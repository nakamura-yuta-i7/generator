/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(1);
	
	var express = __webpack_require__(2);
	var path = __webpack_require__(3);
	var favicon = __webpack_require__(4);
	var logger = __webpack_require__(5);
	var cookieParser = __webpack_require__(6);
	var bodyParser = __webpack_require__(7);
	
	var routes = __webpack_require__(8);
	var users = __webpack_require__(9);
	
	var app = express();
	app.set('views', './dist/server/views');
	app.set('view engine', 'jade');
	//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));
	app.use(logger('dev'));
	app.use(bodyParser.json());
	app.use(bodyParser.urlencoded({ extended: false }));
	app.use(cookieParser());
	app.use(express.static('./dist/public'));
	
	app.use('/', routes);
	app.use('/users', users);
	
	// catch 404 and forward to error handler
	app.use(function (req, res, next) {
	  var err = new Error('Not Found');
	  err.status = 404;
	  next(err);
	});
	
	// error handlers
	
	// development error handler
	// will print stacktrace
	if (app.get('env') === 'development') {
	  app.use(function (err, req, res, next) {
	    res.status(err.status || 500);
	    res.render('error', {
	      message: err.message,
	      error: err
	    });
	  });
	}
	
	// production error handler
	// no stacktraces leaked to user
	app.use(function (err, req, res, next) {
	  res.status(err.status || 500);
	  res.render('error', {
	    message: err.message,
	    error: {}
	  });
	});
	
	var debug = __webpack_require__(10)('generator:server');
	var http = __webpack_require__(11);
	var port = normalizePort(process.env.PORT || '3000');
	app.set('port', port);
	var server = http.createServer(app);
	server.listen(port);
	server.on('error', onError);
	server.on('listening', onListening);
	
	function normalizePort(val) {
	  var port = parseInt(val, 10);
	
	  if (isNaN(port)) {
	    // named pipe
	    return val;
	  }
	
	  if (port >= 0) {
	    // port number
	    return port;
	  }
	
	  return false;
	}
	function onError(error) {
	  if (error.syscall !== 'listen') {
	    throw error;
	  }
	
	  var bind = typeof port === 'string' ? 'Pipe ' + port : 'Port ' + port;
	
	  // handle specific listen errors with friendly messages
	  switch (error.code) {
	    case 'EACCES':
	      console.error(bind + ' requires elevated privileges');
	      process.exit(1);
	      break;
	    case 'EADDRINUSE':
	      console.error(bind + ' is already in use');
	      process.exit(1);
	      break;
	    default:
	      throw error;
	  }
	}
	function onListening() {
	  var addr = server.address();
	  var bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port;
	  debug('Listening on ' + bind);
	}

/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = require("babel-polyfill");

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = require("express");

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = require("serve-favicon");

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = require("morgan");

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = require("cookie-parser");

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = require("body-parser");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var express = __webpack_require__(2);
	var router = express.Router();
	
	/* GET home page. */
	router.get('/', function (req, res, next) {
	
		var co = __webpack_require__(12);
		var thunkify = __webpack_require__(13);
	
		function sleep(param, callback) {
			setTimeout(function () {
				callback(null, 'I woke up (' + param + ') at ' + new Date());
			}, 1000);
		}
		var sleep = thunkify(sleep);
	
		co(regeneratorRuntime.mark(function _callee() {
			return regeneratorRuntime.wrap(function _callee$(_context) {
				while (1) {
					switch (_context.prev = _context.next) {
						case 0:
							_context.t0 = console;
							_context.next = 3;
							return sleep(1);
	
						case 3:
							_context.t1 = _context.sent;
	
							_context.t0.log.call(_context.t0, "1:", _context.t1);
	
							_context.t2 = console;
							_context.next = 8;
							return sleep(2);
	
						case 8:
							_context.t3 = _context.sent;
	
							_context.t2.log.call(_context.t2, "2:", _context.t3);
	
							_context.t4 = console;
							_context.next = 13;
							return sleep(3);
	
						case 13:
							_context.t5 = _context.sent;
	
							_context.t4.log.call(_context.t4, "3:", _context.t5);
	
							_context.t6 = console;
							_context.next = 18;
							return sleep(4);
	
						case 18:
							_context.t7 = _context.sent;
	
							_context.t6.log.call(_context.t6, "4:", _context.t7);
	
							_context.t8 = console;
							_context.next = 23;
							return sleep(5);
	
						case 23:
							_context.t9 = _context.sent;
	
							_context.t8.log.call(_context.t8, "5:", _context.t9);
	
						case 25:
						case 'end':
							return _context.stop();
					}
				}
			}, _callee, this);
		}));
	
		res.render('index', { title: 'Express' });
	});
	
	module.exports = router;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var express = __webpack_require__(2);
	var router = express.Router();
	
	var co = __webpack_require__(12);
	var thunkify = __webpack_require__(13);
	var db = __webpack_require__(15);
	
	/* GET users listing. */
	router.get('/', function (req, res, next) {
		var query = thunkify(db.query.bind(db));
	
		co(regeneratorRuntime.mark(function _callee() {
			var result;
			return regeneratorRuntime.wrap(function _callee$(_context) {
				while (1) {
					switch (_context.prev = _context.next) {
						case 0:
							_context.next = 2;
							return query("select * from users");
	
						case 2:
							result = _context.sent;
	
							res.json(result[0]);
	
						case 4:
						case "end":
							return _context.stop();
					}
				}
			}, _callee, this);
		}));
	});
	
	module.exports = router;

/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = require("debug");

/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = require("http");

/***/ },
/* 12 */
/***/ function(module, exports) {

	
	/**
	 * slice() reference.
	 */
	
	var slice = Array.prototype.slice;
	
	/**
	 * Expose `co`.
	 */
	
	module.exports = co['default'] = co.co = co;
	
	/**
	 * Wrap the given generator `fn` into a
	 * function that returns a promise.
	 * This is a separate function so that
	 * every `co()` call doesn't create a new,
	 * unnecessary closure.
	 *
	 * @param {GeneratorFunction} fn
	 * @return {Function}
	 * @api public
	 */
	
	co.wrap = function (fn) {
	  createPromise.__generatorFunction__ = fn;
	  return createPromise;
	  function createPromise() {
	    return co.call(this, fn.apply(this, arguments));
	  }
	};
	
	/**
	 * Execute the generator function or a generator
	 * and return a promise.
	 *
	 * @param {Function} fn
	 * @return {Promise}
	 * @api public
	 */
	
	function co(gen) {
	  var ctx = this;
	  var args = slice.call(arguments, 1)
	
	  // we wrap everything in a promise to avoid promise chaining,
	  // which leads to memory leak errors.
	  // see https://github.com/tj/co/issues/180
	  return new Promise(function(resolve, reject) {
	    if (typeof gen === 'function') gen = gen.apply(ctx, args);
	    if (!gen || typeof gen.next !== 'function') return resolve(gen);
	
	    onFulfilled();
	
	    /**
	     * @param {Mixed} res
	     * @return {Promise}
	     * @api private
	     */
	
	    function onFulfilled(res) {
	      var ret;
	      try {
	        ret = gen.next(res);
	      } catch (e) {
	        return reject(e);
	      }
	      next(ret);
	    }
	
	    /**
	     * @param {Error} err
	     * @return {Promise}
	     * @api private
	     */
	
	    function onRejected(err) {
	      var ret;
	      try {
	        ret = gen.throw(err);
	      } catch (e) {
	        return reject(e);
	      }
	      next(ret);
	    }
	
	    /**
	     * Get the next value in the generator,
	     * return a promise.
	     *
	     * @param {Object} ret
	     * @return {Promise}
	     * @api private
	     */
	
	    function next(ret) {
	      if (ret.done) return resolve(ret.value);
	      var value = toPromise.call(ctx, ret.value);
	      if (value && isPromise(value)) return value.then(onFulfilled, onRejected);
	      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '
	        + 'but the following object was passed: "' + String(ret.value) + '"'));
	    }
	  });
	}
	
	/**
	 * Convert a `yield`ed value into a promise.
	 *
	 * @param {Mixed} obj
	 * @return {Promise}
	 * @api private
	 */
	
	function toPromise(obj) {
	  if (!obj) return obj;
	  if (isPromise(obj)) return obj;
	  if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);
	  if ('function' == typeof obj) return thunkToPromise.call(this, obj);
	  if (Array.isArray(obj)) return arrayToPromise.call(this, obj);
	  if (isObject(obj)) return objectToPromise.call(this, obj);
	  return obj;
	}
	
	/**
	 * Convert a thunk to a promise.
	 *
	 * @param {Function}
	 * @return {Promise}
	 * @api private
	 */
	
	function thunkToPromise(fn) {
	  var ctx = this;
	  return new Promise(function (resolve, reject) {
	    fn.call(ctx, function (err, res) {
	      if (err) return reject(err);
	      if (arguments.length > 2) res = slice.call(arguments, 1);
	      resolve(res);
	    });
	  });
	}
	
	/**
	 * Convert an array of "yieldables" to a promise.
	 * Uses `Promise.all()` internally.
	 *
	 * @param {Array} obj
	 * @return {Promise}
	 * @api private
	 */
	
	function arrayToPromise(obj) {
	  return Promise.all(obj.map(toPromise, this));
	}
	
	/**
	 * Convert an object of "yieldables" to a promise.
	 * Uses `Promise.all()` internally.
	 *
	 * @param {Object} obj
	 * @return {Promise}
	 * @api private
	 */
	
	function objectToPromise(obj){
	  var results = new obj.constructor();
	  var keys = Object.keys(obj);
	  var promises = [];
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var promise = toPromise.call(this, obj[key]);
	    if (promise && isPromise(promise)) defer(promise, key);
	    else results[key] = obj[key];
	  }
	  return Promise.all(promises).then(function () {
	    return results;
	  });
	
	  function defer(promise, key) {
	    // predefine the key in the result
	    results[key] = undefined;
	    promises.push(promise.then(function (res) {
	      results[key] = res;
	    }));
	  }
	}
	
	/**
	 * Check if `obj` is a promise.
	 *
	 * @param {Object} obj
	 * @return {Boolean}
	 * @api private
	 */
	
	function isPromise(obj) {
	  return 'function' == typeof obj.then;
	}
	
	/**
	 * Check if `obj` is a generator.
	 *
	 * @param {Mixed} obj
	 * @return {Boolean}
	 * @api private
	 */
	
	function isGenerator(obj) {
	  return 'function' == typeof obj.next && 'function' == typeof obj.throw;
	}
	
	/**
	 * Check if `obj` is a generator function.
	 *
	 * @param {Mixed} obj
	 * @return {Boolean}
	 * @api private
	 */
	function isGeneratorFunction(obj) {
	  var constructor = obj.constructor;
	  if (!constructor) return false;
	  if ('GeneratorFunction' === constructor.name || 'GeneratorFunction' === constructor.displayName) return true;
	  return isGenerator(constructor.prototype);
	}
	
	/**
	 * Check for plain object.
	 *
	 * @param {Mixed} val
	 * @return {Boolean}
	 * @api private
	 */
	
	function isObject(val) {
	  return Object == val.constructor;
	}


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var assert = __webpack_require__(14);
	
	/**
	 * Expose `thunkify()`.
	 */
	
	module.exports = thunkify;
	
	/**
	 * Wrap a regular callback `fn` as a thunk.
	 *
	 * @param {Function} fn
	 * @return {Function}
	 * @api public
	 */
	
	function thunkify(fn){
	  assert('function' == typeof fn, 'function required');
	
	  return function(){
	    var args = new Array(arguments.length);
	    var ctx = this;
	
	    for(var i = 0; i < args.length; ++i) {
	      args[i] = arguments[i];
	    }
	
	    return function(done){
	      var called;
	
	      args.push(function(){
	        if (called) return;
	        called = true;
	        done.apply(null, arguments);
	      });
	
	      try {
	        fn.apply(ctx, args);
	      } catch (err) {
	        done(err);
	      }
	    }
	  }
	};


/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = require("assert");

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var mysql = __webpack_require__(16);
	var connection = mysql.createConnection({
	  host: 'localhost',
	  user: 'root',
	  password: 'yuta0502',
	  database: 'express4-sample'
	});
	
	module.exports = connection;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var Classes = Object.create(null);
	
	/**
	 * Create a new Connection instance.
	 * @param {object} config
	 * @public
	 */
	exports.createConnection = function createConnection(config) {
	  var Connection       = loadClass('Connection');
	  var ConnectionConfig = loadClass('ConnectionConfig');
	
	  return new Connection({config: new ConnectionConfig(config)});
	};
	
	/**
	 * Create a new Pool instance.
	 * @param {object} config
	 * @public
	 */
	exports.createPool = function createPool(config) {
	  var Pool       = loadClass('Pool');
	  var PoolConfig = loadClass('PoolConfig');
	
	  return new Pool({config: new PoolConfig(config)});
	};
	
	/**
	 * Create a new PoolCluster instance.
	 * @param {object} config
	 * @public
	 */
	exports.createPoolCluster = function createPoolCluster(config) {
	  var PoolCluster = loadClass('PoolCluster');
	
	  return new PoolCluster(config);
	};
	
	/**
	 * Create a new Query instance.
	 * @public
	 */
	exports.createQuery = function createQuery(sql, values, callback) {
	  var Connection = loadClass('Connection');
	
	  return Connection.createQuery(sql, values, callback);
	};
	
	/**
	 * Escape a value for SQL.
	 * @param {*} value
	 * @param {boolean} [stringifyObjects=false]
	 * @param {string} [timeZone=local]
	 * @public
	 */
	exports.escape = function escape(value, stringifyObjects, timeZone) {
	  var SqlString = loadClass('SqlString');
	
	  return SqlString.escape(value, stringifyObjects, timeZone);
	};
	
	/**
	 * Escape an identifier for SQL.
	 * @param {*} value
	 * @param {boolean} [forbidQualified]
	 * @public
	 */
	exports.escapeId = function escapeId(value, forbidQualified) {
	  var SqlString = loadClass('SqlString');
	
	  return SqlString.escapeId(value, forbidQualified);
	};
	
	/**
	 * Format SQL and replacement values into a SQL string.
	 * @param {string} sql
	 * @param {array} [values]
	 * @param {boolean} [stringifyObjects=false]
	 * @param {string} [timeZone=local]
	 * @public
	 */
	exports.format = function format(sql, values, stringifyObjects, timeZone) {
	  var SqlString = loadClass('SqlString');
	
	  return SqlString.format(sql, values, stringifyObjects, timeZone);
	};
	
	/**
	 * The type constants.
	 * @public
	 */
	Object.defineProperty(exports, 'Types', {
	  get: loadClass.bind(null, 'Types')
	});
	
	/**
	 * Load the given class.
	 * @private
	 */
	function loadClass(className) {
	  var Class = Classes[className];
	
	  if (Class !== undefined) {
	    return Class;
	  }
	
	  // This uses a switch for static require analysis
	  switch (className) {
	    case 'Connection':
	      Class = __webpack_require__(17);
	      break;
	    case 'ConnectionConfig':
	      Class = __webpack_require__(21);
	      break;
	    case 'Pool':
	      Class = __webpack_require__(82);
	      break;
	    case 'PoolCluster':
	      Class = __webpack_require__(84);
	      break;
	    case 'PoolConfig':
	      Class = __webpack_require__(85);
	      break;
	    case 'SqlString':
	      Class = __webpack_require__(81);
	      break;
	    case 'Types':
	      Class = __webpack_require__(46);
	      break;
	    default:
	      throw new Error('Cannot find class \'' + className + '\'');
	  }
	
	  // Store to prevent invoking require()
	  Classes[className] = Class;
	
	  return Class;
	}


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var Crypto           = __webpack_require__(18);
	var Net              = __webpack_require__(19);
	var tls              = __webpack_require__(20);
	var ConnectionConfig = __webpack_require__(21);
	var Protocol         = __webpack_require__(26);
	var SqlString        = __webpack_require__(81);
	var Query            = __webpack_require__(62);
	var EventEmitter     = __webpack_require__(34).EventEmitter;
	var Util             = __webpack_require__(33);
	
	module.exports = Connection;
	Util.inherits(Connection, EventEmitter);
	function Connection(options) {
	  EventEmitter.call(this);
	
	  this.config = options.config;
	
	  this._socket        = options.socket;
	  this._protocol      = new Protocol({config: this.config, connection: this});
	  this._connectCalled = false;
	  this.state          = "disconnected";
	  this.threadId       = null;
	}
	
	function bindToCurrentDomain(callback) {
	  if (!callback) return;
	
	  var domain = process.domain;
	
	  return domain
	    ? domain.bind(callback)
	    : callback;
	}
	
	Connection.createQuery = function createQuery(sql, values, callback) {
	  if (sql instanceof Query) {
	    return sql;
	  }
	
	  var cb      = bindToCurrentDomain(callback);
	  var options = {};
	
	  if (typeof sql === 'function') {
	    cb = bindToCurrentDomain(sql);
	    return new Query(options, cb);
	  }
	
	  if (typeof sql === 'object') {
	    for (var prop in sql) {
	      options[prop] = sql[prop];
	    }
	
	    if (typeof values === 'function') {
	      cb = bindToCurrentDomain(values);
	    } else if (values !== undefined) {
	      options.values = values;
	    }
	
	    return new Query(options, cb);
	  }
	
	  options.sql    = sql;
	  options.values = values;
	
	  if (typeof values === 'function') {
	    cb = bindToCurrentDomain(values);
	    options.values = undefined;
	  }
	
	  if (cb === undefined && callback !== undefined) {
	    throw new TypeError('argument callback must be a function when provided');
	  }
	
	  return new Query(options, cb);
	};
	
	Connection.prototype.connect = function connect(options, callback) {
	  if (!callback && typeof options === 'function') {
	    callback = options;
	    options = {};
	  }
	
	  if (!this._connectCalled) {
	    this._connectCalled = true;
	
	    // Connect either via a UNIX domain socket or a TCP socket.
	    this._socket = (this.config.socketPath)
	      ? Net.createConnection(this.config.socketPath)
	      : Net.createConnection(this.config.port, this.config.host);
	
	    var connection = this;
	    this._protocol.on('data', function(data) {
	       connection._socket.write(data);
	    });
	    this._socket.on('data', function(data) {
	      connection._protocol.write(data);
	    });
	    this._protocol.on('end', function() {
	       connection._socket.end()
	    });
	    this._socket.on('end', function(err) {
	      connection._protocol.end();
	    });
	
	    this._socket.on('error', this._handleNetworkError.bind(this));
	    this._socket.on('connect', this._handleProtocolConnect.bind(this));
	    this._protocol.on('handshake', this._handleProtocolHandshake.bind(this));
	    this._protocol.on('unhandledError', this._handleProtocolError.bind(this));
	    this._protocol.on('drain', this._handleProtocolDrain.bind(this));
	    this._protocol.on('end', this._handleProtocolEnd.bind(this));
	    this._protocol.on('enqueue', this._handleProtocolEnqueue.bind(this));
	
	    if (this.config.connectTimeout) {
	      var handleConnectTimeout = this._handleConnectTimeout.bind(this);
	
	      this._socket.setTimeout(this.config.connectTimeout, handleConnectTimeout);
	      this._socket.once('connect', function() {
	        this.setTimeout(0, handleConnectTimeout);
	      });
	    }
	  }
	
	  this._protocol.handshake(options, bindToCurrentDomain(callback));
	};
	
	Connection.prototype.changeUser = function changeUser(options, callback) {
	  if (!callback && typeof options === 'function') {
	    callback = options;
	    options = {};
	  }
	
	  this._implyConnect();
	
	  var charsetNumber = (options.charset)
	    ? ConnectionConfig.getCharsetNumber(options.charset)
	    : this.config.charsetNumber;
	
	  return this._protocol.changeUser({
	    user          : options.user || this.config.user,
	    password      : options.password || this.config.password,
	    database      : options.database || this.config.database,
	    timeout       : options.timeout,
	    charsetNumber : charsetNumber,
	    currentConfig : this.config
	  }, bindToCurrentDomain(callback));
	};
	
	Connection.prototype.beginTransaction = function beginTransaction(options, callback) {
	  if (!callback && typeof options === 'function') {
	    callback = options;
	    options = {};
	  }
	
	  options = options || {};
	  options.sql = 'START TRANSACTION';
	  options.values = null;
	  
	  return this.query(options, callback);
	};
	
	Connection.prototype.commit = function commit(options, callback) {
	  if (!callback && typeof options === 'function') {
	    callback = options;
	    options = {};
	  }
	
	  options = options || {};
	  options.sql = 'COMMIT';
	  options.values = null;
	  
	  return this.query(options, callback);
	};
	
	Connection.prototype.rollback = function rollback(options, callback) {
	  if (!callback && typeof options === 'function') {
	    callback = options;
	    options = {};
	  }
	
	  options = options || {};
	  options.sql = 'ROLLBACK';
	  options.values = null;
	  
	  return this.query(options, callback);
	};
	
	Connection.prototype.query = function query(sql, values, cb) {
	  var query = Connection.createQuery(sql, values, cb);
	  query._connection = this;
	
	  if (!(typeof sql == 'object' && 'typeCast' in sql)) {
	    query.typeCast = this.config.typeCast;
	  }
	
	  if (query.sql) {
	    query.sql = this.format(query.sql, query.values);
	  }
	
	  this._implyConnect();
	
	  return this._protocol._enqueue(query);
	};
	
	Connection.prototype.ping = function ping(options, callback) {
	  if (!callback && typeof options === 'function') {
	    callback = options;
	    options = {};
	  }
	
	  this._implyConnect();
	  this._protocol.ping(options, bindToCurrentDomain(callback));
	};
	
	Connection.prototype.statistics = function statistics(options, callback) {
	  if (!callback && typeof options === 'function') {
	    callback = options;
	    options = {};
	  }
	
	  this._implyConnect();
	  this._protocol.stats(options, bindToCurrentDomain(callback));
	};
	
	Connection.prototype.end = function end(options, callback) {
	  var cb   = callback;
	  var opts = options;
	
	  if (!callback && typeof options === 'function') {
	    cb   = options;
	    opts = null;
	  }
	
	  // create custom options reference
	  opts = Object.create(opts || null)
	
	  if (opts.timeout === undefined) {
	    // default timeout of 30 seconds
	    opts.timeout = 30000;
	  }
	
	  this._implyConnect();
	  this._protocol.quit(opts, bindToCurrentDomain(cb));
	};
	
	Connection.prototype.destroy = function() {
	  this.state = "disconnected";
	  this._implyConnect();
	  this._socket.destroy();
	  this._protocol.destroy();
	};
	
	Connection.prototype.pause = function() {
	  this._socket.pause();
	  this._protocol.pause();
	};
	
	Connection.prototype.resume = function() {
	  this._socket.resume();
	  this._protocol.resume();
	};
	
	Connection.prototype.escape = function(value) {
	  return SqlString.escape(value, false, this.config.timezone);
	};
	
	Connection.prototype.escapeId = function escapeId(value) {
	  return SqlString.escapeId(value, false);
	};
	
	Connection.prototype.format = function(sql, values) {
	  if (typeof this.config.queryFormat == "function") {
	    return this.config.queryFormat.call(this, sql, values, this.config.timezone);
	  }
	  return SqlString.format(sql, values, this.config.stringifyObjects, this.config.timezone);
	};
	
	if (tls.TLSSocket) {
	  // 0.11+ environment
	  Connection.prototype._startTLS = function _startTLS(onSecure) {
	    var secureContext = tls.createSecureContext({
	      ca         : this.config.ssl.ca,
	      cert       : this.config.ssl.cert,
	      ciphers    : this.config.ssl.ciphers,
	      key        : this.config.ssl.key,
	      passphrase : this.config.ssl.passphrase
	    });
	
	    // "unpipe"
	    this._socket.removeAllListeners('data');
	    this._protocol.removeAllListeners('data');
	
	    // socket <-> encrypted
	    var rejectUnauthorized = this.config.ssl.rejectUnauthorized;
	    var secureSocket       = new tls.TLSSocket(this._socket, {
	      rejectUnauthorized : rejectUnauthorized,
	      requestCert        : true,
	      secureContext      : secureContext,
	      isServer           : false
	    });
	
	    // cleartext <-> protocol
	    secureSocket.pipe(this._protocol);
	    this._protocol.on('data', function(data) {
	      secureSocket.write(data);
	    });
	
	    secureSocket.on('secure', function() {
	      onSecure(rejectUnauthorized ? this.ssl.verifyError() : null);
	    });
	
	    // start TLS communications
	    secureSocket._start();
	  };
	} else {
	  // pre-0.11 environment
	  Connection.prototype._startTLS = function _startTLS(onSecure) {
	    // before TLS:
	    //  _socket <-> _protocol
	    // after:
	    //  _socket <-> securePair.encrypted <-> securePair.cleartext <-> _protocol
	
	    var credentials = Crypto.createCredentials({
	      ca         : this.config.ssl.ca,
	      cert       : this.config.ssl.cert,
	      ciphers    : this.config.ssl.ciphers,
	      key        : this.config.ssl.key,
	      passphrase : this.config.ssl.passphrase
	    });
	
	    var rejectUnauthorized = this.config.ssl.rejectUnauthorized;
	    var securePair         = tls.createSecurePair(credentials, false, true, rejectUnauthorized);
	
	    // "unpipe"
	    this._socket.removeAllListeners('data');
	    this._protocol.removeAllListeners('data');
	
	    // socket <-> encrypted
	    securePair.encrypted.pipe(this._socket);
	    this._socket.on('data', function(data) {
	      securePair.encrypted.write(data);
	    });
	
	    // cleartext <-> protocol
	    securePair.cleartext.pipe(this._protocol);
	    this._protocol.on('data', function(data) {
	      securePair.cleartext.write(data);
	    });
	
	    securePair.on('secure', function() {
	      if (!rejectUnauthorized) {
	        onSecure();
	        return;
	      }
	
	      var verifyError = this.ssl.verifyError();
	      var err = verifyError;
	
	      // node.js 0.6 support
	      if (typeof err === 'string') {
	        err = new Error(verifyError);
	        err.code = verifyError;
	      }
	
	      onSecure(err);
	    });
	  };
	}
	
	Connection.prototype._handleConnectTimeout = function() {
	  if (this._socket) {
	    this._socket.setTimeout(0);
	    this._socket.destroy();
	  }
	
	  var err = new Error('connect ETIMEDOUT');
	  err.errorno = 'ETIMEDOUT';
	  err.code = 'ETIMEDOUT';
	  err.syscall = 'connect';
	
	  this._handleNetworkError(err);
	};
	
	Connection.prototype._handleNetworkError = function(err) {
	  this._protocol.handleNetworkError(err);
	};
	
	Connection.prototype._handleProtocolError = function(err) {
	  this.state = "protocol_error";
	  this.emit('error', err);
	};
	
	Connection.prototype._handleProtocolDrain = function() {
	  this.emit('drain');
	};
	
	Connection.prototype._handleProtocolConnect = function() {
	  this.state = "connected";
	  this.emit('connect');
	};
	
	Connection.prototype._handleProtocolHandshake = function _handleProtocolHandshake(packet) {
	  this.state    = "authenticated";
	  this.threadId = packet.threadId;
	};
	
	Connection.prototype._handleProtocolEnd = function(err) {
	  this.state = "disconnected";
	  this.emit('end', err);
	};
	
	Connection.prototype._handleProtocolEnqueue = function _handleProtocolEnqueue(sequence) {
	  this.emit('enqueue', sequence);
	};
	
	Connection.prototype._implyConnect = function() {
	  if (!this._connectCalled) {
	    this.connect();
	  }
	};


/***/ },
/* 18 */
/***/ function(module, exports) {

	module.exports = require("crypto");

/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = require("net");

/***/ },
/* 20 */
/***/ function(module, exports) {

	module.exports = require("tls");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var urlParse        = __webpack_require__(22).parse;
	var ClientConstants = __webpack_require__(23);
	var Charsets        = __webpack_require__(24);
	var SSLProfiles     = null;
	
	module.exports = ConnectionConfig;
	function ConnectionConfig(options) {
	  if (typeof options === 'string') {
	    options = ConnectionConfig.parseUrl(options);
	  }
	
	  this.host               = options.host || 'localhost';
	  this.port               = options.port || 3306;
	  this.localAddress       = options.localAddress;
	  this.socketPath         = options.socketPath;
	  this.user               = options.user || undefined;
	  this.password           = options.password || undefined;
	  this.database           = options.database;
	  this.connectTimeout     = (options.connectTimeout === undefined)
	    ? (10 * 1000)
	    : options.connectTimeout;
	  this.insecureAuth       = options.insecureAuth || false;
	  this.supportBigNumbers  = options.supportBigNumbers || false;
	  this.bigNumberStrings   = options.bigNumberStrings || false;
	  this.dateStrings        = options.dateStrings || false;
	  this.debug              = options.debug;
	  this.trace              = options.trace !== false;
	  this.stringifyObjects   = options.stringifyObjects || false;
	  this.timezone           = options.timezone || 'local';
	  this.flags              = options.flags || '';
	  this.queryFormat        = options.queryFormat;
	  this.pool               = options.pool || undefined;
	  this.ssl                = (typeof options.ssl === 'string')
	    ? ConnectionConfig.getSSLProfile(options.ssl)
	    : (options.ssl || false);
	  this.multipleStatements = options.multipleStatements || false; 
	  this.typeCast           = (options.typeCast === undefined)
	    ? true
	    : options.typeCast;
	
	  if (this.timezone[0] == " ") {
	    // "+" is a url encoded char for space so it
	    // gets translated to space when giving a
	    // connection string..
	    this.timezone = "+" + this.timezone.substr(1);
	  }
	
	  if (this.ssl) {
	    // Default rejectUnauthorized to true
	    this.ssl.rejectUnauthorized = this.ssl.rejectUnauthorized !== false;
	  }
	
	  this.maxPacketSize = 0;
	  this.charsetNumber = (options.charset)
	    ? ConnectionConfig.getCharsetNumber(options.charset)
	    : options.charsetNumber||Charsets.UTF8_GENERAL_CI;
	
	  // Set the client flags
	  var defaultFlags = ConnectionConfig.getDefaultFlags(options);
	  this.clientFlags = ConnectionConfig.mergeFlags(defaultFlags, options.flags)
	}
	
	ConnectionConfig.mergeFlags = function mergeFlags(defaultFlags, userFlags) {
	  var allFlags = ConnectionConfig.parseFlagList(defaultFlags);
	  var newFlags = ConnectionConfig.parseFlagList(userFlags);
	
	  // Merge the new flags
	  for (var flag in newFlags) {
	    if (allFlags[flag] !== false) {
	      allFlags[flag] = newFlags[flag];
	    }
	  }
	
	  // Build flags
	  var flags = 0x0;
	  for (var flag in allFlags) {
	    if (allFlags[flag]) {
	      // TODO: Throw here on some future release
	      flags |= ClientConstants['CLIENT_' + flag] || 0x0;
	    }
	  }
	
	  return flags;
	};
	
	ConnectionConfig.getCharsetNumber = function getCharsetNumber(charset) {
	  var num = Charsets[charset.toUpperCase()];
	
	  if (num === undefined) {
	    throw new TypeError('Unknown charset \'' + charset + '\'');
	  }
	
	  return num;
	};
	
	ConnectionConfig.getDefaultFlags = function getDefaultFlags(options) {
	  var defaultFlags = [
	    '-COMPRESS',          // Compression protocol *NOT* supported
	    '-CONNECT_ATTRS',     // Does *NOT* send connection attributes in Protocol::HandshakeResponse41
	    '+CONNECT_WITH_DB',   // One can specify db on connect in Handshake Response Packet
	    '+FOUND_ROWS',        // Send found rows instead of affected rows
	    '+IGNORE_SIGPIPE',    // Don't issue SIGPIPE if network failures
	    '+IGNORE_SPACE',      // Let the parser ignore spaces before '('
	    '+LOCAL_FILES',       // Can use LOAD DATA LOCAL
	    '+LONG_FLAG',         // Longer flags in Protocol::ColumnDefinition320
	    '+LONG_PASSWORD',     // Use the improved version of Old Password Authentication
	    '+MULTI_RESULTS',     // Can handle multiple resultsets for COM_QUERY
	    '+ODBC',              // Special handling of ODBC behaviour
	    '-PLUGIN_AUTH',       // Does *NOT* support auth plugins
	    '+PROTOCOL_41',       // Uses the 4.1 protocol
	    '+PS_MULTI_RESULTS',  // Can handle multiple resultsets for COM_STMT_EXECUTE
	    '+RESERVED',          // Unused
	    '+SECURE_CONNECTION', // Supports Authentication::Native41
	    '+TRANSACTIONS'       // Expects status flags
	  ];
	
	  if (options && options.multipleStatements) {
	    // May send multiple statements per COM_QUERY and COM_STMT_PREPARE
	    defaultFlags.push('+MULTI_STATEMENTS');
	  }
	
	  return defaultFlags;
	};
	
	ConnectionConfig.getSSLProfile = function getSSLProfile(name) {
	  if (!SSLProfiles) {
	    SSLProfiles = __webpack_require__(25);
	  }
	
	  var ssl = SSLProfiles[name];
	
	  if (ssl === undefined) {
	    throw new TypeError('Unknown SSL profile \'' + name + '\'');
	  }
	
	  return ssl;
	};
	
	ConnectionConfig.parseFlagList = function parseFlagList(flagList) {
	  var allFlags = Object.create(null);
	
	  if (!flagList) {
	    return allFlags;
	  }
	
	  var flags = !Array.isArray(flagList)
	    ? String(flagList || '').toUpperCase().split(/\s*,+\s*/)
	    : flagList;
	
	  for (var i = 0; i < flags.length; i++) {
	    var flag   = flags[i];
	    var offset = 1;
	    var state  = flag[0];
	
	    if (state === undefined) {
	      // TODO: throw here on some future release
	      continue;
	    }
	
	    if (state !== '-' && state !== '+') {
	      offset = 0;
	      state  = '+';
	    }
	
	    allFlags[flag.substr(offset)] = state === '+';
	  }
	
	  return allFlags;
	};
	
	ConnectionConfig.parseUrl = function(url) {
	  url = urlParse(url, true);
	
	  var options = {
	    host     : url.hostname,
	    port     : url.port,
	    database : url.pathname.substr(1),
	  };
	
	  if (url.auth) {
	    var auth = url.auth.split(':');
	    options.user     = auth[0];
	    options.password = auth[1];
	  }
	
	  if (url.query) {
	    for (var key in url.query) {
	      var value = url.query[key];
	
	      try {
	        // Try to parse this as a JSON expression first
	        options[key] = JSON.parse(value);
	      } catch (err) {
	        // Otherwise assume it is a plain string
	        options[key] = value;
	      }
	    }
	  }
	
	  return options;
	};


/***/ },
/* 22 */
/***/ function(module, exports) {

	module.exports = require("url");

/***/ },
/* 23 */
/***/ function(module, exports) {

	// Manually extracted from mysql-5.5.23/include/mysql_com.h
	exports.CLIENT_LONG_PASSWORD     = 1; /* new more secure passwords */
	exports.CLIENT_FOUND_ROWS        = 2; /* Found instead of affected rows */
	exports.CLIENT_LONG_FLAG         = 4; /* Get all column flags */
	exports.CLIENT_CONNECT_WITH_DB   = 8; /* One can specify db on connect */
	exports.CLIENT_NO_SCHEMA         = 16; /* Don't allow database.table.column */
	exports.CLIENT_COMPRESS          = 32; /* Can use compression protocol */
	exports.CLIENT_ODBC              = 64; /* Odbc client */
	exports.CLIENT_LOCAL_FILES       = 128; /* Can use LOAD DATA LOCAL */
	exports.CLIENT_IGNORE_SPACE      = 256; /* Ignore spaces before '(' */
	exports.CLIENT_PROTOCOL_41       = 512; /* New 4.1 protocol */
	exports.CLIENT_INTERACTIVE       = 1024; /* This is an interactive client */
	exports.CLIENT_SSL               = 2048; /* Switch to SSL after handshake */
	exports.CLIENT_IGNORE_SIGPIPE    = 4096;    /* IGNORE sigpipes */
	exports.CLIENT_TRANSACTIONS      = 8192; /* Client knows about transactions */
	exports.CLIENT_RESERVED          = 16384;   /* Old flag for 4.1 protocol  */
	exports.CLIENT_SECURE_CONNECTION = 32768;  /* New 4.1 authentication */
	
	exports.CLIENT_MULTI_STATEMENTS = 65536; /* Enable/disable multi-stmt support */
	exports.CLIENT_MULTI_RESULTS    = 131072; /* Enable/disable multi-results */
	exports.CLIENT_PS_MULTI_RESULTS = 262144; /* Multi-results in PS-protocol */
	
	exports.CLIENT_PLUGIN_AUTH = 524288; /* Client supports plugin authentication */
	
	exports.CLIENT_SSL_VERIFY_SERVER_CERT = 1073741824;
	exports.CLIENT_REMEMBER_OPTIONS       = 2147483648;


/***/ },
/* 24 */
/***/ function(module, exports) {

	exports.BIG5_CHINESE_CI              = 1;
	exports.LATIN2_CZECH_CS              = 2;
	exports.DEC8_SWEDISH_CI              = 3;
	exports.CP850_GENERAL_CI             = 4;
	exports.LATIN1_GERMAN1_CI            = 5;
	exports.HP8_ENGLISH_CI               = 6;
	exports.KOI8R_GENERAL_CI             = 7;
	exports.LATIN1_SWEDISH_CI            = 8;
	exports.LATIN2_GENERAL_CI            = 9;
	exports.SWE7_SWEDISH_CI              = 10;
	exports.ASCII_GENERAL_CI             = 11;
	exports.UJIS_JAPANESE_CI             = 12;
	exports.SJIS_JAPANESE_CI             = 13;
	exports.CP1251_BULGARIAN_CI          = 14;
	exports.LATIN1_DANISH_CI             = 15;
	exports.HEBREW_GENERAL_CI            = 16;
	exports.TIS620_THAI_CI               = 18;
	exports.EUCKR_KOREAN_CI              = 19;
	exports.LATIN7_ESTONIAN_CS           = 20;
	exports.LATIN2_HUNGARIAN_CI          = 21;
	exports.KOI8U_GENERAL_CI             = 22;
	exports.CP1251_UKRAINIAN_CI          = 23;
	exports.GB2312_CHINESE_CI            = 24;
	exports.GREEK_GENERAL_CI             = 25;
	exports.CP1250_GENERAL_CI            = 26;
	exports.LATIN2_CROATIAN_CI           = 27;
	exports.GBK_CHINESE_CI               = 28;
	exports.CP1257_LITHUANIAN_CI         = 29;
	exports.LATIN5_TURKISH_CI            = 30;
	exports.LATIN1_GERMAN2_CI            = 31;
	exports.ARMSCII8_GENERAL_CI          = 32;
	exports.UTF8_GENERAL_CI              = 33;
	exports.CP1250_CZECH_CS              = 34;
	exports.UCS2_GENERAL_CI              = 35;
	exports.CP866_GENERAL_CI             = 36;
	exports.KEYBCS2_GENERAL_CI           = 37;
	exports.MACCE_GENERAL_CI             = 38;
	exports.MACROMAN_GENERAL_CI          = 39;
	exports.CP852_GENERAL_CI             = 40;
	exports.LATIN7_GENERAL_CI            = 41;
	exports.LATIN7_GENERAL_CS            = 42;
	exports.MACCE_BIN                    = 43;
	exports.CP1250_CROATIAN_CI           = 44;
	exports.UTF8MB4_GENERAL_CI           = 45;
	exports.UTF8MB4_BIN                  = 46;
	exports.LATIN1_BIN                   = 47;
	exports.LATIN1_GENERAL_CI            = 48;
	exports.LATIN1_GENERAL_CS            = 49;
	exports.CP1251_BIN                   = 50;
	exports.CP1251_GENERAL_CI            = 51;
	exports.CP1251_GENERAL_CS            = 52;
	exports.MACROMAN_BIN                 = 53;
	exports.UTF16_GENERAL_CI             = 54;
	exports.UTF16_BIN                    = 55;
	exports.UTF16LE_GENERAL_CI           = 56;
	exports.CP1256_GENERAL_CI            = 57;
	exports.CP1257_BIN                   = 58;
	exports.CP1257_GENERAL_CI            = 59;
	exports.UTF32_GENERAL_CI             = 60;
	exports.UTF32_BIN                    = 61;
	exports.UTF16LE_BIN                  = 62;
	exports.BINARY                       = 63;
	exports.ARMSCII8_BIN                 = 64;
	exports.ASCII_BIN                    = 65;
	exports.CP1250_BIN                   = 66;
	exports.CP1256_BIN                   = 67;
	exports.CP866_BIN                    = 68;
	exports.DEC8_BIN                     = 69;
	exports.GREEK_BIN                    = 70;
	exports.HEBREW_BIN                   = 71;
	exports.HP8_BIN                      = 72;
	exports.KEYBCS2_BIN                  = 73;
	exports.KOI8R_BIN                    = 74;
	exports.KOI8U_BIN                    = 75;
	exports.LATIN2_BIN                   = 77;
	exports.LATIN5_BIN                   = 78;
	exports.LATIN7_BIN                   = 79;
	exports.CP850_BIN                    = 80;
	exports.CP852_BIN                    = 81;
	exports.SWE7_BIN                     = 82;
	exports.UTF8_BIN                     = 83;
	exports.BIG5_BIN                     = 84;
	exports.EUCKR_BIN                    = 85;
	exports.GB2312_BIN                   = 86;
	exports.GBK_BIN                      = 87;
	exports.SJIS_BIN                     = 88;
	exports.TIS620_BIN                   = 89;
	exports.UCS2_BIN                     = 90;
	exports.UJIS_BIN                     = 91;
	exports.GEOSTD8_GENERAL_CI           = 92;
	exports.GEOSTD8_BIN                  = 93;
	exports.LATIN1_SPANISH_CI            = 94;
	exports.CP932_JAPANESE_CI            = 95;
	exports.CP932_BIN                    = 96;
	exports.EUCJPMS_JAPANESE_CI          = 97;
	exports.EUCJPMS_BIN                  = 98;
	exports.CP1250_POLISH_CI             = 99;
	exports.UTF16_UNICODE_CI             = 101;
	exports.UTF16_ICELANDIC_CI           = 102;
	exports.UTF16_LATVIAN_CI             = 103;
	exports.UTF16_ROMANIAN_CI            = 104;
	exports.UTF16_SLOVENIAN_CI           = 105;
	exports.UTF16_POLISH_CI              = 106;
	exports.UTF16_ESTONIAN_CI            = 107;
	exports.UTF16_SPANISH_CI             = 108;
	exports.UTF16_SWEDISH_CI             = 109;
	exports.UTF16_TURKISH_CI             = 110;
	exports.UTF16_CZECH_CI               = 111;
	exports.UTF16_DANISH_CI              = 112;
	exports.UTF16_LITHUANIAN_CI          = 113;
	exports.UTF16_SLOVAK_CI              = 114;
	exports.UTF16_SPANISH2_CI            = 115;
	exports.UTF16_ROMAN_CI               = 116;
	exports.UTF16_PERSIAN_CI             = 117;
	exports.UTF16_ESPERANTO_CI           = 118;
	exports.UTF16_HUNGARIAN_CI           = 119;
	exports.UTF16_SINHALA_CI             = 120;
	exports.UTF16_GERMAN2_CI             = 121;
	exports.UTF16_CROATIAN_MYSQL561_CI   = 122;
	exports.UTF16_UNICODE_520_CI         = 123;
	exports.UTF16_VIETNAMESE_CI          = 124;
	exports.UCS2_UNICODE_CI              = 128;
	exports.UCS2_ICELANDIC_CI            = 129;
	exports.UCS2_LATVIAN_CI              = 130;
	exports.UCS2_ROMANIAN_CI             = 131;
	exports.UCS2_SLOVENIAN_CI            = 132;
	exports.UCS2_POLISH_CI               = 133;
	exports.UCS2_ESTONIAN_CI             = 134;
	exports.UCS2_SPANISH_CI              = 135;
	exports.UCS2_SWEDISH_CI              = 136;
	exports.UCS2_TURKISH_CI              = 137;
	exports.UCS2_CZECH_CI                = 138;
	exports.UCS2_DANISH_CI               = 139;
	exports.UCS2_LITHUANIAN_CI           = 140;
	exports.UCS2_SLOVAK_CI               = 141;
	exports.UCS2_SPANISH2_CI             = 142;
	exports.UCS2_ROMAN_CI                = 143;
	exports.UCS2_PERSIAN_CI              = 144;
	exports.UCS2_ESPERANTO_CI            = 145;
	exports.UCS2_HUNGARIAN_CI            = 146;
	exports.UCS2_SINHALA_CI              = 147;
	exports.UCS2_GERMAN2_CI              = 148;
	exports.UCS2_CROATIAN_MYSQL561_CI    = 149;
	exports.UCS2_UNICODE_520_CI          = 150;
	exports.UCS2_VIETNAMESE_CI           = 151;
	exports.UCS2_GENERAL_MYSQL500_CI     = 159;
	exports.UTF32_UNICODE_CI             = 160;
	exports.UTF32_ICELANDIC_CI           = 161;
	exports.UTF32_LATVIAN_CI             = 162;
	exports.UTF32_ROMANIAN_CI            = 163;
	exports.UTF32_SLOVENIAN_CI           = 164;
	exports.UTF32_POLISH_CI              = 165;
	exports.UTF32_ESTONIAN_CI            = 166;
	exports.UTF32_SPANISH_CI             = 167;
	exports.UTF32_SWEDISH_CI             = 168;
	exports.UTF32_TURKISH_CI             = 169;
	exports.UTF32_CZECH_CI               = 170;
	exports.UTF32_DANISH_CI              = 171;
	exports.UTF32_LITHUANIAN_CI          = 172;
	exports.UTF32_SLOVAK_CI              = 173;
	exports.UTF32_SPANISH2_CI            = 174;
	exports.UTF32_ROMAN_CI               = 175;
	exports.UTF32_PERSIAN_CI             = 176;
	exports.UTF32_ESPERANTO_CI           = 177;
	exports.UTF32_HUNGARIAN_CI           = 178;
	exports.UTF32_SINHALA_CI             = 179;
	exports.UTF32_GERMAN2_CI             = 180;
	exports.UTF32_CROATIAN_MYSQL561_CI   = 181;
	exports.UTF32_UNICODE_520_CI         = 182;
	exports.UTF32_VIETNAMESE_CI          = 183;
	exports.UTF8_UNICODE_CI              = 192;
	exports.UTF8_ICELANDIC_CI            = 193;
	exports.UTF8_LATVIAN_CI              = 194;
	exports.UTF8_ROMANIAN_CI             = 195;
	exports.UTF8_SLOVENIAN_CI            = 196;
	exports.UTF8_POLISH_CI               = 197;
	exports.UTF8_ESTONIAN_CI             = 198;
	exports.UTF8_SPANISH_CI              = 199;
	exports.UTF8_SWEDISH_CI              = 200;
	exports.UTF8_TURKISH_CI              = 201;
	exports.UTF8_CZECH_CI                = 202;
	exports.UTF8_DANISH_CI               = 203;
	exports.UTF8_LITHUANIAN_CI           = 204;
	exports.UTF8_SLOVAK_CI               = 205;
	exports.UTF8_SPANISH2_CI             = 206;
	exports.UTF8_ROMAN_CI                = 207;
	exports.UTF8_PERSIAN_CI              = 208;
	exports.UTF8_ESPERANTO_CI            = 209;
	exports.UTF8_HUNGARIAN_CI            = 210;
	exports.UTF8_SINHALA_CI              = 211;
	exports.UTF8_GERMAN2_CI              = 212;
	exports.UTF8_CROATIAN_MYSQL561_CI    = 213;
	exports.UTF8_UNICODE_520_CI          = 214;
	exports.UTF8_VIETNAMESE_CI           = 215;
	exports.UTF8_GENERAL_MYSQL500_CI     = 223;
	exports.UTF8MB4_UNICODE_CI           = 224;
	exports.UTF8MB4_ICELANDIC_CI         = 225;
	exports.UTF8MB4_LATVIAN_CI           = 226;
	exports.UTF8MB4_ROMANIAN_CI          = 227;
	exports.UTF8MB4_SLOVENIAN_CI         = 228;
	exports.UTF8MB4_POLISH_CI            = 229;
	exports.UTF8MB4_ESTONIAN_CI          = 230;
	exports.UTF8MB4_SPANISH_CI           = 231;
	exports.UTF8MB4_SWEDISH_CI           = 232;
	exports.UTF8MB4_TURKISH_CI           = 233;
	exports.UTF8MB4_CZECH_CI             = 234;
	exports.UTF8MB4_DANISH_CI            = 235;
	exports.UTF8MB4_LITHUANIAN_CI        = 236;
	exports.UTF8MB4_SLOVAK_CI            = 237;
	exports.UTF8MB4_SPANISH2_CI          = 238;
	exports.UTF8MB4_ROMAN_CI             = 239;
	exports.UTF8MB4_PERSIAN_CI           = 240;
	exports.UTF8MB4_ESPERANTO_CI         = 241;
	exports.UTF8MB4_HUNGARIAN_CI         = 242;
	exports.UTF8MB4_SINHALA_CI           = 243;
	exports.UTF8MB4_GERMAN2_CI           = 244;
	exports.UTF8MB4_CROATIAN_MYSQL561_CI = 245;
	exports.UTF8MB4_UNICODE_520_CI       = 246;
	exports.UTF8MB4_VIETNAMESE_CI        = 247;
	exports.UTF8_GENERAL50_CI            = 253;
	
	// short aliases
	exports.ARMSCII8 = exports.ARMSCII8_GENERAL_CI;
	exports.ASCII    = exports.ASCII_GENERAL_CI;
	exports.BIG5     = exports.BIG5_CHINESE_CI;
	exports.BINARY   = exports.BINARY;
	exports.CP1250   = exports.CP1250_GENERAL_CI;
	exports.CP1251   = exports.CP1251_GENERAL_CI;
	exports.CP1256   = exports.CP1256_GENERAL_CI;
	exports.CP1257   = exports.CP1257_GENERAL_CI;
	exports.CP866    = exports.CP866_GENERAL_CI;
	exports.CP850    = exports.CP850_GENERAL_CI;
	exports.CP852    = exports.CP852_GENERAL_CI;
	exports.CP932    = exports.CP932_JAPANESE_CI;
	exports.DEC8     = exports.DEC8_SWEDISH_CI;
	exports.EUCJPMS  = exports.EUCJPMS_JAPANESE_CI;
	exports.EUCKR    = exports.EUCKR_KOREAN_CI;
	exports.GB2312   = exports.GB2312_CHINESE_CI;
	exports.GBK      = exports.GBK_CHINESE_CI;
	exports.GEOSTD8  = exports.GEOSTD8_GENERAL_CI;
	exports.GREEK    = exports.GREEK_GENERAL_CI;
	exports.HEBREW   = exports.HEBREW_GENERAL_CI;
	exports.HP8      = exports.HP8_ENGLISH_CI;
	exports.KEYBCS2  = exports.KEYBCS2_GENERAL_CI;
	exports.KOI8R    = exports.KOI8R_GENERAL_CI;
	exports.KOI8U    = exports.KOI8U_GENERAL_CI;
	exports.LATIN1   = exports.LATIN1_SWEDISH_CI;
	exports.LATIN2   = exports.LATIN2_GENERAL_CI;
	exports.LATIN5   = exports.LATIN5_TURKISH_CI;
	exports.LATIN7   = exports.LATIN7_GENERAL_CI;
	exports.MACCE    = exports.MACCE_GENERAL_CI;
	exports.MACROMAN = exports.MACROMAN_GENERAL_CI;
	exports.SJIS     = exports.SJIS_JAPANESE_CI;
	exports.SWE7     = exports.SWE7_SWEDISH_CI;
	exports.TIS620   = exports.TIS620_THAI_CI;
	exports.UCS2     = exports.UCS2_GENERAL_CI;
	exports.UJIS     = exports.UJIS_JAPANESE_CI;
	exports.UTF16    = exports.UTF16_GENERAL_CI;
	exports.UTF16LE  = exports.UTF16LE_GENERAL_CI;
	exports.UTF8     = exports.UTF8_GENERAL_CI;
	exports.UTF8MB4  = exports.UTF8MB4_GENERAL_CI;
	exports.UTF32    = exports.UTF32_GENERAL_CI;


/***/ },
/* 25 */
/***/ function(module, exports) {

	// Certificates for Amazon RDS
	exports['Amazon RDS'] = {
	  ca: [
	    /**
	     * Amazon RDS global certificate 2010 to 2015
	     *
	     *   CN = aws.amazon.com/rds/
	     *   OU = RDS
	     *   O = Amazon.com
	     *   L = Seattle
	     *   ST = Washington
	     *   C = US
	     *   P = 2010-04-05T22:44:31Z/2015-04-04T22:41:31Z
	     *   F = 7F:09:8D:A5:7D:BB:A6:EF:7C:70:D8:CA:4E:49:11:55:7E:89:A7:D3
	     */
	    '-----BEGIN CERTIFICATE-----\n'
	    + 'MIIDQzCCAqygAwIBAgIJAOd1tlfiGoEoMA0GCSqGSIb3DQEBBQUAMHUxCzAJBgNV\n'
	    + 'BAYTAlVTMRMwEQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdTZWF0dGxlMRMw\n'
	    + 'EQYDVQQKEwpBbWF6b24uY29tMQwwCgYDVQQLEwNSRFMxHDAaBgNVBAMTE2F3cy5h\n'
	    + 'bWF6b24uY29tL3Jkcy8wHhcNMTAwNDA1MjI0NDMxWhcNMTUwNDA0MjI0NDMxWjB1\n'
	    + 'MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHU2Vh\n'
	    + 'dHRsZTETMBEGA1UEChMKQW1hem9uLmNvbTEMMAoGA1UECxMDUkRTMRwwGgYDVQQD\n'
	    + 'ExNhd3MuYW1hem9uLmNvbS9yZHMvMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKB\n'
	    + 'gQDKhXGU7tizxUR5WaFoMTFcxNxa05PEjZaIOEN5ctkWrqYSRov0/nOMoZjqk8bC\n'
	    + 'med9vPFoQGD0OTakPs0jVe3wwmR735hyVwmKIPPsGlaBYj1O6llIpZeQVyupNx56\n'
	    + 'UzqtiLaDzh1KcmfqP3qP2dInzBfJQKjiRudo1FWnpPt33QIDAQABo4HaMIHXMB0G\n'
	    + 'A1UdDgQWBBT/H3x+cqSkR/ePSIinPtc4yWKe3DCBpwYDVR0jBIGfMIGcgBT/H3x+\n'
	    + 'cqSkR/ePSIinPtc4yWKe3KF5pHcwdTELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldh\n'
	    + 'c2hpbmd0b24xEDAOBgNVBAcTB1NlYXR0bGUxEzARBgNVBAoTCkFtYXpvbi5jb20x\n'
	    + 'DDAKBgNVBAsTA1JEUzEcMBoGA1UEAxMTYXdzLmFtYXpvbi5jb20vcmRzL4IJAOd1\n'
	    + 'tlfiGoEoMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEFBQADgYEAvguZy/BDT66x\n'
	    + 'GfgnJlyQwnFSeVLQm9u/FIvz4huGjbq9dqnD6h/Gm56QPFdyMEyDiZWaqY6V08lY\n'
	    + 'LTBNb4kcIc9/6pc0/ojKciP5QJRm6OiZ4vgG05nF4fYjhU7WClUx7cxq1fKjNc2J\n'
	    + 'UCmmYqgiVkAGWRETVo+byOSDZ4swb10=\n'
	    + '-----END CERTIFICATE-----\n',
	
	    /**
	     * Amazon RDS global root CA 2015 to 2020
	     *
	     *   CN = Amazon RDS Root CA
	     *   OU = Amazon RDS
	     *   O = Amazon Web Services, Inc.
	     *   L = Seattle
	     *   ST = Washington
	     *   C = US
	     *   P = 2015-02-05T09:11:31Z/2020-03-05T09:11:31Z
	     *   F = E8:11:88:56:E7:A7:CE:3E:5E:DC:9A:31:25:1B:93:AC:DC:43:CE:B0
	     */
	    '-----BEGIN CERTIFICATE-----\n'
	    + 'MIID9DCCAtygAwIBAgIBQjANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
	    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
	    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
	    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUwOTExMzFaFw0y\n'
	    + 'MDAzMDUwOTExMzFaMIGKMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
	    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
	    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEbMBkGA1UEAwwSQW1hem9uIFJE\n'
	    + 'UyBSb290IENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuD8nrZ8V\n'
	    + 'u+VA8yVlUipCZIKPTDcOILYpUe8Tct0YeQQr0uyl018StdBsa3CjBgvwpDRq1HgF\n'
	    + 'Ji2N3+39+shCNspQeE6aYU+BHXhKhIIStt3r7gl/4NqYiDDMWKHxHq0nsGDFfArf\n'
	    + 'AOcjZdJagOMqb3fF46flc8k2E7THTm9Sz4L7RY1WdABMuurpICLFE3oHcGdapOb9\n'
	    + 'T53pQR+xpHW9atkcf3pf7gbO0rlKVSIoUenBlZipUlp1VZl/OD/E+TtRhDDNdI2J\n'
	    + 'P/DSMM3aEsq6ZQkfbz/Ilml+Lx3tJYXUDmp+ZjzMPLk/+3beT8EhrwtcG3VPpvwp\n'
	    + 'BIOqsqVVTvw/CwIDAQABo2MwYTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUw\n'
	    + 'AwEB/zAdBgNVHQ4EFgQUTgLurD72FchM7Sz1BcGPnIQISYMwHwYDVR0jBBgwFoAU\n'
	    + 'TgLurD72FchM7Sz1BcGPnIQISYMwDQYJKoZIhvcNAQEFBQADggEBAHZcgIio8pAm\n'
	    + 'MjHD5cl6wKjXxScXKtXygWH2BoDMYBJF9yfyKO2jEFxYKbHePpnXB1R04zJSWAw5\n'
	    + '2EUuDI1pSBh9BA82/5PkuNlNeSTB3dXDD2PEPdzVWbSKvUB8ZdooV+2vngL0Zm4r\n'
	    + '47QPyd18yPHrRIbtBtHR/6CwKevLZ394zgExqhnekYKIqqEX41xsUV0Gm6x4vpjf\n'
	    + '2u6O/+YE2U+qyyxHE5Wd5oqde0oo9UUpFETJPVb6Q2cEeQib8PBAyi0i6KnF+kIV\n'
	    + 'A9dY7IHSubtCK/i8wxMVqfd5GtbA8mmpeJFwnDvm9rBEsHybl08qlax9syEwsUYr\n'
	    + '/40NawZfTUU=\n'
	    + '-----END CERTIFICATE-----\n',
	
	    /**
	     * Amazon RDS ap-northeast-1 certificate CA 2015 to 2020
	     *
	     *   CN = Amazon RDS ap-northeast-1 CA
	     *   OU = Amazon RDS
	     *   O = Amazon Web Services, Inc.
	     *   L = Seattle
	     *   ST = Washington
	     *   C = US
	     *   P = 2015-02-05T22:03:06Z/2020-03-05T22:03:06Z
	     *   F = 4B:2D:8A:E0:C1:A3:A9:AF:A7:BB:65:0C:5A:16:8A:39:3C:03:F2:C5
	     */
	    '-----BEGIN CERTIFICATE-----\n'
	    + 'MIIEATCCAumgAwIBAgIBRDANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
	    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
	    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
	    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzMDZaFw0y\n'
	    + 'MDAzMDUyMjAzMDZaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
	    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
	    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1hem9uIFJE\n'
	    + 'UyBhcC1ub3J0aGVhc3QtMSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n'
	    + 'ggEBAMmM2B4PfTXCZjbZMWiDPyxvk/eeNwIRJAhfzesiGUiLozX6CRy3rwC1ZOPV\n'
	    + 'AcQf0LB+O8wY88C/cV+d4Q2nBDmnk+Vx7o2MyMh343r5rR3Na+4izd89tkQVt0WW\n'
	    + 'vO21KRH5i8EuBjinboOwAwu6IJ+HyiQiM0VjgjrmEr/YzFPL8MgHD/YUHehqjACn\n'
	    + 'C0+B7/gu7W4qJzBL2DOf7ub2qszGtwPE+qQzkCRDwE1A4AJmVE++/FLH2Zx78Egg\n'
	    + 'fV1sUxPtYgjGH76VyyO6GNKM6rAUMD/q5mnPASQVIXgKbupr618bnH+SWHFjBqZq\n'
	    + 'HvDGPMtiiWII41EmGUypyt5AbysCAwEAAaNmMGQwDgYDVR0PAQH/BAQDAgEGMBIG\n'
	    + 'A1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFIiKM0Q6n1K4EmLxs3ZXxINbwEwR\n'
	    + 'MB8GA1UdIwQYMBaAFE4C7qw+9hXITO0s9QXBj5yECEmDMA0GCSqGSIb3DQEBBQUA\n'
	    + 'A4IBAQBezGbE9Rw/k2e25iGjj5n8r+M3dlye8ORfCE/dijHtxqAKasXHgKX8I9Tw\n'
	    + 'JkBiGWiuzqn7gO5MJ0nMMro1+gq29qjZnYX1pDHPgsRjUX8R+juRhgJ3JSHijRbf\n'
	    + '4qNJrnwga7pj94MhcLq9u0f6dxH6dXbyMv21T4TZMTmcFduf1KgaiVx1PEyJjC6r\n'
	    + 'M+Ru+A0eM+jJ7uCjUoZKcpX8xkj4nmSnz9NMPog3wdOSB9cAW7XIc5mHa656wr7I\n'
	    + 'WJxVcYNHTXIjCcng2zMKd1aCcl2KSFfy56sRfT7J5Wp69QSr+jq8KM55gw8uqAwi\n'
	    + 'VPrXn2899T1rcTtFYFP16WXjGuc0\n'
	    + '-----END CERTIFICATE-----\n',
	
	    /**
	     * Amazon RDS ap-southeast-1 certificate CA 2015 to 2020
	     *
	     *   CN = Amazon RDS ap-southeast-1 CA
	     *   OU = Amazon RDS
	     *   O = Amazon Web Services, Inc.
	     *   L = Seattle
	     *   ST = Washington
	     *   C = US
	     *   P = 2015-02-05T22:03:19Z/2020-03-05T22:03:19Z
	     *   F = 0E:EC:5D:BD:F9:80:EE:A9:A0:8D:81:AC:37:D9:8D:34:1C:CD:27:D1
	     */
	    '-----BEGIN CERTIFICATE-----\n'
	    + 'MIIEATCCAumgAwIBAgIBRTANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
	    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
	    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
	    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzMTlaFw0y\n'
	    + 'MDAzMDUyMjAzMTlaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
	    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
	    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1hem9uIFJE\n'
	    + 'UyBhcC1zb3V0aGVhc3QtMSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n'
	    + 'ggEBANaXElmSEYt/UtxHFsARFhSUahTf1KNJzR0Dmay6hqOXQuRVbKRwPd19u5vx\n'
	    + 'DdF1sLT7D69IK3VDnUiQScaCv2Dpu9foZt+rLx+cpx1qiQd1UHrvqq8xPzQOqCdC\n'
	    + 'RFStq6yVYZ69yfpfoI67AjclMOjl2Vph3ftVnqP0IgVKZdzeC7fd+umGgR9xY0Qr\n'
	    + 'Ubhd/lWdsbNvzK3f1TPWcfIKQnpvSt85PIEDJir6/nuJUKMtmJRwTymJf0i+JZ4x\n'
	    + '7dJa341p2kHKcHMgOPW7nJQklGBA70ytjUV6/qebS3yIugr/28mwReflg3TJzVDl\n'
	    + 'EOvi6pqbqNbkMuEwGDCmEQIVqgkCAwEAAaNmMGQwDgYDVR0PAQH/BAQDAgEGMBIG\n'
	    + 'A1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFAu93/4k5xbWOsgdCdn+/KdiRuit\n'
	    + 'MB8GA1UdIwQYMBaAFE4C7qw+9hXITO0s9QXBj5yECEmDMA0GCSqGSIb3DQEBBQUA\n'
	    + 'A4IBAQBlcjSyscpPjf5+MgzMuAsCxByqUt+WFspwcMCpwdaBeHOPSQrXNqX2Sk6P\n'
	    + 'kth6oCivA64trWo8tFMvPYlUA1FYVD5WpN0kCK+P5pD4KHlaDsXhuhClJzp/OP8t\n'
	    + 'pOyUr5109RHLxqoKB5J5m1XA7rgcFjnMxwBSWFe3/4uMk/+4T53YfCVXuc6QV3i7\n'
	    + 'I/2LAJwFf//pTtt6fZenYfCsahnr2nvrNRNyAxcfvGZ/4Opn/mJtR6R/AjvQZHiR\n'
	    + 'bkRNKF2GW0ueK5W4FkZVZVhhX9xh1Aj2Ollb+lbOqADaVj+AT3PoJPZ3MPQHKCXm\n'
	    + 'xwG0LOLlRr/TfD6li1AfOVTAJXv9\n'
	    + '-----END CERTIFICATE-----\n',
	
	    /**
	     * Amazon RDS ap-southeast-2 certificate CA 2015 to 2020
	     *
	     *   CN = Amazon RDS ap-southeast-2 CA
	     *   OU = Amazon RDS
	     *   O = Amazon Web Services, Inc.
	     *   L = Seattle
	     *   ST = Washington
	     *   C = US
	     *   P = 2015-02-05T22:03:24Z/2020-03-05T22:03:24Z
	     *   F = 20:D9:A8:82:23:AB:B9:E5:C5:24:10:D3:4D:0F:3D:B1:31:DF:E5:14
	     */
	    '-----BEGIN CERTIFICATE-----\n'
	    + 'MIIEATCCAumgAwIBAgIBRjANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
	    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
	    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
	    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzMjRaFw0y\n'
	    + 'MDAzMDUyMjAzMjRaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
	    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
	    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1hem9uIFJE\n'
	    + 'UyBhcC1zb3V0aGVhc3QtMiBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n'
	    + 'ggEBAJqBAJutz69hFOh3BtLHZTbwE8eejGGKayn9hu98YMDPzWzGXWCmW+ZYWELA\n'
	    + 'cY3cNWNF8K4FqKXFr2ssorBYim1UtYFX8yhydT2hMD5zgQ2sCGUpuidijuPA6zaq\n'
	    + 'Z3tdhVR94f0q8mpwpv2zqR9PcqaGDx2VR1x773FupRPRo7mEW1vC3IptHCQlP/zE\n'
	    + '7jQiLl28bDIH2567xg7e7E9WnZToRnhlYdTaDaJsHTzi5mwILi4cihSok7Shv/ME\n'
	    + 'hnukvxeSPUpaVtFaBhfBqq055ePq9I+Ns4KGreTKMhU0O9fkkaBaBmPaFgmeX/XO\n'
	    + 'n2AX7gMouo3mtv34iDTZ0h6YCGkCAwEAAaNmMGQwDgYDVR0PAQH/BAQDAgEGMBIG\n'
	    + 'A1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFIlQnY0KHYWn1jYumSdJYfwj/Nfw\n'
	    + 'MB8GA1UdIwQYMBaAFE4C7qw+9hXITO0s9QXBj5yECEmDMA0GCSqGSIb3DQEBBQUA\n'
	    + 'A4IBAQA0wVU6/l41cTzHc4azc4CDYY2Wd90DFWiH9C/mw0SgToYfCJ/5Cfi0NT/Y\n'
	    + 'PRnk3GchychCJgoPA/k9d0//IhYEAIiIDjyFVgjbTkKV3sh4RbdldKVOUB9kumz/\n'
	    + 'ZpShplsGt3z4QQiVnKfrAgqxWDjR0I0pQKkxXa6Sjkicos9LQxVtJ0XA4ieG1E7z\n'
	    + 'zJr+6t80wmzxvkInSaWP3xNJK9azVRTrgQZQlvkbpDbExl4mNTG66VD3bAp6t3Wa\n'
	    + 'B49//uDdfZmPkqqbX+hsxp160OH0rxJppwO3Bh869PkDnaPEd/Pxw7PawC+li0gi\n'
	    + 'NRV8iCEx85aFxcyOhqn0WZOasxee\n'
	    + '-----END CERTIFICATE-----\n',
	
	    /**
	     * Amazon RDS eu-central-1 certificate CA 2015 to 2020
	     *
	     *   CN = Amazon RDS eu-central-1 CA
	     *   OU = Amazon RDS
	     *   O = Amazon Web Services, Inc.
	     *   L = Seattle
	     *   ST = Washington
	     *   C = US
	     *   P = 2015-02-05T22:03:31Z/2020-03-05T22:03:31Z
	     *   F = 94:B4:DF:B9:6D:7E:F7:C3:B7:BF:51:E9:A6:B7:44:A0:D0:82:11:84
	     */
	    '-----BEGIN CERTIFICATE-----\n'
	    + 'MIID/zCCAuegAwIBAgIBRzANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
	    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
	    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
	    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzMzFaFw0y\n'
	    + 'MDAzMDUyMjAzMzFaMIGSMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
	    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
	    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEjMCEGA1UEAwwaQW1hem9uIFJE\n'
	    + 'UyBldS1jZW50cmFsLTEgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB\n'
	    + 'AQDFtP2dhSLuaPOI4ZrrPWsK4OY9ocQBp3yApH1KJYmI9wpQKZG/KCH2E6Oo7JAw\n'
	    + 'QORU519r033T+FO2Z7pFPlmz1yrxGXyHpJs8ySx3Yo5S8ncDCdZJCLmtPiq/hahg\n'
	    + '5/0ffexMFUCQaYicFZsrJ/cStdxUV+tSw2JQLD7UxS9J97LQWUPyyG+ZrjYVTVq+\n'
	    + 'zudnFmNSe4QoecXMhAFTGJFQXxP7nhSL9Ao5FGgdXy7/JWeWdQIAj8ku6cBDKPa6\n'
	    + 'Y6kP+ak+In+Lye8z9qsCD/afUozfWjPR2aA4JoIZVF8dNRShIMo8l0XfgfM2q0+n\n'
	    + 'ApZWZ+BjhIO5XuoUgHS3D2YFAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNV\n'
	    + 'HRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBRm4GsWIA/M6q+tK8WGHWDGh2gcyTAf\n'
	    + 'BgNVHSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQUFAAOC\n'
	    + 'AQEAHpMmeVQNqcxgfQdbDIi5UIy+E7zZykmtAygN1XQrvga9nXTis4kOTN6g5/+g\n'
	    + 'HCx7jIXeNJzAbvg8XFqBN84Quqgpl/tQkbpco9Jh1HDs558D5NnZQxNqH5qXQ3Mm\n'
	    + 'uPgCw0pYcPOa7bhs07i+MdVwPBsX27CFDtsgAIru8HvKxY1oTZrWnyIRo93tt/pk\n'
	    + 'WuItVMVHjaQZVfTCow0aDUbte6Vlw82KjUFq+n2NMSCJDiDKsDDHT6BJc4AJHIq3\n'
	    + '/4Z52MSC9KMr0yAaaoWfW/yMEj9LliQauAgwVjArF4q78rxpfKTG9Rfd8U1BZANP\n'
	    + '7FrFMN0ThjfA1IvmOYcgskY5bQ==\n'
	    + '-----END CERTIFICATE-----\n',
	
	    /**
	     * Amazon RDS eu-west-1 certificate CA 2015 to 2020
	     *
	     *   CN = Amazon RDS eu-west-1 CA
	     *   OU = Amazon RDS
	     *   O = Amazon Web Services, Inc.
	     *   L = Seattle
	     *   ST = Washington
	     *   C = US
	     *   P = 2015-02-05T22:03:35Z/2020-03-05T22:03:35Z
	     *   F = 1A:95:F0:43:82:D2:5D:A6:AD:F5:13:27:0B:40:8A:72:D9:92:F3:E0
	     */
	    '-----BEGIN CERTIFICATE-----\n'
	    + 'MIID/DCCAuSgAwIBAgIBSDANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
	    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
	    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
	    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzMzVaFw0y\n'
	    + 'MDAzMDUyMjAzMzVaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
	    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
	    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\n'
	    + 'UyBldS13ZXN0LTEgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCx\n'
	    + 'PdbqQ0HKRj79Pmocxvjc+P6i4Ux24kgFIl+ckiir1vzkmesc3a58gjrMlCksEObt\n'
	    + 'Yihs5IhzEq1ePT0gbfS9GYFp34Uj/MtPwlrfCBWG4d2TcrsKRHr1/EXUYhWqmdrb\n'
	    + 'RhX8XqoRhVkbF/auzFSBhTzcGGvZpQ2KIaxRcQfcXlMVhj/pxxAjh8U4F350Fb0h\n'
	    + 'nX1jw4/KvEreBL0Xb2lnlGTkwVxaKGSgXEnOgIyOFdOQc61vdome0+eeZsP4jqeR\n'
	    + 'TGYJA9izJsRbe2YJxHuazD+548hsPlM3vFzKKEVURCha466rAaYAHy3rKur3HYQx\n'
	    + 'Yt+SoKcEz9PXuSGj96ejAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\n'
	    + 'Af8ECDAGAQH/AgEAMB0GA1UdDgQWBBTebg//h2oeXbZjQ4uuoiuLYzuiPDAfBgNV\n'
	    + 'HSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQUFAAOCAQEA\n'
	    + 'TikPaGeZasTPw+4RBemlsyPAjtFFQLo7ddaFdORLgdEysVf8aBqndvbA6MT/v4lj\n'
	    + 'GtEtUdF59ZcbWOrVm+fBZ2h/jYJ59dYF/xzb09nyRbdMSzB9+mkSsnOMqluq5y8o\n'
	    + 'DY/PfP2vGhEg/2ZncRC7nlQU1Dm8F4lFWEiQ2fi7O1cW852Vmbq61RIfcYsH/9Ma\n'
	    + 'kpgk10VZ75b8m3UhmpZ/2uRY+JEHImH5WpcTJ7wNiPNJsciZMznGtrgOnPzYco8L\n'
	    + 'cDleOASIZifNMQi9PKOJKvi0ITz0B/imr8KBsW0YjZVJ54HMa7W1lwugSM7aMAs+\n'
	    + 'E3Sd5lS+SHwWaOCHwhOEVA==\n'
	    + '-----END CERTIFICATE-----\n',
	
	    /**
	     * Amazon RDS sa-east-1 certificate CA 2015 to 2020
	     *
	     *   CN = Amazon RDS sa-east-1 CA
	     *   OU = Amazon RDS
	     *   O = Amazon Web Services, Inc.
	     *   L = Seattle
	     *   ST = Washington
	     *   C = US
	     *   P = 2015-02-05T22:03:40Z/2020-03-05T22:03:40Z
	     *   F = 32:10:3D:FA:6D:42:F5:35:98:40:15:F4:4C:74:74:27:CB:CE:D4:B5
	     */
	    '-----BEGIN CERTIFICATE-----\n'
	    + 'MIID/DCCAuSgAwIBAgIBSTANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
	    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
	    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
	    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzNDBaFw0y\n'
	    + 'MDAzMDUyMjAzNDBaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
	    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
	    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\n'
	    + 'UyBzYS1lYXN0LTEgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCU\n'
	    + 'X4OBnQ5xA6TLJAiFEI6l7bUWjoVJBa/VbMdCCSs2i2dOKmqUaXu2ix2zcPILj3lZ\n'
	    + 'GMk3d/2zvTK/cKhcFrewHUBamTeVHdEmynhMQamqNmkM4ptYzFcvEUw1TGxHT4pV\n'
	    + 'Q6gSN7+/AJewQvyHexHo8D0+LDN0/Wa9mRm4ixCYH2CyYYJNKaZt9+EZfNu+PPS4\n'
	    + '8iB0TWH0DgQkbWMBfCRgolLLitAZklZ4dvdlEBS7evN1/7ttBxUK6SvkeeSx3zBl\n'
	    + 'ww3BlXqc3bvTQL0A+RRysaVyFbvtp9domFaDKZCpMmDFAN/ntx215xmQdrSt+K3F\n'
	    + 'cXdGQYHx5q410CAclGnbAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\n'
	    + 'Af8ECDAGAQH/AgEAMB0GA1UdDgQWBBT6iVWnm/uakS+tEX2mzIfw+8JL0zAfBgNV\n'
	    + 'HSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQUFAAOCAQEA\n'
	    + 'FmDD+QuDklXn2EgShwQxV13+txPRuVdOSrutHhoCgMwFWCMtPPtBAKs6KPY7Guvw\n'
	    + 'DpJoZSehDiOfsgMirjOWjvfkeWSNvKfjWTVneX7pZD9W5WPnsDBvTbCGezm+v87z\n'
	    + 'b+ZM2ZMo98m/wkMcIEAgdSKilR2fuw8rLkAjhYFfs0A7tDgZ9noKwgHvoE4dsrI0\n'
	    + 'KZYco6DlP/brASfHTPa2puBLN9McK3v+h0JaSqqm5Ro2Bh56tZkQh8AWy/miuDuK\n'
	    + '3+hNEVdxosxlkM1TPa1DGj0EzzK0yoeerXuH2HX7LlCrrxf6/wdKnjR12PMrLQ4A\n'
	    + 'pCqkcWw894z6bV9MAvKe6A==\n'
	    + '-----END CERTIFICATE-----\n',
	
	    /**
	     * Amazon RDS us-east-1 certificate CA 2015 to 2020
	     *
	     *   CN = Amazon RDS us-east-1 CA
	     *   OU = Amazon RDS
	     *   O = Amazon Web Services, Inc.
	     *   L = Seattle
	     *   ST = Washington
	     *   C = US
	     *   P = 2015-02-05T21:54:04Z/2020-03-05T21:54:04Z
	     *   F = 34:47:8A:90:8A:83:AE:45:DC:B6:16:76:D2:35:EC:E9:75:C6:2C:63
	     */
	    '-----BEGIN CERTIFICATE-----\n'
	    + 'MIID/DCCAuSgAwIBAgIBQzANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
	    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
	    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
	    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMTU0MDRaFw0y\n'
	    + 'MDAzMDUyMTU0MDRaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
	    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
	    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\n'
	    + 'UyB1cy1lYXN0LTEgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDI\n'
	    + 'UIuwh8NusKHk1SqPXcP7OqxY3S/M2ZyQWD3w7Bfihpyyy/fc1w0/suIpX3kbMhAV\n'
	    + '2ESwged2/2zSx4pVnjp/493r4luhSqQYzru78TuPt9bhJIJ51WXunZW2SWkisSaf\n'
	    + 'USYUzVN9ezR/bjXTumSUQaLIouJt3OHLX49s+3NAbUyOI8EdvgBQWD68H1epsC0n\n'
	    + 'CI5s+pIktyOZ59c4DCDLQcXErQ+tNbDC++oct1ANd/q8p9URonYwGCGOBy7sbCYq\n'
	    + '9eVHh1Iy2M+SNXddVOGw5EuruvHoCIQyOz5Lz4zSuZA9dRbrfztNOpezCNYu6NKM\n'
	    + 'n+hzcvdiyxv77uNm8EaxAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\n'
	    + 'Af8ECDAGAQH/AgEAMB0GA1UdDgQWBBQSQG3TmMe6Sa3KufaPBa72v4QFDzAfBgNV\n'
	    + 'HSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQUFAAOCAQEA\n'
	    + 'L/mOZfB3187xTmjOHMqN2G2oSKHBKiQLM9uv8+97qT+XR+TVsBT6b3yoPpMAGhHA\n'
	    + 'Pc7nxAF5gPpuzatx0OTLPcmYucFmfqT/1qA5WlgCnMNtczyNMH97lKFTNV7Njtek\n'
	    + 'jWEzAEQSyEWrkNpNlC4j6kMYyPzVXQeXUeZTgJ9FNnVZqmvfjip2N22tawMjrCn5\n'
	    + '7KN/zN65EwY2oO9XsaTwwWmBu3NrDdMbzJnbxoWcFWj4RBwanR1XjQOVNhDwmCOl\n'
	    + '/1Et13b8CPyj69PC8BOVU6cfTSx8WUVy0qvYOKHNY9Bqa5BDnIL3IVmUkeTlM1mt\n'
	    + 'enRpyBj+Bk9rh/ICdiRKmA==\n'
	    + '-----END CERTIFICATE-----\n',
	
	    /**
	     * Amazon RDS us-west-1 certificate CA 2015 to 2020
	     *
	     *   CN = Amazon RDS us-west-1 CA
	     *   OU = Amazon RDS
	     *   O = Amazon Web Services, Inc.
	     *   L = Seattle
	     *   ST = Washington
	     *   C = US
	     *   P = 2015-02-05T22:03:45Z/2020-03-05T22:03:45Z
	     *   F = EF:94:2F:E3:58:0E:09:D6:79:C2:16:97:91:FB:37:EA:D7:70:A8:4B
	     */
	    '-----BEGIN CERTIFICATE-----\n'
	    + 'MIID/DCCAuSgAwIBAgIBSjANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
	    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
	    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
	    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzNDVaFw0y\n'
	    + 'MDAzMDUyMjAzNDVaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
	    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
	    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\n'
	    + 'UyB1cy13ZXN0LTEgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDE\n'
	    + 'Dhw+uw/ycaiIhhyu2pXFRimq0DlB8cNtIe8hdqndH8TV/TFrljNgR8QdzOgZtZ9C\n'
	    + 'zzQ2GRpInN/qJF6slEd6wO+6TaDBQkPY+07TXNt52POFUhdVkhJXHpE2BS7Xn6J7\n'
	    + '7RFAOeG1IZmc2DDt+sR1BgXzUqHslQGfFYNS0/MBO4P+ya6W7IhruB1qfa4HiYQS\n'
	    + 'dbe4MvGWnv0UzwAqdR7OF8+8/5c58YXZIXCO9riYF2ql6KNSL5cyDPcYK5VK0+Q9\n'
	    + 'VI6vuJHSMYcF7wLePw8jtBktqAFE/wbdZiIHhZvNyiNWPPNTGUmQbaJ+TzQEHDs5\n'
	    + '8en+/W7JKnPyBOkxxENbAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\n'
	    + 'Af8ECDAGAQH/AgEAMB0GA1UdDgQWBBS0nw/tFR9bCjgqWTPJkyy4oOD8bzAfBgNV\n'
	    + 'HSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQUFAAOCAQEA\n'
	    + 'CXGAY3feAak6lHdqj6+YWjy6yyUnLK37bRxZDsyDVXrPRQaXRzPTzx79jvDwEb/H\n'
	    + 'Q/bdQ7zQRWqJcbivQlwhuPJ4kWPUZgSt3JUUuqkMsDzsvj/bwIjlrEFDOdHGh0mi\n'
	    + 'eVIngFEjUXjMh+5aHPEF9BlQnB8LfVtKj18e15UDTXFa+xJPFxUR7wDzCfo4WI1m\n'
	    + 'sUMG4q1FkGAZgsoyFPZfF8IVvgCuGdR8z30VWKklFxttlK0eGLlPAyIO0CQxPQlo\n'
	    + 'saNJrHf4tLOgZIWk+LpDhNd9Et5EzvJ3aURUsKY4pISPPF5WdvM9OE59bERwUErd\n'
	    + 'nuOuQWQeeadMceZnauRzJQ==\n'
	    + '-----END CERTIFICATE-----\n',
	
	    /**
	     * Amazon RDS us-west-2 certificate CA 2015 to 2020
	     *
	     *   CN = Amazon RDS us-west-2 CA
	     *   OU = Amazon RDS
	     *   O = Amazon Web Services, Inc.
	     *   L = Seattle
	     *   ST = Washington
	     *   C = US
	     *   P = 2015-02-05T22:03:50Z/2020-03-05T22:03:50Z
	     *   F = 94:2C:A8:B0:23:48:17:F0:CD:2F:19:7F:C1:E0:21:7C:65:79:13:3A
	     */
	    '-----BEGIN CERTIFICATE-----\n'
	    + 'MIID/DCCAuSgAwIBAgIBSzANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\n'
	    + 'EzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\n'
	    + 'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n'
	    + 'GzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzNTBaFw0y\n'
	    + 'MDAzMDUyMjAzNTBaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\n'
	    + 'bjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n'
	    + 'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\n'
	    + 'UyB1cy13ZXN0LTIgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDM\n'
	    + 'H58SR48U6jyERC1vYTnub34smf5EQVXyzaTmspWGWGzT31NLNZGSDFaa7yef9kdO\n'
	    + 'mzJsgebR5tXq6LdwlIoWkKYQ7ycUaadtVKVYdI40QcI3cHn0qLFlg2iBXmWp/B+i\n'
	    + 'Z34VuVlCh31Uj5WmhaBoz8t/GRqh1V/aCsf3Wc6jCezH3QfuCjBpzxdOOHN6Ie2v\n'
	    + 'xX09O5qmZTvMoRBAvPkxdaPg/Mi7fxueWTbEVk78kuFbF1jHYw8U1BLILIAhcqlq\n'
	    + 'x4u8nl73t3O3l/soNUcIwUDK0/S+Kfqhwn9yQyPlhb4Wy3pfnZLJdkyHldktnQav\n'
	    + '9TB9u7KH5Lk0aAYslMLxAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\n'
	    + 'Af8ECDAGAQH/AgEAMB0GA1UdDgQWBBT8roM4lRnlFHWMPWRz0zkwFZog1jAfBgNV\n'
	    + 'HSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQUFAAOCAQEA\n'
	    + 'JwrxwgwmPtcdaU7O7WDdYa4hprpOMamI49NDzmE0s10oGrqmLwZygcWU0jT+fJ+Y\n'
	    + 'pJe1w0CVfKaeLYNsOBVW3X4ZPmffYfWBheZiaiEflq/P6t7/Eg81gaKYnZ/x1Dfa\n'
	    + 'sUYkzPvCkXe9wEz5zdUTOCptDt89rBR9CstL9vE7WYUgiVVmBJffWbHQLtfjv6OF\n'
	    + 'NMb0QME981kGRzc2WhgP71YS2hHd1kXtsoYP1yTu4vThSKsoN4bkiHsaC1cRkLoy\n'
	    + '0fFA4wpB3WloMEvCDaUvvH1LZlBXTNlwi9KtcwD4tDxkkBt4tQczKLGpQ/nF/W9n\n'
	    + '8YDWk3IIc1sd0bkZqoau2Q==\n'
	    + '-----END CERTIFICATE-----\n'
	  ]
	}


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var Parser       = __webpack_require__(27);
	var Sequences    = __webpack_require__(30);
	var Packets      = __webpack_require__(35);
	var Timers       = __webpack_require__(79);
	var Stream       = __webpack_require__(69).Stream;
	var Util         = __webpack_require__(33);
	var PacketWriter = __webpack_require__(80);
	
	module.exports = Protocol;
	Util.inherits(Protocol, Stream);
	function Protocol(options) {
	  Stream.call(this);
	
	  options = options || {};
	
	  this.readable = true;
	  this.writable = true;
	
	  this._config                        = options.config || {};
	  this._connection                    = options.connection;
	  this._callback                      = null;
	  this._fatalError                    = null;
	  this._quitSequence                  = null;
	  this._handshakeSequence             = null;
	  this._handshaked                    = false;
	  this._ended                         = false;
	  this._destroyed                     = false;
	  this._queue                         = [];
	  this._handshakeInitializationPacket = null;
	
	  this._parser = new Parser({
	    onError  : this.handleParserError.bind(this),
	    onPacket : this._parsePacket.bind(this),
	    config   : this._config
	  });
	}
	
	Protocol.prototype.write = function(buffer) {
	  this._parser.write(buffer);
	  return true;
	};
	
	Protocol.prototype.handshake = function handshake(options, callback) {
	  if (typeof options === 'function') {
	    callback = options;
	    options = {};
	  }
	
	  options = options || {};
	  options.config = this._config;
	
	  return this._handshakeSequence = this._enqueue(new Sequences.Handshake(options, callback));
	};
	
	Protocol.prototype.query = function query(options, callback) {
	  return this._enqueue(new Sequences.Query(options, callback));
	};
	
	Protocol.prototype.changeUser = function changeUser(options, callback) {
	  return this._enqueue(new Sequences.ChangeUser(options, callback));
	};
	
	Protocol.prototype.ping = function ping(options, callback) {
	  if (typeof options === 'function') {
	    callback = options;
	    options = {};
	  }
	
	  return this._enqueue(new Sequences.Ping(options, callback));
	};
	
	Protocol.prototype.stats = function stats(options, callback) {
	  if (typeof options === 'function') {
	    callback = options;
	    options = {};
	  }
	
	  return this._enqueue(new Sequences.Statistics(options, callback));
	};
	
	Protocol.prototype.quit = function quit(options, callback) {
	  if (typeof options === 'function') {
	    callback = options;
	    options = {};
	  }
	
	  return this._quitSequence = this._enqueue(new Sequences.Quit(options, callback));
	};
	
	Protocol.prototype.end = function() {
	  if(this._ended) {
	    return;
	  }
	  this._ended = true;
	
	  var expected = (this._quitSequence && this._queue[0] === this._quitSequence);
	  if (expected) {
	    this._quitSequence.end();
	    this.emit('end');
	    return;
	  }
	
	  var err = new Error('Connection lost: The server closed the connection.');
	  err.fatal = true;
	  err.code = 'PROTOCOL_CONNECTION_LOST';
	
	  this._delegateError(err);
	};
	
	Protocol.prototype.pause = function() {
	  this._parser.pause();
	  // Since there is a file stream in query, we must transmit pause/resume event to current sequence.
	  var seq = this._queue[0];
	  if (seq && seq.emit) {
	    seq.emit('pause');
	  }
	};
	
	Protocol.prototype.resume = function() {
	  this._parser.resume();
	  // Since there is a file stream in query, we must transmit pause/resume event to current sequence.
	  var seq = this._queue[0];
	  if (seq && seq.emit) {
	    seq.emit('resume');
	  }
	};
	
	Protocol.prototype._enqueue = function(sequence) {
	  if (!this._validateEnqueue(sequence)) {
	    return sequence;
	  }
	
	  if (this._config.trace) {
	    // Long stack trace support
	    sequence._callSite = sequence._callSite || new Error;
	  }
	
	  this._queue.push(sequence);
	  this.emit('enqueue', sequence);
	
	  var self = this;
	  sequence
	    .on('error', function(err) {
	      self._delegateError(err, sequence);
	    })
	    .on('packet', function(packet) {
	      Timers.active(sequence);
	      self._emitPacket(packet);
	    })
	    .on('end', function() {
	      self._dequeue(sequence);
	    })
	    .on('timeout', function() {
	      var err = new Error(sequence.constructor.name + ' inactivity timeout');
	
	      err.code    = 'PROTOCOL_SEQUENCE_TIMEOUT';
	      err.fatal   = true;
	      err.timeout = sequence._timeout;
	
	      self._delegateError(err, sequence);
	    })
	    .on('start-tls', function() {
	      Timers.active(sequence);
	      self._connection._startTLS(function(err) {
	        if (err) {
	          // SSL negotiation error are fatal
	          err.code  = 'HANDSHAKE_SSL_ERROR';
	          err.fatal = true;
	          sequence.end(err);
	          return
	        }
	
	        Timers.active(sequence);
	        sequence._tlsUpgradeCompleteHandler();
	      }) 
	    });
	
	  if (this._queue.length === 1) {
	    this._parser.resetPacketNumber();
	    this._startSequence(sequence);
	  }
	
	  return sequence;
	};
	
	Protocol.prototype._validateEnqueue = function _validateEnqueue(sequence) {
	  var err;
	  var prefix = 'Cannot enqueue ' + sequence.constructor.name;
	  var prefixBefore = prefix + ' before ';
	  var prefixAfter = prefix + ' after ';
	
	  if (this._fatalError) {
	    err      = new Error(prefixAfter + 'fatal error.');
	    err.code = 'PROTOCOL_ENQUEUE_AFTER_FATAL_ERROR';
	  } else if (this._quitSequence) {
	    err      = new Error(prefixAfter + 'invoking quit.');
	    err.code = 'PROTOCOL_ENQUEUE_AFTER_QUIT';
	  } else if (this._destroyed) {
	    err      = new Error(prefixAfter + 'being destroyed.');
	    err.code = 'PROTOCOL_ENQUEUE_AFTER_DESTROY';
	  } else if (this._handshakeSequence && sequence.constructor === Sequences.Handshake) {
	    err      = new Error(prefixAfter + 'already enqueuing a Handshake.');
	    err.code = 'PROTOCOL_ENQUEUE_HANDSHAKE_TWICE';
	  } else if (!this._handshakeSequence && sequence.constructor === Sequences.ChangeUser) {
	    err      = new Error(prefixBefore + 'a Handshake.');
	    err.code = 'PROTOCOL_ENQUEUE_BEFORE_HANDSHAKE';
	  } else {
	    return true;
	  }
	
	  var self  = this;
	  err.fatal = false;
	
	  // add error handler
	  sequence.on('error', function (err) {
	    self._delegateError(err, sequence);
	  });
	
	  process.nextTick(function () {
	    sequence.end(err);
	  });
	
	  return false;
	};
	
	Protocol.prototype._parsePacket = function() {
	  var sequence = this._queue[0];
	
	  if (!sequence) {
	    var err   = new Error('Received packet with no active sequence.');
	    err.code  = 'PROTOCOL_STRAY_PACKET';
	    err.fatal = true;
	
	    this._delegateError(err);
	    return;
	  }
	
	  var Packet     = this._determinePacket(sequence);
	  var packet     = new Packet({protocol41: this._config.protocol41});
	  var packetName = Packet.name;
	
	  // Special case: Faster dispatch, and parsing done inside sequence
	  if (Packet === Packets.RowDataPacket) {
	    sequence.RowDataPacket(packet, this._parser, this._connection);
	
	    if (this._config.debug) {
	      this._debugPacket(true, packet);
	    }
	
	    return;
	  }
	
	  if (this._config.debug) {
	    this._parsePacketDebug(packet);
	  } else {
	    packet.parse(this._parser);
	  }
	
	  if (Packet === Packets.HandshakeInitializationPacket) {
	    this._handshakeInitializationPacket = packet;
	  }
	
	  Timers.active(sequence);
	
	  if (!sequence[packetName]) {
	    var err   = new Error('Received packet in the wrong sequence.');
	    err.code  = 'PROTOCOL_INCORRECT_PACKET_SEQUENCE';
	    err.fatal = true;
	
	    this._delegateError(err);
	    return;
	  }
	
	  sequence[packetName](packet);
	};
	
	Protocol.prototype._parsePacketDebug = function _parsePacketDebug(packet) {
	  try {
	    packet.parse(this._parser);
	  } finally {
	    this._debugPacket(true, packet);
	  }
	};
	
	Protocol.prototype._emitPacket = function(packet) {
	  var packetWriter = new PacketWriter();
	  packet.write(packetWriter);
	  this.emit('data', packetWriter.toBuffer(this._parser));
	
	  if (this._config.debug) {
	    this._debugPacket(false, packet);
	  }
	};
	
	Protocol.prototype._determinePacket = function(sequence) {
	  var firstByte = this._parser.peak();
	
	  if (sequence.determinePacket) {
	    var Packet = sequence.determinePacket(firstByte, this._parser);
	    if (Packet) {
	      return Packet;
	    }
	  }
	
	  switch (firstByte) {
	    case 0x00:
	      if (!this._handshaked) {
	        this._handshaked = true;
	        this.emit('handshake', this._handshakeInitializationPacket);
	      }
	      return Packets.OkPacket;
	    case 0xfe: return Packets.EofPacket;
	    case 0xff: return Packets.ErrorPacket;
	  }
	
	  throw new Error('Could not determine packet, firstByte = ' + firstByte);
	};
	
	Protocol.prototype._dequeue = function(sequence) {
	  Timers.unenroll(sequence);
	
	  // No point in advancing the queue, we are dead
	  if (this._fatalError) {
	    return;
	  }
	
	  this._queue.shift();
	
	  var sequence = this._queue[0];
	  if (!sequence) {
	    this.emit('drain');
	    return;
	  }
	
	  this._parser.resetPacketNumber();
	
	  this._startSequence(sequence);
	};
	
	Protocol.prototype._startSequence = function(sequence) {
	  if (sequence._timeout > 0 && isFinite(sequence._timeout)) {
	    Timers.enroll(sequence, sequence._timeout);
	    Timers.active(sequence);
	  }
	
	  if (sequence.constructor === Sequences.ChangeUser) {
	    sequence.start(this._handshakeInitializationPacket);
	  } else {
	    sequence.start();
	  }
	};
	
	Protocol.prototype.handleNetworkError = function(err) {
	  err.fatal = true;
	
	  var sequence = this._queue[0];
	  if (sequence) {
	    sequence.end(err);
	  } else {
	    this._delegateError(err);
	  }
	};
	
	Protocol.prototype.handleParserError = function handleParserError(err) {
	  var sequence = this._queue[0];
	  if (sequence) {
	    sequence.end(err);
	  } else {
	    this._delegateError(err);
	  }
	};
	
	Protocol.prototype._delegateError = function(err, sequence) {
	  // Stop delegating errors after the first fatal error
	  if (this._fatalError) {
	    return;
	  }
	
	  if (err.fatal) {
	    this._fatalError = err;
	  }
	
	  if (this._shouldErrorBubbleUp(err, sequence)) {
	    // Can't use regular 'error' event here as that always destroys the pipe
	    // between socket and protocol which is not what we want (unless the
	    // exception was fatal).
	    this.emit('unhandledError', err);
	  } else if (err.fatal) {
	    // Send fatal error to all sequences in the queue
	    var queue = this._queue;
	    process.nextTick(function () {
	      queue.forEach(function (sequence) {
	        sequence.end(err);
	      });
	      queue.length = 0;
	    });
	  }
	
	  // Make sure the stream we are piping to is getting closed
	  if (err.fatal) {
	    this.emit('end', err);
	  }
	};
	
	Protocol.prototype._shouldErrorBubbleUp = function(err, sequence) {
	  if (sequence) {
	    if (sequence.hasErrorHandler()) {
	      return false;
	    } else if (!err.fatal) {
	      return true;
	    }
	  }
	
	  return (err.fatal && !this._hasPendingErrorHandlers());
	};
	
	Protocol.prototype._hasPendingErrorHandlers = function() {
	  return this._queue.some(function(sequence) {
	    return sequence.hasErrorHandler();
	  });
	};
	
	Protocol.prototype.destroy = function() {
	  this._destroyed = true;
	  this._parser.pause();
	
	  if (this._connection.state !== "disconnected") {
	    if(!this._ended) {
	      this.end();
	    }
	  }
	};
	
	Protocol.prototype._debugPacket = function(incoming, packet) {
	  var headline = (incoming)
	    ? '<-- '
	    : '--> ';
	
	  headline = headline + packet.constructor.name;
	
	  // check for debug packet restriction
	  if (Array.isArray(this._config.debug) && this._config.debug.indexOf(packet.constructor.name) === -1) {
	    return;
	  }
	
	  console.log(headline);
	  console.log(packet);
	  console.log('');
	};


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var MAX_PACKET_LENGTH = Math.pow(2, 24) - 1;
	var MUL_32BIT         = Math.pow(2, 32);
	var PacketHeader      = __webpack_require__(28);
	var BigNumber         = __webpack_require__(29);
	
	module.exports = Parser;
	function Parser(options) {
	  options = options || {};
	
	  this._supportBigNumbers = options.config && options.config.supportBigNumbers;
	  this._buffer            = new Buffer(0);
	  this._longPacketBuffers = [];
	  this._offset            = 0;
	  this._packetEnd         = null;
	  this._packetHeader      = null;
	  this._packetOffset      = null;
	  this._onError           = options.onError || function(err) { throw err; };
	  this._onPacket          = options.onPacket || function() {};
	  this._nextPacketNumber  = 0;
	  this._encoding          = 'utf-8';
	  this._paused            = false;
	}
	
	Parser.prototype.write = function(buffer) {
	  this.append(buffer);
	
	  while (true) {
	    if (this._paused) {
	      return;
	    }
	
	    if (!this._packetHeader) {
	      if (this._bytesRemaining() < 4) {
	        break;
	      }
	
	      this._packetHeader = new PacketHeader(
	        this.parseUnsignedNumber(3),
	        this.parseUnsignedNumber(1)
	      );
	
	      if (this._packetHeader.number !== this._nextPacketNumber) {
	        var err = new Error(
	          'Packets out of order. Got: ' + this._packetHeader.number + ' ' +
	          'Expected: ' + this._nextPacketNumber
	        );
	
	        err.code  = 'PROTOCOL_PACKETS_OUT_OF_ORDER';
	        err.fatal = true;
	
	        this._onError(err);
	      }
	
	      this.incrementPacketNumber();
	    }
	
	    if (this._bytesRemaining() < this._packetHeader.length) {
	      break;
	    }
	
	    this._packetEnd    = this._offset + this._packetHeader.length;
	    this._packetOffset = this._offset;
	
	    if (this._packetHeader.length === MAX_PACKET_LENGTH) {
	      this._longPacketBuffers.push(this._buffer.slice(this._packetOffset, this._packetEnd));
	
	      this._advanceToNextPacket();
	      continue;
	    }
	
	    this._combineLongPacketBuffers();
	
	    // Try...finally to ensure exception safety. Unfortunately this is costing
	    // us up to ~10% performance in some benchmarks.
	    var hadException = true;
	    try {
	      this._onPacket(this._packetHeader);
	      hadException = false;
	    } catch (err) {
	      if (!err || typeof err.code !== 'string' || err.code.substr(0, 7) !== 'PARSER_') {
	        // Rethrow unknown errors
	        throw err;
	      }
	
	      // Pass down parser errors
	      this._onError(err);
	      hadException = false;
	    } finally {
	      this._advanceToNextPacket();
	
	      // If we had an exception, the parser while loop will be broken out
	      // of after the finally block. So we need to make sure to re-enter it
	      // to continue parsing any bytes that may already have been received.
	      if (hadException) {
	        process.nextTick(this.write.bind(this));
	      }
	    }
	  }
	};
	
	Parser.prototype.append = function append(chunk) {
	  if (!chunk || chunk.length === 0) {
	    return;
	  }
	
	  var buffer      = chunk;
	  var sliceEnd    = this._buffer.length;
	  var sliceStart  = this._packetOffset === null
	    ? this._offset
	    : this._packetOffset;
	  var sliceLength = sliceEnd - sliceStart;
	
	  if (sliceLength !== 0) {
	    // Create a new Buffer
	    buffer = new Buffer(sliceLength + chunk.length);
	
	    // Copy data
	    this._buffer.copy(buffer, 0, sliceStart, sliceEnd);
	    chunk.copy(buffer, sliceLength);
	  }
	
	  // Adjust data-tracking pointers
	  this._buffer       = buffer;
	  this._offset       = this._offset - sliceStart;
	  this._packetEnd    = this._packetEnd !== null
	    ? this._packetEnd - sliceStart
	    : null;
	  this._packetOffset = this._packetOffset !== null
	    ? this._packetOffset - sliceStart
	    : null;
	};
	
	Parser.prototype.pause = function() {
	  this._paused = true;
	};
	
	Parser.prototype.resume = function() {
	  this._paused = false;
	
	  // nextTick() to avoid entering write() multiple times within the same stack
	  // which would cause problems as write manipulates the state of the object.
	  process.nextTick(this.write.bind(this));
	};
	
	Parser.prototype.peak = function() {
	  return this._buffer[this._offset];
	};
	
	Parser.prototype.parseUnsignedNumber = function(bytes) {
	  if (bytes === 1) {
	    return this._buffer[this._offset++];
	  }
	
	  var buffer = this._buffer;
	  var offset = this._offset + bytes - 1;
	  var value  = 0;
	
	  if (bytes > 4) {
	    var err    = new Error('parseUnsignedNumber: Supports only up to 4 bytes');
	    err.offset = (this._offset - this._packetOffset - 1);
	    err.code   = 'PARSER_UNSIGNED_TOO_LONG';
	    throw err;
	  }
	
	  while (offset >= this._offset) {
	    value = ((value << 8) | buffer[offset]) >>> 0;
	    offset--;
	  }
	
	  this._offset += bytes;
	
	  return value;
	};
	
	Parser.prototype.parseLengthCodedString = function() {
	  var length = this.parseLengthCodedNumber();
	
	  if (length === null) {
	    return null;
	  }
	
	  return this.parseString(length);
	};
	
	Parser.prototype.parseLengthCodedBuffer = function() {
	  var length = this.parseLengthCodedNumber();
	
	  if (length === null) {
	    return null;
	  }
	
	  return this.parseBuffer(length);
	};
	
	Parser.prototype.parseLengthCodedNumber = function parseLengthCodedNumber() {
	  if (this._offset >= this._buffer.length) {
	    var err    = new Error('Parser: read past end');
	    err.offset = (this._offset - this._packetOffset);
	    err.code   = 'PARSER_READ_PAST_END';
	    throw err;
	  }
	
	  var bits = this._buffer[this._offset++];
	
	  if (bits <= 250) {
	    return bits;
	  }
	
	  switch (bits) {
	    case 251:
	      return null;
	    case 252:
	      return this.parseUnsignedNumber(2);
	    case 253:
	      return this.parseUnsignedNumber(3);
	    case 254:
	      break;
	    default:
	      var err    = new Error('Unexpected first byte' + (bits ? ': 0x' + bits.toString(16) : ''));
	      err.offset = (this._offset - this._packetOffset - 1);
	      err.code   = 'PARSER_BAD_LENGTH_BYTE';
	      throw err;
	  }
	
	  var low = this.parseUnsignedNumber(4);
	  var high = this.parseUnsignedNumber(4);
	  var value;
	
	  if (high >>> 21) {
	    value = (new BigNumber(low)).plus((new BigNumber(MUL_32BIT)).times(high)).toString();
	
	    if (this._supportBigNumbers) {
	      return value;
	    }
	
	    var err    = new Error(
	      'parseLengthCodedNumber: JS precision range exceeded, ' +
	      'number is >= 53 bit: "' + value + '"'
	    );
	    err.offset = (this._offset - this._packetOffset - 8);
	    err.code   = 'PARSER_JS_PRECISION_RANGE_EXCEEDED';
	    throw err;
	  }
	
	  value = low + (MUL_32BIT * high);
	
	  return value;
	};
	
	Parser.prototype.parseFiller = function(length) {
	  return this.parseBuffer(length);
	};
	
	Parser.prototype.parseNullTerminatedBuffer = function() {
	  var end      = this._nullByteOffset();
	  var value    = this._buffer.slice(this._offset, end);
	  this._offset = end + 1;
	
	  return value;
	};
	
	Parser.prototype.parseNullTerminatedString = function() {
	  var end      = this._nullByteOffset();
	  var value    = this._buffer.toString(this._encoding, this._offset, end);
	  this._offset = end + 1;
	
	  return value;
	};
	
	Parser.prototype._nullByteOffset = function() {
	  var offset = this._offset;
	
	  while (this._buffer[offset] !== 0x00) {
	    offset++;
	
	    if (offset >= this._buffer.length) {
	      var err    = new Error('Offset of null terminated string not found.');
	      err.offset = (this._offset - this._packetOffset);
	      err.code   = 'PARSER_MISSING_NULL_BYTE';
	      throw err;
	    }
	  }
	
	  return offset;
	};
	
	Parser.prototype.parsePacketTerminatedString = function() {
	  var length = this._packetEnd - this._offset;
	  return this.parseString(length);
	};
	
	Parser.prototype.parseBuffer = function(length) {
	  var response = new Buffer(length);
	  this._buffer.copy(response, 0, this._offset, this._offset + length);
	
	  this._offset += length;
	  return response;
	};
	
	Parser.prototype.parseString = function(length) {
	  var offset = this._offset;
	  var end = offset + length;
	  var value = this._buffer.toString(this._encoding, offset, end);
	
	  this._offset = end;
	  return value;
	};
	
	Parser.prototype.parseGeometryValue = function() {
	  var buffer = this.parseLengthCodedBuffer();
	  var offset = 4;
	
	  if (buffer === null ||!buffer.length) {
	    return null;
	  }
	
	  function parseGeometry() {
	    var result = null;
	    var byteOrder = buffer.readUInt8(offset); offset += 1;
	    var wkbType = byteOrder? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset); offset += 4;
	    switch(wkbType) {
	      case 1: // WKBPoint
	        var x = byteOrder? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset); offset += 8;
	        var y = byteOrder? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset); offset += 8;
	        result = {x: x, y: y};
	        break;
	      case 2: // WKBLineString
	        var numPoints = byteOrder? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset); offset += 4;
	        result = [];
	        for(var i=numPoints;i>0;i--) {
	          var x = byteOrder? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset); offset += 8;
	          var y = byteOrder? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset); offset += 8;
	          result.push({x: x, y: y});
	        }
	        break;
	      case 3: // WKBPolygon
	        var numRings = byteOrder? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset); offset += 4;
	        result = [];
	        for(var i=numRings;i>0;i--) {
	          var numPoints = byteOrder? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset); offset += 4;
	          var line = [];
	          for(var j=numPoints;j>0;j--) {
	            var x = byteOrder? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset); offset += 8;
	            var y = byteOrder? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset); offset += 8;
	            line.push({x: x, y: y});
	          }
	          result.push(line);
	        }
	        break;
	      case 4: // WKBMultiPoint
	      case 5: // WKBMultiLineString
	      case 6: // WKBMultiPolygon
	      case 7: // WKBGeometryCollection
	        var num = byteOrder? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset); offset += 4;
	        var result = [];
	        for(var i=num;i>0;i--) {
	          result.push(parseGeometry());
	        }
	        break;
	    }
	    return result;
	  }
	  return parseGeometry();
	};
	
	Parser.prototype.reachedPacketEnd = function() {
	  return this._offset === this._packetEnd;
	};
	
	Parser.prototype._bytesRemaining = function() {
	  return this._buffer.length - this._offset;
	};
	
	Parser.prototype.incrementPacketNumber = function() {
	  var currentPacketNumber = this._nextPacketNumber;
	  this._nextPacketNumber = (this._nextPacketNumber + 1) % 256;
	
	  return currentPacketNumber;
	};
	
	Parser.prototype.resetPacketNumber = function() {
	  this._nextPacketNumber = 0;
	};
	
	Parser.prototype.packetLength = function() {
	  return this._longPacketBuffers.reduce(function(length, buffer) {
	    return length + buffer.length;
	  }, this._packetHeader.length);
	};
	
	Parser.prototype._combineLongPacketBuffers = function() {
	  if (!this._longPacketBuffers.length) {
	    return;
	  }
	
	  var trailingPacketBytes = this._buffer.length - this._packetEnd;
	
	  var length = this._longPacketBuffers.reduce(function(length, buffer) {
	    return length + buffer.length;
	  }, this._bytesRemaining());
	
	  var combinedBuffer = new Buffer(length);
	
	  var offset = this._longPacketBuffers.reduce(function(offset, buffer) {
	    buffer.copy(combinedBuffer, offset);
	    return offset + buffer.length;
	  }, 0);
	
	  this._buffer.copy(combinedBuffer, offset, this._offset);
	
	  this._buffer            = combinedBuffer;
	  this._longPacketBuffers = [];
	  this._offset            = 0;
	  this._packetEnd         = this._buffer.length - trailingPacketBytes;
	  this._packetOffset      = 0;
	};
	
	Parser.prototype._advanceToNextPacket = function() {
	  this._offset       = this._packetEnd;
	  this._packetHeader = null;
	  this._packetEnd    = null;
	  this._packetOffset = null;
	};


/***/ },
/* 28 */
/***/ function(module, exports) {

	module.exports = PacketHeader;
	function PacketHeader(length, number) {
	  this.length = length;
	  this.number = number;
	}


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*! bignumber.js v2.0.7 https://github.com/MikeMcl/bignumber.js/LICENCE */
	
	;(function (global) {
	    'use strict';
	
	    /*
	      bignumber.js v2.0.7
	      A JavaScript library for arbitrary-precision arithmetic.
	      https://github.com/MikeMcl/bignumber.js
	      Copyright (c) 2015 Michael Mclaughlin <M8ch88l@gmail.com>
	      MIT Expat Licence
	    */
	
	
	    var BigNumber, crypto, parseNumeric,
	        isNumeric = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
	        mathceil = Math.ceil,
	        mathfloor = Math.floor,
	        notBool = ' not a boolean or binary digit',
	        roundingMode = 'rounding mode',
	        tooManyDigits = 'number type has more than 15 significant digits',
	        ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_',
	        BASE = 1e14,
	        LOG_BASE = 14,
	        MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
	        // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
	        POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
	        SQRT_BASE = 1e7,
	
	        /*
	         * The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
	         * the arguments to toExponential, toFixed, toFormat, and toPrecision, beyond which an
	         * exception is thrown (if ERRORS is true).
	         */
	        MAX = 1E9;                                   // 0 to MAX_INT32
	
	
	    /*
	     * Create and return a BigNumber constructor.
	     */
	    function another(configObj) {
	        var div,
	
	            // id tracks the caller function, so its name can be included in error messages.
	            id = 0,
	            P = BigNumber.prototype,
	            ONE = new BigNumber(1),
	
	
	            /********************************* EDITABLE DEFAULTS **********************************/
	
	
	            /*
	             * The default values below must be integers within the inclusive ranges stated.
	             * The values can also be changed at run-time using BigNumber.config.
	             */
	
	            // The maximum number of decimal places for operations involving division.
	            DECIMAL_PLACES = 20,                     // 0 to MAX
	
	            /*
	             * The rounding mode used when rounding to the above decimal places, and when using
	             * toExponential, toFixed, toFormat and toPrecision, and round (default value).
	             * UP         0 Away from zero.
	             * DOWN       1 Towards zero.
	             * CEIL       2 Towards +Infinity.
	             * FLOOR      3 Towards -Infinity.
	             * HALF_UP    4 Towards nearest neighbour. If equidistant, up.
	             * HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
	             * HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
	             * HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
	             * HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
	             */
	            ROUNDING_MODE = 4,                       // 0 to 8
	
	            // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]
	
	            // The exponent value at and beneath which toString returns exponential notation.
	            // Number type: -7
	            TO_EXP_NEG = -7,                         // 0 to -MAX
	
	            // The exponent value at and above which toString returns exponential notation.
	            // Number type: 21
	            TO_EXP_POS = 21,                         // 0 to MAX
	
	            // RANGE : [MIN_EXP, MAX_EXP]
	
	            // The minimum exponent value, beneath which underflow to zero occurs.
	            // Number type: -324  (5e-324)
	            MIN_EXP = -1e7,                          // -1 to -MAX
	
	            // The maximum exponent value, above which overflow to Infinity occurs.
	            // Number type:  308  (1.7976931348623157e+308)
	            // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
	            MAX_EXP = 1e7,                           // 1 to MAX
	
	            // Whether BigNumber Errors are ever thrown.
	            ERRORS = true,                           // true or false
	
	            // Change to intValidatorNoErrors if ERRORS is false.
	            isValidInt = intValidatorWithErrors,     // intValidatorWithErrors/intValidatorNoErrors
	
	            // Whether to use cryptographically-secure random number generation, if available.
	            CRYPTO = false,                          // true or false
	
	            /*
	             * The modulo mode used when calculating the modulus: a mod n.
	             * The quotient (q = a / n) is calculated according to the corresponding rounding mode.
	             * The remainder (r) is calculated as: r = a - n * q.
	             *
	             * UP        0 The remainder is positive if the dividend is negative, else is negative.
	             * DOWN      1 The remainder has the same sign as the dividend.
	             *             This modulo mode is commonly known as 'truncated division' and is
	             *             equivalent to (a % n) in JavaScript.
	             * FLOOR     3 The remainder has the same sign as the divisor (Python %).
	             * HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
	             * EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
	             *             The remainder is always positive.
	             *
	             * The truncated division, floored division, Euclidian division and IEEE 754 remainder
	             * modes are commonly used for the modulus operation.
	             * Although the other rounding modes can also be used, they may not give useful results.
	             */
	            MODULO_MODE = 1,                         // 0 to 9
	
	            // The maximum number of significant digits of the result of the toPower operation.
	            // If POW_PRECISION is 0, there will be unlimited significant digits.
	            POW_PRECISION = 100,                     // 0 to MAX
	
	            // The format specification used by the BigNumber.prototype.toFormat method.
	            FORMAT = {
	                decimalSeparator: '.',
	                groupSeparator: ',',
	                groupSize: 3,
	                secondaryGroupSize: 0,
	                fractionGroupSeparator: '\xA0',      // non-breaking space
	                fractionGroupSize: 0
	            };
	
	
	        /******************************************************************************************/
	
	
	        // CONSTRUCTOR
	
	
	        /*
	         * The BigNumber constructor and exported function.
	         * Create and return a new instance of a BigNumber object.
	         *
	         * n {number|string|BigNumber} A numeric value.
	         * [b] {number} The base of n. Integer, 2 to 64 inclusive.
	         */
	        function BigNumber( n, b ) {
	            var c, e, i, num, len, str,
	                x = this;
	
	            // Enable constructor usage without new.
	            if ( !( x instanceof BigNumber ) ) {
	
	                // 'BigNumber() constructor call without new: {n}'
	                if (ERRORS) raise( 26, 'constructor call without new', n );
	                return new BigNumber( n, b );
	            }
	
	            // 'new BigNumber() base not an integer: {b}'
	            // 'new BigNumber() base out of range: {b}'
	            if ( b == null || !isValidInt( b, 2, 64, id, 'base' ) ) {
	
	                // Duplicate.
	                if ( n instanceof BigNumber ) {
	                    x.s = n.s;
	                    x.e = n.e;
	                    x.c = ( n = n.c ) ? n.slice() : n;
	                    id = 0;
	                    return;
	                }
	
	                if ( ( num = typeof n == 'number' ) && n * 0 == 0 ) {
	                    x.s = 1 / n < 0 ? ( n = -n, -1 ) : 1;
	
	                    // Fast path for integers.
	                    if ( n === ~~n ) {
	                        for ( e = 0, i = n; i >= 10; i /= 10, e++ );
	                        x.e = e;
	                        x.c = [n];
	                        id = 0;
	                        return;
	                    }
	
	                    str = n + '';
	                } else {
	                    if ( !isNumeric.test( str = n + '' ) ) return parseNumeric( x, str, num );
	                    x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
	                }
	            } else {
	                b = b | 0;
	                str = n + '';
	
	                // Ensure return value is rounded to DECIMAL_PLACES as with other bases.
	                // Allow exponential notation to be used with base 10 argument.
	                if ( b == 10 ) {
	                    x = new BigNumber( n instanceof BigNumber ? n : str );
	                    return round( x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE );
	                }
	
	                // Avoid potential interpretation of Infinity and NaN as base 44+ values.
	                // Any number in exponential form will fail due to the [Ee][+-].
	                if ( ( num = typeof n == 'number' ) && n * 0 != 0 ||
	                  !( new RegExp( '^-?' + ( c = '[' + ALPHABET.slice( 0, b ) + ']+' ) +
	                    '(?:\\.' + c + ')?$',b < 37 ? 'i' : '' ) ).test(str) ) {
	                    return parseNumeric( x, str, num, b );
	                }
	
	                if (num) {
	                    x.s = 1 / n < 0 ? ( str = str.slice(1), -1 ) : 1;
	
	                    if ( ERRORS && str.replace( /^0\.0*|\./, '' ).length > 15 ) {
	
	                        // 'new BigNumber() number type has more than 15 significant digits: {n}'
	                        raise( id, tooManyDigits, n );
	                    }
	
	                    // Prevent later check for length on converted number.
	                    num = false;
	                } else {
	                    x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
	                }
	
	                str = convertBase( str, 10, b, x.s );
	            }
	
	            // Decimal point?
	            if ( ( e = str.indexOf('.') ) > -1 ) str = str.replace( '.', '' );
	
	            // Exponential form?
	            if ( ( i = str.search( /e/i ) ) > 0 ) {
	
	                // Determine exponent.
	                if ( e < 0 ) e = i;
	                e += +str.slice( i + 1 );
	                str = str.substring( 0, i );
	            } else if ( e < 0 ) {
	
	                // Integer.
	                e = str.length;
	            }
	
	            // Determine leading zeros.
	            for ( i = 0; str.charCodeAt(i) === 48; i++ );
	
	            // Determine trailing zeros.
	            for ( len = str.length; str.charCodeAt(--len) === 48; );
	            str = str.slice( i, len + 1 );
	
	            if (str) {
	                len = str.length;
	
	                // Disallow numbers with over 15 significant digits if number type.
	                // 'new BigNumber() number type has more than 15 significant digits: {n}'
	                if ( num && ERRORS && len > 15 ) raise( id, tooManyDigits, x.s * n );
	
	                e = e - i - 1;
	
	                 // Overflow?
	                if ( e > MAX_EXP ) {
	
	                    // Infinity.
	                    x.c = x.e = null;
	
	                // Underflow?
	                } else if ( e < MIN_EXP ) {
	
	                    // Zero.
	                    x.c = [ x.e = 0 ];
	                } else {
	                    x.e = e;
	                    x.c = [];
	
	                    // Transform base
	
	                    // e is the base 10 exponent.
	                    // i is where to slice str to get the first element of the coefficient array.
	                    i = ( e + 1 ) % LOG_BASE;
	                    if ( e < 0 ) i += LOG_BASE;
	
	                    if ( i < len ) {
	                        if (i) x.c.push( +str.slice( 0, i ) );
	
	                        for ( len -= LOG_BASE; i < len; ) {
	                            x.c.push( +str.slice( i, i += LOG_BASE ) );
	                        }
	
	                        str = str.slice(i);
	                        i = LOG_BASE - str.length;
	                    } else {
	                        i -= len;
	                    }
	
	                    for ( ; i--; str += '0' );
	                    x.c.push( +str );
	                }
	            } else {
	
	                // Zero.
	                x.c = [ x.e = 0 ];
	            }
	
	            id = 0;
	        }
	
	
	        // CONSTRUCTOR PROPERTIES
	
	
	        BigNumber.another = another;
	
	        BigNumber.ROUND_UP = 0;
	        BigNumber.ROUND_DOWN = 1;
	        BigNumber.ROUND_CEIL = 2;
	        BigNumber.ROUND_FLOOR = 3;
	        BigNumber.ROUND_HALF_UP = 4;
	        BigNumber.ROUND_HALF_DOWN = 5;
	        BigNumber.ROUND_HALF_EVEN = 6;
	        BigNumber.ROUND_HALF_CEIL = 7;
	        BigNumber.ROUND_HALF_FLOOR = 8;
	        BigNumber.EUCLID = 9;
	
	
	        /*
	         * Configure infrequently-changing library-wide settings.
	         *
	         * Accept an object or an argument list, with one or many of the following properties or
	         * parameters respectively:
	         *
	         *   DECIMAL_PLACES  {number}  Integer, 0 to MAX inclusive
	         *   ROUNDING_MODE   {number}  Integer, 0 to 8 inclusive
	         *   EXPONENTIAL_AT  {number|number[]}  Integer, -MAX to MAX inclusive or
	         *                                      [integer -MAX to 0 incl., 0 to MAX incl.]
	         *   RANGE           {number|number[]}  Non-zero integer, -MAX to MAX inclusive or
	         *                                      [integer -MAX to -1 incl., integer 1 to MAX incl.]
	         *   ERRORS          {boolean|number}   true, false, 1 or 0
	         *   CRYPTO          {boolean|number}   true, false, 1 or 0
	         *   MODULO_MODE     {number}           0 to 9 inclusive
	         *   POW_PRECISION   {number}           0 to MAX inclusive
	         *   FORMAT          {object}           See BigNumber.prototype.toFormat
	         *      decimalSeparator       {string}
	         *      groupSeparator         {string}
	         *      groupSize              {number}
	         *      secondaryGroupSize     {number}
	         *      fractionGroupSeparator {string}
	         *      fractionGroupSize      {number}
	         *
	         * (The values assigned to the above FORMAT object properties are not checked for validity.)
	         *
	         * E.g.
	         * BigNumber.config(20, 4) is equivalent to
	         * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
	         *
	         * Ignore properties/parameters set to null or undefined.
	         * Return an object with the properties current values.
	         */
	        BigNumber.config = function () {
	            var v, p,
	                i = 0,
	                r = {},
	                a = arguments,
	                o = a[0],
	                has = o && typeof o == 'object'
	                  ? function () { if ( o.hasOwnProperty(p) ) return ( v = o[p] ) != null; }
	                  : function () { if ( a.length > i ) return ( v = a[i++] ) != null; };
	
	            // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
	            // 'config() DECIMAL_PLACES not an integer: {v}'
	            // 'config() DECIMAL_PLACES out of range: {v}'
	            if ( has( p = 'DECIMAL_PLACES' ) && isValidInt( v, 0, MAX, 2, p ) ) {
	                DECIMAL_PLACES = v | 0;
	            }
	            r[p] = DECIMAL_PLACES;
	
	            // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
	            // 'config() ROUNDING_MODE not an integer: {v}'
	            // 'config() ROUNDING_MODE out of range: {v}'
	            if ( has( p = 'ROUNDING_MODE' ) && isValidInt( v, 0, 8, 2, p ) ) {
	                ROUNDING_MODE = v | 0;
	            }
	            r[p] = ROUNDING_MODE;
	
	            // EXPONENTIAL_AT {number|number[]}
	            // Integer, -MAX to MAX inclusive or [integer -MAX to 0 inclusive, 0 to MAX inclusive].
	            // 'config() EXPONENTIAL_AT not an integer: {v}'
	            // 'config() EXPONENTIAL_AT out of range: {v}'
	            if ( has( p = 'EXPONENTIAL_AT' ) ) {
	
	                if ( isArray(v) ) {
	                    if ( isValidInt( v[0], -MAX, 0, 2, p ) && isValidInt( v[1], 0, MAX, 2, p ) ) {
	                        TO_EXP_NEG = v[0] | 0;
	                        TO_EXP_POS = v[1] | 0;
	                    }
	                } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
	                    TO_EXP_NEG = -( TO_EXP_POS = ( v < 0 ? -v : v ) | 0 );
	                }
	            }
	            r[p] = [ TO_EXP_NEG, TO_EXP_POS ];
	
	            // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
	            // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
	            // 'config() RANGE not an integer: {v}'
	            // 'config() RANGE cannot be zero: {v}'
	            // 'config() RANGE out of range: {v}'
	            if ( has( p = 'RANGE' ) ) {
	
	                if ( isArray(v) ) {
	                    if ( isValidInt( v[0], -MAX, -1, 2, p ) && isValidInt( v[1], 1, MAX, 2, p ) ) {
	                        MIN_EXP = v[0] | 0;
	                        MAX_EXP = v[1] | 0;
	                    }
	                } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
	                    if ( v | 0 ) MIN_EXP = -( MAX_EXP = ( v < 0 ? -v : v ) | 0 );
	                    else if (ERRORS) raise( 2, p + ' cannot be zero', v );
	                }
	            }
	            r[p] = [ MIN_EXP, MAX_EXP ];
	
	            // ERRORS {boolean|number} true, false, 1 or 0.
	            // 'config() ERRORS not a boolean or binary digit: {v}'
	            if ( has( p = 'ERRORS' ) ) {
	
	                if ( v === !!v || v === 1 || v === 0 ) {
	                    id = 0;
	                    isValidInt = ( ERRORS = !!v ) ? intValidatorWithErrors : intValidatorNoErrors;
	                } else if (ERRORS) {
	                    raise( 2, p + notBool, v );
	                }
	            }
	            r[p] = ERRORS;
	
	            // CRYPTO {boolean|number} true, false, 1 or 0.
	            // 'config() CRYPTO not a boolean or binary digit: {v}'
	            // 'config() crypto unavailable: {crypto}'
	            if ( has( p = 'CRYPTO' ) ) {
	
	                if ( v === !!v || v === 1 || v === 0 ) {
	                    CRYPTO = !!( v && crypto && typeof crypto == 'object' );
	                    if ( v && !CRYPTO && ERRORS ) raise( 2, 'crypto unavailable', crypto );
	                } else if (ERRORS) {
	                    raise( 2, p + notBool, v );
	                }
	            }
	            r[p] = CRYPTO;
	
	            // MODULO_MODE {number} Integer, 0 to 9 inclusive.
	            // 'config() MODULO_MODE not an integer: {v}'
	            // 'config() MODULO_MODE out of range: {v}'
	            if ( has( p = 'MODULO_MODE' ) && isValidInt( v, 0, 9, 2, p ) ) {
	                MODULO_MODE = v | 0;
	            }
	            r[p] = MODULO_MODE;
	
	            // POW_PRECISION {number} Integer, 0 to MAX inclusive.
	            // 'config() POW_PRECISION not an integer: {v}'
	            // 'config() POW_PRECISION out of range: {v}'
	            if ( has( p = 'POW_PRECISION' ) && isValidInt( v, 0, MAX, 2, p ) ) {
	                POW_PRECISION = v | 0;
	            }
	            r[p] = POW_PRECISION;
	
	            // FORMAT {object}
	            // 'config() FORMAT not an object: {v}'
	            if ( has( p = 'FORMAT' ) ) {
	
	                if ( typeof v == 'object' ) {
	                    FORMAT = v;
	                } else if (ERRORS) {
	                    raise( 2, p + ' not an object', v );
	                }
	            }
	            r[p] = FORMAT;
	
	            return r;
	        };
	
	
	        /*
	         * Return a new BigNumber whose value is the maximum of the arguments.
	         *
	         * arguments {number|string|BigNumber}
	         */
	        BigNumber.max = function () { return maxOrMin( arguments, P.lt ); };
	
	
	        /*
	         * Return a new BigNumber whose value is the minimum of the arguments.
	         *
	         * arguments {number|string|BigNumber}
	         */
	        BigNumber.min = function () { return maxOrMin( arguments, P.gt ); };
	
	
	        /*
	         * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
	         * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
	         * zeros are produced).
	         *
	         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
	         *
	         * 'random() decimal places not an integer: {dp}'
	         * 'random() decimal places out of range: {dp}'
	         * 'random() crypto unavailable: {crypto}'
	         */
	        BigNumber.random = (function () {
	            var pow2_53 = 0x20000000000000;
	
	            // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
	            // Check if Math.random() produces more than 32 bits of randomness.
	            // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
	            // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
	            var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
	              ? function () { return mathfloor( Math.random() * pow2_53 ); }
	              : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
	                  (Math.random() * 0x800000 | 0); };
	
	            return function (dp) {
	                var a, b, e, k, v,
	                    i = 0,
	                    c = [],
	                    rand = new BigNumber(ONE);
	
	                dp = dp == null || !isValidInt( dp, 0, MAX, 14 ) ? DECIMAL_PLACES : dp | 0;
	                k = mathceil( dp / LOG_BASE );
	
	                if (CRYPTO) {
	
	                    // Browsers supporting crypto.getRandomValues.
	                    if ( crypto && crypto.getRandomValues ) {
	
	                        a = crypto.getRandomValues( new Uint32Array( k *= 2 ) );
	
	                        for ( ; i < k; ) {
	
	                            // 53 bits:
	                            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
	                            // 11111 11111111 11111111 11111111 11100000 00000000 00000000
	                            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
	                            //                                     11111 11111111 11111111
	                            // 0x20000 is 2^21.
	                            v = a[i] * 0x20000 + (a[i + 1] >>> 11);
	
	                            // Rejection sampling:
	                            // 0 <= v < 9007199254740992
	                            // Probability that v >= 9e15, is
	                            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
	                            if ( v >= 9e15 ) {
	                                b = crypto.getRandomValues( new Uint32Array(2) );
	                                a[i] = b[0];
	                                a[i + 1] = b[1];
	                            } else {
	
	                                // 0 <= v <= 8999999999999999
	                                // 0 <= (v % 1e14) <= 99999999999999
	                                c.push( v % 1e14 );
	                                i += 2;
	                            }
	                        }
	                        i = k / 2;
	
	                    // Node.js supporting crypto.randomBytes.
	                    } else if ( crypto && crypto.randomBytes ) {
	
	                        // buffer
	                        a = crypto.randomBytes( k *= 7 );
	
	                        for ( ; i < k; ) {
	
	                            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
	                            // 0x100000000 is 2^32, 0x1000000 is 2^24
	                            // 11111 11111111 11111111 11111111 11111111 11111111 11111111
	                            // 0 <= v < 9007199254740992
	                            v = ( ( a[i] & 31 ) * 0x1000000000000 ) + ( a[i + 1] * 0x10000000000 ) +
	                                  ( a[i + 2] * 0x100000000 ) + ( a[i + 3] * 0x1000000 ) +
	                                  ( a[i + 4] << 16 ) + ( a[i + 5] << 8 ) + a[i + 6];
	
	                            if ( v >= 9e15 ) {
	                                crypto.randomBytes(7).copy( a, i );
	                            } else {
	
	                                // 0 <= (v % 1e14) <= 99999999999999
	                                c.push( v % 1e14 );
	                                i += 7;
	                            }
	                        }
	                        i = k / 7;
	                    } else if (ERRORS) {
	                        raise( 14, 'crypto unavailable', crypto );
	                    }
	                }
	
	                // Use Math.random: CRYPTO is false or crypto is unavailable and ERRORS is false.
	                if (!i) {
	
	                    for ( ; i < k; ) {
	                        v = random53bitInt();
	                        if ( v < 9e15 ) c[i++] = v % 1e14;
	                    }
	                }
	
	                k = c[--i];
	                dp %= LOG_BASE;
	
	                // Convert trailing digits to zeros according to dp.
	                if ( k && dp ) {
	                    v = POWS_TEN[LOG_BASE - dp];
	                    c[i] = mathfloor( k / v ) * v;
	                }
	
	                // Remove trailing elements which are zero.
	                for ( ; c[i] === 0; c.pop(), i-- );
	
	                // Zero?
	                if ( i < 0 ) {
	                    c = [ e = 0 ];
	                } else {
	
	                    // Remove leading elements which are zero and adjust exponent accordingly.
	                    for ( e = -1 ; c[0] === 0; c.shift(), e -= LOG_BASE);
	
	                    // Count the digits of the first element of c to determine leading zeros, and...
	                    for ( i = 1, v = c[0]; v >= 10; v /= 10, i++);
	
	                    // adjust the exponent accordingly.
	                    if ( i < LOG_BASE ) e -= LOG_BASE - i;
	                }
	
	                rand.e = e;
	                rand.c = c;
	                return rand;
	            };
	        })();
	
	
	        // PRIVATE FUNCTIONS
	
	
	        // Convert a numeric string of baseIn to a numeric string of baseOut.
	        function convertBase( str, baseOut, baseIn, sign ) {
	            var d, e, k, r, x, xc, y,
	                i = str.indexOf( '.' ),
	                dp = DECIMAL_PLACES,
	                rm = ROUNDING_MODE;
	
	            if ( baseIn < 37 ) str = str.toLowerCase();
	
	            // Non-integer.
	            if ( i >= 0 ) {
	                k = POW_PRECISION;
	
	                // Unlimited precision.
	                POW_PRECISION = 0;
	                str = str.replace( '.', '' );
	                y = new BigNumber(baseIn);
	                x = y.pow( str.length - i );
	                POW_PRECISION = k;
	
	                // Convert str as if an integer, then restore the fraction part by dividing the
	                // result by its base raised to a power.
	                y.c = toBaseOut( toFixedPoint( coeffToString( x.c ), x.e ), 10, baseOut );
	                y.e = y.c.length;
	            }
	
	            // Convert the number as integer.
	            xc = toBaseOut( str, baseIn, baseOut );
	            e = k = xc.length;
	
	            // Remove trailing zeros.
	            for ( ; xc[--k] == 0; xc.pop() );
	            if ( !xc[0] ) return '0';
	
	            if ( i < 0 ) {
	                --e;
	            } else {
	                x.c = xc;
	                x.e = e;
	
	                // sign is needed for correct rounding.
	                x.s = sign;
	                x = div( x, y, dp, rm, baseOut );
	                xc = x.c;
	                r = x.r;
	                e = x.e;
	            }
	
	            d = e + dp + 1;
	
	            // The rounding digit, i.e. the digit to the right of the digit that may be rounded up.
	            i = xc[d];
	            k = baseOut / 2;
	            r = r || d < 0 || xc[d + 1] != null;
	
	            r = rm < 4 ? ( i != null || r ) && ( rm == 0 || rm == ( x.s < 0 ? 3 : 2 ) )
	                       : i > k || i == k &&( rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
	                         rm == ( x.s < 0 ? 8 : 7 ) );
	
	            if ( d < 1 || !xc[0] ) {
	
	                // 1^-dp or 0.
	                str = r ? toFixedPoint( '1', -dp ) : '0';
	            } else {
	                xc.length = d;
	
	                if (r) {
	
	                    // Rounding up may mean the previous digit has to be rounded up and so on.
	                    for ( --baseOut; ++xc[--d] > baseOut; ) {
	                        xc[d] = 0;
	
	                        if ( !d ) {
	                            ++e;
	                            xc.unshift(1);
	                        }
	                    }
	                }
	
	                // Determine trailing zeros.
	                for ( k = xc.length; !xc[--k]; );
	
	                // E.g. [4, 11, 15] becomes 4bf.
	                for ( i = 0, str = ''; i <= k; str += ALPHABET.charAt( xc[i++] ) );
	                str = toFixedPoint( str, e );
	            }
	
	            // The caller will add the sign.
	            return str;
	        }
	
	
	        // Perform division in the specified base. Called by div and convertBase.
	        div = (function () {
	
	            // Assume non-zero x and k.
	            function multiply( x, k, base ) {
	                var m, temp, xlo, xhi,
	                    carry = 0,
	                    i = x.length,
	                    klo = k % SQRT_BASE,
	                    khi = k / SQRT_BASE | 0;
	
	                for ( x = x.slice(); i--; ) {
	                    xlo = x[i] % SQRT_BASE;
	                    xhi = x[i] / SQRT_BASE | 0;
	                    m = khi * xlo + xhi * klo;
	                    temp = klo * xlo + ( ( m % SQRT_BASE ) * SQRT_BASE ) + carry;
	                    carry = ( temp / base | 0 ) + ( m / SQRT_BASE | 0 ) + khi * xhi;
	                    x[i] = temp % base;
	                }
	
	                if (carry) x.unshift(carry);
	
	                return x;
	            }
	
	            function compare( a, b, aL, bL ) {
	                var i, cmp;
	
	                if ( aL != bL ) {
	                    cmp = aL > bL ? 1 : -1;
	                } else {
	
	                    for ( i = cmp = 0; i < aL; i++ ) {
	
	                        if ( a[i] != b[i] ) {
	                            cmp = a[i] > b[i] ? 1 : -1;
	                            break;
	                        }
	                    }
	                }
	                return cmp;
	            }
	
	            function subtract( a, b, aL, base ) {
	                var i = 0;
	
	                // Subtract b from a.
	                for ( ; aL--; ) {
	                    a[aL] -= i;
	                    i = a[aL] < b[aL] ? 1 : 0;
	                    a[aL] = i * base + a[aL] - b[aL];
	                }
	
	                // Remove leading zeros.
	                for ( ; !a[0] && a.length > 1; a.shift() );
	            }
	
	            // x: dividend, y: divisor.
	            return function ( x, y, dp, rm, base ) {
	                var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
	                    yL, yz,
	                    s = x.s == y.s ? 1 : -1,
	                    xc = x.c,
	                    yc = y.c;
	
	                // Either NaN, Infinity or 0?
	                if ( !xc || !xc[0] || !yc || !yc[0] ) {
	
	                    return new BigNumber(
	
	                      // Return NaN if either NaN, or both Infinity or 0.
	                      !x.s || !y.s || ( xc ? yc && xc[0] == yc[0] : !yc ) ? NaN :
	
	                        // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
	                        xc && xc[0] == 0 || !yc ? s * 0 : s / 0
	                    );
	                }
	
	                q = new BigNumber(s);
	                qc = q.c = [];
	                e = x.e - y.e;
	                s = dp + e + 1;
	
	                if ( !base ) {
	                    base = BASE;
	                    e = bitFloor( x.e / LOG_BASE ) - bitFloor( y.e / LOG_BASE );
	                    s = s / LOG_BASE | 0;
	                }
	
	                // Result exponent may be one less then the current value of e.
	                // The coefficients of the BigNumbers from convertBase may have trailing zeros.
	                for ( i = 0; yc[i] == ( xc[i] || 0 ); i++ );
	                if ( yc[i] > ( xc[i] || 0 ) ) e--;
	
	                if ( s < 0 ) {
	                    qc.push(1);
	                    more = true;
	                } else {
	                    xL = xc.length;
	                    yL = yc.length;
	                    i = 0;
	                    s += 2;
	
	                    // Normalise xc and yc so highest order digit of yc is >= base / 2.
	
	                    n = mathfloor( base / ( yc[0] + 1 ) );
	
	                    // Not necessary, but to handle odd bases where yc[0] == ( base / 2 ) - 1.
	                    // if ( n > 1 || n++ == 1 && yc[0] < base / 2 ) {
	                    if ( n > 1 ) {
	                        yc = multiply( yc, n, base );
	                        xc = multiply( xc, n, base );
	                        yL = yc.length;
	                        xL = xc.length;
	                    }
	
	                    xi = yL;
	                    rem = xc.slice( 0, yL );
	                    remL = rem.length;
	
	                    // Add zeros to make remainder as long as divisor.
	                    for ( ; remL < yL; rem[remL++] = 0 );
	                    yz = yc.slice();
	                    yz.unshift(0);
	                    yc0 = yc[0];
	                    if ( yc[1] >= base / 2 ) yc0++;
	                    // Not necessary, but to prevent trial digit n > base, when using base 3.
	                    // else if ( base == 3 && yc0 == 1 ) yc0 = 1 + 1e-15;
	
	                    do {
	                        n = 0;
	
	                        // Compare divisor and remainder.
	                        cmp = compare( yc, rem, yL, remL );
	
	                        // If divisor < remainder.
	                        if ( cmp < 0 ) {
	
	                            // Calculate trial digit, n.
	
	                            rem0 = rem[0];
	                            if ( yL != remL ) rem0 = rem0 * base + ( rem[1] || 0 );
	
	                            // n is how many times the divisor goes into the current remainder.
	                            n = mathfloor( rem0 / yc0 );
	
	                            //  Algorithm:
	                            //  1. product = divisor * trial digit (n)
	                            //  2. if product > remainder: product -= divisor, n--
	                            //  3. remainder -= product
	                            //  4. if product was < remainder at 2:
	                            //    5. compare new remainder and divisor
	                            //    6. If remainder > divisor: remainder -= divisor, n++
	
	                            if ( n > 1 ) {
	
	                                // n may be > base only when base is 3.
	                                if (n >= base) n = base - 1;
	
	                                // product = divisor * trial digit.
	                                prod = multiply( yc, n, base );
	                                prodL = prod.length;
	                                remL = rem.length;
	
	                                // Compare product and remainder.
	                                // If product > remainder.
	                                // Trial digit n too high.
	                                // n is 1 too high about 5% of the time, and is not known to have
	                                // ever been more than 1 too high.
	                                while ( compare( prod, rem, prodL, remL ) == 1 ) {
	                                    n--;
	
	                                    // Subtract divisor from product.
	                                    subtract( prod, yL < prodL ? yz : yc, prodL, base );
	                                    prodL = prod.length;
	                                    cmp = 1;
	                                }
	                            } else {
	
	                                // n is 0 or 1, cmp is -1.
	                                // If n is 0, there is no need to compare yc and rem again below,
	                                // so change cmp to 1 to avoid it.
	                                // If n is 1, leave cmp as -1, so yc and rem are compared again.
	                                if ( n == 0 ) {
	
	                                    // divisor < remainder, so n must be at least 1.
	                                    cmp = n = 1;
	                                }
	
	                                // product = divisor
	                                prod = yc.slice();
	                                prodL = prod.length;
	                            }
	
	                            if ( prodL < remL ) prod.unshift(0);
	
	                            // Subtract product from remainder.
	                            subtract( rem, prod, remL, base );
	                            remL = rem.length;
	
	                             // If product was < remainder.
	                            if ( cmp == -1 ) {
	
	                                // Compare divisor and new remainder.
	                                // If divisor < new remainder, subtract divisor from remainder.
	                                // Trial digit n too low.
	                                // n is 1 too low about 5% of the time, and very rarely 2 too low.
	                                while ( compare( yc, rem, yL, remL ) < 1 ) {
	                                    n++;
	
	                                    // Subtract divisor from remainder.
	                                    subtract( rem, yL < remL ? yz : yc, remL, base );
	                                    remL = rem.length;
	                                }
	                            }
	                        } else if ( cmp === 0 ) {
	                            n++;
	                            rem = [0];
	                        } // else cmp === 1 and n will be 0
	
	                        // Add the next digit, n, to the result array.
	                        qc[i++] = n;
	
	                        // Update the remainder.
	                        if ( rem[0] ) {
	                            rem[remL++] = xc[xi] || 0;
	                        } else {
	                            rem = [ xc[xi] ];
	                            remL = 1;
	                        }
	                    } while ( ( xi++ < xL || rem[0] != null ) && s-- );
	
	                    more = rem[0] != null;
	
	                    // Leading zero?
	                    if ( !qc[0] ) qc.shift();
	                }
	
	                if ( base == BASE ) {
	
	                    // To calculate q.e, first get the number of digits of qc[0].
	                    for ( i = 1, s = qc[0]; s >= 10; s /= 10, i++ );
	                    round( q, dp + ( q.e = i + e * LOG_BASE - 1 ) + 1, rm, more );
	
	                // Caller is convertBase.
	                } else {
	                    q.e = e;
	                    q.r = +more;
	                }
	
	                return q;
	            };
	        })();
	
	
	        /*
	         * Return a string representing the value of BigNumber n in fixed-point or exponential
	         * notation rounded to the specified decimal places or significant digits.
	         *
	         * n is a BigNumber.
	         * i is the index of the last digit required (i.e. the digit that may be rounded up).
	         * rm is the rounding mode.
	         * caller is caller id: toExponential 19, toFixed 20, toFormat 21, toPrecision 24.
	         */
	        function format( n, i, rm, caller ) {
	            var c0, e, ne, len, str;
	
	            rm = rm != null && isValidInt( rm, 0, 8, caller, roundingMode )
	              ? rm | 0 : ROUNDING_MODE;
	
	            if ( !n.c ) return n.toString();
	            c0 = n.c[0];
	            ne = n.e;
	
	            if ( i == null ) {
	                str = coeffToString( n.c );
	                str = caller == 19 || caller == 24 && ne <= TO_EXP_NEG
	                  ? toExponential( str, ne )
	                  : toFixedPoint( str, ne );
	            } else {
	                n = round( new BigNumber(n), i, rm );
	
	                // n.e may have changed if the value was rounded up.
	                e = n.e;
	
	                str = coeffToString( n.c );
	                len = str.length;
	
	                // toPrecision returns exponential notation if the number of significant digits
	                // specified is less than the number of digits necessary to represent the integer
	                // part of the value in fixed-point notation.
	
	                // Exponential notation.
	                if ( caller == 19 || caller == 24 && ( i <= e || e <= TO_EXP_NEG ) ) {
	
	                    // Append zeros?
	                    for ( ; len < i; str += '0', len++ );
	                    str = toExponential( str, e );
	
	                // Fixed-point notation.
	                } else {
	                    i -= ne;
	                    str = toFixedPoint( str, e );
	
	                    // Append zeros?
	                    if ( e + 1 > len ) {
	                        if ( --i > 0 ) for ( str += '.'; i--; str += '0' );
	                    } else {
	                        i += e - len;
	                        if ( i > 0 ) {
	                            if ( e + 1 == len ) str += '.';
	                            for ( ; i--; str += '0' );
	                        }
	                    }
	                }
	            }
	
	            return n.s < 0 && c0 ? '-' + str : str;
	        }
	
	
	        // Handle BigNumber.max and BigNumber.min.
	        function maxOrMin( args, method ) {
	            var m, n,
	                i = 0;
	
	            if ( isArray( args[0] ) ) args = args[0];
	            m = new BigNumber( args[0] );
	
	            for ( ; ++i < args.length; ) {
	                n = new BigNumber( args[i] );
	
	                // If any number is NaN, return NaN.
	                if ( !n.s ) {
	                    m = n;
	                    break;
	                } else if ( method.call( m, n ) ) {
	                    m = n;
	                }
	            }
	
	            return m;
	        }
	
	
	        /*
	         * Return true if n is an integer in range, otherwise throw.
	         * Use for argument validation when ERRORS is true.
	         */
	        function intValidatorWithErrors( n, min, max, caller, name ) {
	            if ( n < min || n > max || n != truncate(n) ) {
	                raise( caller, ( name || 'decimal places' ) +
	                  ( n < min || n > max ? ' out of range' : ' not an integer' ), n );
	            }
	
	            return true;
	        }
	
	
	        /*
	         * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
	         * Called by minus, plus and times.
	         */
	        function normalise( n, c, e ) {
	            var i = 1,
	                j = c.length;
	
	             // Remove trailing zeros.
	            for ( ; !c[--j]; c.pop() );
	
	            // Calculate the base 10 exponent. First get the number of digits of c[0].
	            for ( j = c[0]; j >= 10; j /= 10, i++ );
	
	            // Overflow?
	            if ( ( e = i + e * LOG_BASE - 1 ) > MAX_EXP ) {
	
	                // Infinity.
	                n.c = n.e = null;
	
	            // Underflow?
	            } else if ( e < MIN_EXP ) {
	
	                // Zero.
	                n.c = [ n.e = 0 ];
	            } else {
	                n.e = e;
	                n.c = c;
	            }
	
	            return n;
	        }
	
	
	        // Handle values that fail the validity test in BigNumber.
	        parseNumeric = (function () {
	            var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
	                dotAfter = /^([^.]+)\.$/,
	                dotBefore = /^\.([^.]+)$/,
	                isInfinityOrNaN = /^-?(Infinity|NaN)$/,
	                whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
	
	            return function ( x, str, num, b ) {
	                var base,
	                    s = num ? str : str.replace( whitespaceOrPlus, '' );
	
	                // No exception on Infinity or NaN.
	                if ( isInfinityOrNaN.test(s) ) {
	                    x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
	                } else {
	                    if ( !num ) {
	
	                        // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
	                        s = s.replace( basePrefix, function ( m, p1, p2 ) {
	                            base = ( p2 = p2.toLowerCase() ) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
	                            return !b || b == base ? p1 : m;
	                        });
	
	                        if (b) {
	                            base = b;
	
	                            // E.g. '1.' to '1', '.1' to '0.1'
	                            s = s.replace( dotAfter, '$1' ).replace( dotBefore, '0.$1' );
	                        }
	
	                        if ( str != s ) return new BigNumber( s, base );
	                    }
	
	                    // 'new BigNumber() not a number: {n}'
	                    // 'new BigNumber() not a base {b} number: {n}'
	                    if (ERRORS) raise( id, 'not a' + ( b ? ' base ' + b : '' ) + ' number', str );
	                    x.s = null;
	                }
	
	                x.c = x.e = null;
	                id = 0;
	            }
	        })();
	
	
	        // Throw a BigNumber Error.
	        function raise( caller, msg, val ) {
	            var error = new Error( [
	                'new BigNumber',     // 0
	                'cmp',               // 1
	                'config',            // 2
	                'div',               // 3
	                'divToInt',          // 4
	                'eq',                // 5
	                'gt',                // 6
	                'gte',               // 7
	                'lt',                // 8
	                'lte',               // 9
	                'minus',             // 10
	                'mod',               // 11
	                'plus',              // 12
	                'precision',         // 13
	                'random',            // 14
	                'round',             // 15
	                'shift',             // 16
	                'times',             // 17
	                'toDigits',          // 18
	                'toExponential',     // 19
	                'toFixed',           // 20
	                'toFormat',          // 21
	                'toFraction',        // 22
	                'pow',               // 23
	                'toPrecision',       // 24
	                'toString',          // 25
	                'BigNumber'          // 26
	            ][caller] + '() ' + msg + ': ' + val );
	
	            error.name = 'BigNumber Error';
	            id = 0;
	            throw error;
	        }
	
	
	        /*
	         * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
	         * If r is truthy, it is known that there are more digits after the rounding digit.
	         */
	        function round( x, sd, rm, r ) {
	            var d, i, j, k, n, ni, rd,
	                xc = x.c,
	                pows10 = POWS_TEN;
	
	            // if x is not Infinity or NaN...
	            if (xc) {
	
	                // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
	                // n is a base 1e14 number, the value of the element of array x.c containing rd.
	                // ni is the index of n within x.c.
	                // d is the number of digits of n.
	                // i is the index of rd within n including leading zeros.
	                // j is the actual index of rd within n (if < 0, rd is a leading zero).
	                out: {
	
	                    // Get the number of digits of the first element of xc.
	                    for ( d = 1, k = xc[0]; k >= 10; k /= 10, d++ );
	                    i = sd - d;
	
	                    // If the rounding digit is in the first element of xc...
	                    if ( i < 0 ) {
	                        i += LOG_BASE;
	                        j = sd;
	                        n = xc[ ni = 0 ];
	
	                        // Get the rounding digit at index j of n.
	                        rd = n / pows10[ d - j - 1 ] % 10 | 0;
	                    } else {
	                        ni = mathceil( ( i + 1 ) / LOG_BASE );
	
	                        if ( ni >= xc.length ) {
	
	                            if (r) {
	
	                                // Needed by sqrt.
	                                for ( ; xc.length <= ni; xc.push(0) );
	                                n = rd = 0;
	                                d = 1;
	                                i %= LOG_BASE;
	                                j = i - LOG_BASE + 1;
	                            } else {
	                                break out;
	                            }
	                        } else {
	                            n = k = xc[ni];
	
	                            // Get the number of digits of n.
	                            for ( d = 1; k >= 10; k /= 10, d++ );
	
	                            // Get the index of rd within n.
	                            i %= LOG_BASE;
	
	                            // Get the index of rd within n, adjusted for leading zeros.
	                            // The number of leading zeros of n is given by LOG_BASE - d.
	                            j = i - LOG_BASE + d;
	
	                            // Get the rounding digit at index j of n.
	                            rd = j < 0 ? 0 : n / pows10[ d - j - 1 ] % 10 | 0;
	                        }
	                    }
	
	                    r = r || sd < 0 ||
	
	                    // Are there any non-zero digits after the rounding digit?
	                    // The expression  n % pows10[ d - j - 1 ]  returns all digits of n to the right
	                    // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
	                      xc[ni + 1] != null || ( j < 0 ? n : n % pows10[ d - j - 1 ] );
	
	                    r = rm < 4
	                      ? ( rd || r ) && ( rm == 0 || rm == ( x.s < 0 ? 3 : 2 ) )
	                      : rd > 5 || rd == 5 && ( rm == 4 || r || rm == 6 &&
	
	                        // Check whether the digit to the left of the rounding digit is odd.
	                        ( ( i > 0 ? j > 0 ? n / pows10[ d - j ] : 0 : xc[ni - 1] ) % 10 ) & 1 ||
	                          rm == ( x.s < 0 ? 8 : 7 ) );
	
	                    if ( sd < 1 || !xc[0] ) {
	                        xc.length = 0;
	
	                        if (r) {
	
	                            // Convert sd to decimal places.
	                            sd -= x.e + 1;
	
	                            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
	                            xc[0] = pows10[ sd % LOG_BASE ];
	                            x.e = -sd || 0;
	                        } else {
	
	                            // Zero.
	                            xc[0] = x.e = 0;
	                        }
	
	                        return x;
	                    }
	
	                    // Remove excess digits.
	                    if ( i == 0 ) {
	                        xc.length = ni;
	                        k = 1;
	                        ni--;
	                    } else {
	                        xc.length = ni + 1;
	                        k = pows10[ LOG_BASE - i ];
	
	                        // E.g. 56700 becomes 56000 if 7 is the rounding digit.
	                        // j > 0 means i > number of leading zeros of n.
	                        xc[ni] = j > 0 ? mathfloor( n / pows10[ d - j ] % pows10[j] ) * k : 0;
	                    }
	
	                    // Round up?
	                    if (r) {
	
	                        for ( ; ; ) {
	
	                            // If the digit to be rounded up is in the first element of xc...
	                            if ( ni == 0 ) {
	
	                                // i will be the length of xc[0] before k is added.
	                                for ( i = 1, j = xc[0]; j >= 10; j /= 10, i++ );
	                                j = xc[0] += k;
	                                for ( k = 1; j >= 10; j /= 10, k++ );
	
	                                // if i != k the length has increased.
	                                if ( i != k ) {
	                                    x.e++;
	                                    if ( xc[0] == BASE ) xc[0] = 1;
	                                }
	
	                                break;
	                            } else {
	                                xc[ni] += k;
	                                if ( xc[ni] != BASE ) break;
	                                xc[ni--] = 0;
	                                k = 1;
	                            }
	                        }
	                    }
	
	                    // Remove trailing zeros.
	                    for ( i = xc.length; xc[--i] === 0; xc.pop() );
	                }
	
	                // Overflow? Infinity.
	                if ( x.e > MAX_EXP ) {
	                    x.c = x.e = null;
	
	                // Underflow? Zero.
	                } else if ( x.e < MIN_EXP ) {
	                    x.c = [ x.e = 0 ];
	                }
	            }
	
	            return x;
	        }
	
	
	        // PROTOTYPE/INSTANCE METHODS
	
	
	        /*
	         * Return a new BigNumber whose value is the absolute value of this BigNumber.
	         */
	        P.absoluteValue = P.abs = function () {
	            var x = new BigNumber(this);
	            if ( x.s < 0 ) x.s = 1;
	            return x;
	        };
	
	
	        /*
	         * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
	         * number in the direction of Infinity.
	         */
	        P.ceil = function () {
	            return round( new BigNumber(this), this.e + 1, 2 );
	        };
	
	
	        /*
	         * Return
	         * 1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
	         * -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
	         * 0 if they have the same value,
	         * or null if the value of either is NaN.
	         */
	        P.comparedTo = P.cmp = function ( y, b ) {
	            id = 1;
	            return compare( this, new BigNumber( y, b ) );
	        };
	
	
	        /*
	         * Return the number of decimal places of the value of this BigNumber, or null if the value
	         * of this BigNumber is Infinity or NaN.
	         */
	        P.decimalPlaces = P.dp = function () {
	            var n, v,
	                c = this.c;
	
	            if ( !c ) return null;
	            n = ( ( v = c.length - 1 ) - bitFloor( this.e / LOG_BASE ) ) * LOG_BASE;
	
	            // Subtract the number of trailing zeros of the last number.
	            if ( v = c[v] ) for ( ; v % 10 == 0; v /= 10, n-- );
	            if ( n < 0 ) n = 0;
	
	            return n;
	        };
	
	
	        /*
	         *  n / 0 = I
	         *  n / N = N
	         *  n / I = 0
	         *  0 / n = 0
	         *  0 / 0 = N
	         *  0 / N = N
	         *  0 / I = 0
	         *  N / n = N
	         *  N / 0 = N
	         *  N / N = N
	         *  N / I = N
	         *  I / n = I
	         *  I / 0 = I
	         *  I / N = N
	         *  I / I = N
	         *
	         * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
	         * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
	         */
	        P.dividedBy = P.div = function ( y, b ) {
	            id = 3;
	            return div( this, new BigNumber( y, b ), DECIMAL_PLACES, ROUNDING_MODE );
	        };
	
	
	        /*
	         * Return a new BigNumber whose value is the integer part of dividing the value of this
	         * BigNumber by the value of BigNumber(y, b).
	         */
	        P.dividedToIntegerBy = P.divToInt = function ( y, b ) {
	            id = 4;
	            return div( this, new BigNumber( y, b ), 0, 1 );
	        };
	
	
	        /*
	         * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
	         * otherwise returns false.
	         */
	        P.equals = P.eq = function ( y, b ) {
	            id = 5;
	            return compare( this, new BigNumber( y, b ) ) === 0;
	        };
	
	
	        /*
	         * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
	         * number in the direction of -Infinity.
	         */
	        P.floor = function () {
	            return round( new BigNumber(this), this.e + 1, 3 );
	        };
	
	
	        /*
	         * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
	         * otherwise returns false.
	         */
	        P.greaterThan = P.gt = function ( y, b ) {
	            id = 6;
	            return compare( this, new BigNumber( y, b ) ) > 0;
	        };
	
	
	        /*
	         * Return true if the value of this BigNumber is greater than or equal to the value of
	         * BigNumber(y, b), otherwise returns false.
	         */
	        P.greaterThanOrEqualTo = P.gte = function ( y, b ) {
	            id = 7;
	            return ( b = compare( this, new BigNumber( y, b ) ) ) === 1 || b === 0;
	
	        };
	
	
	        /*
	         * Return true if the value of this BigNumber is a finite number, otherwise returns false.
	         */
	        P.isFinite = function () {
	            return !!this.c;
	        };
	
	
	        /*
	         * Return true if the value of this BigNumber is an integer, otherwise return false.
	         */
	        P.isInteger = P.isInt = function () {
	            return !!this.c && bitFloor( this.e / LOG_BASE ) > this.c.length - 2;
	        };
	
	
	        /*
	         * Return true if the value of this BigNumber is NaN, otherwise returns false.
	         */
	        P.isNaN = function () {
	            return !this.s;
	        };
	
	
	        /*
	         * Return true if the value of this BigNumber is negative, otherwise returns false.
	         */
	        P.isNegative = P.isNeg = function () {
	            return this.s < 0;
	        };
	
	
	        /*
	         * Return true if the value of this BigNumber is 0 or -0, otherwise returns false.
	         */
	        P.isZero = function () {
	            return !!this.c && this.c[0] == 0;
	        };
	
	
	        /*
	         * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
	         * otherwise returns false.
	         */
	        P.lessThan = P.lt = function ( y, b ) {
	            id = 8;
	            return compare( this, new BigNumber( y, b ) ) < 0;
	        };
	
	
	        /*
	         * Return true if the value of this BigNumber is less than or equal to the value of
	         * BigNumber(y, b), otherwise returns false.
	         */
	        P.lessThanOrEqualTo = P.lte = function ( y, b ) {
	            id = 9;
	            return ( b = compare( this, new BigNumber( y, b ) ) ) === -1 || b === 0;
	        };
	
	
	        /*
	         *  n - 0 = n
	         *  n - N = N
	         *  n - I = -I
	         *  0 - n = -n
	         *  0 - 0 = 0
	         *  0 - N = N
	         *  0 - I = -I
	         *  N - n = N
	         *  N - 0 = N
	         *  N - N = N
	         *  N - I = N
	         *  I - n = I
	         *  I - 0 = I
	         *  I - N = N
	         *  I - I = N
	         *
	         * Return a new BigNumber whose value is the value of this BigNumber minus the value of
	         * BigNumber(y, b).
	         */
	        P.minus = P.sub = function ( y, b ) {
	            var i, j, t, xLTy,
	                x = this,
	                a = x.s;
	
	            id = 10;
	            y = new BigNumber( y, b );
	            b = y.s;
	
	            // Either NaN?
	            if ( !a || !b ) return new BigNumber(NaN);
	
	            // Signs differ?
	            if ( a != b ) {
	                y.s = -b;
	                return x.plus(y);
	            }
	
	            var xe = x.e / LOG_BASE,
	                ye = y.e / LOG_BASE,
	                xc = x.c,
	                yc = y.c;
	
	            if ( !xe || !ye ) {
	
	                // Either Infinity?
	                if ( !xc || !yc ) return xc ? ( y.s = -b, y ) : new BigNumber( yc ? x : NaN );
	
	                // Either zero?
	                if ( !xc[0] || !yc[0] ) {
	
	                    // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
	                    return yc[0] ? ( y.s = -b, y ) : new BigNumber( xc[0] ? x :
	
	                      // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
	                      ROUNDING_MODE == 3 ? -0 : 0 );
	                }
	            }
	
	            xe = bitFloor(xe);
	            ye = bitFloor(ye);
	            xc = xc.slice();
	
	            // Determine which is the bigger number.
	            if ( a = xe - ye ) {
	
	                if ( xLTy = a < 0 ) {
	                    a = -a;
	                    t = xc;
	                } else {
	                    ye = xe;
	                    t = yc;
	                }
	
	                t.reverse();
	
	                // Prepend zeros to equalise exponents.
	                for ( b = a; b--; t.push(0) );
	                t.reverse();
	            } else {
	
	                // Exponents equal. Check digit by digit.
	                j = ( xLTy = ( a = xc.length ) < ( b = yc.length ) ) ? a : b;
	
	                for ( a = b = 0; b < j; b++ ) {
	
	                    if ( xc[b] != yc[b] ) {
	                        xLTy = xc[b] < yc[b];
	                        break;
	                    }
	                }
	            }
	
	            // x < y? Point xc to the array of the bigger number.
	            if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;
	
	            b = ( j = yc.length ) - ( i = xc.length );
	
	            // Append zeros to xc if shorter.
	            // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
	            if ( b > 0 ) for ( ; b--; xc[i++] = 0 );
	            b = BASE - 1;
	
	            // Subtract yc from xc.
	            for ( ; j > a; ) {
	
	                if ( xc[--j] < yc[j] ) {
	                    for ( i = j; i && !xc[--i]; xc[i] = b );
	                    --xc[i];
	                    xc[j] += BASE;
	                }
	
	                xc[j] -= yc[j];
	            }
	
	            // Remove leading zeros and adjust exponent accordingly.
	            for ( ; xc[0] == 0; xc.shift(), --ye );
	
	            // Zero?
	            if ( !xc[0] ) {
	
	                // Following IEEE 754 (2008) 6.3,
	                // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
	                y.s = ROUNDING_MODE == 3 ? -1 : 1;
	                y.c = [ y.e = 0 ];
	                return y;
	            }
	
	            // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
	            // for finite x and y.
	            return normalise( y, xc, ye );
	        };
	
	
	        /*
	         *   n % 0 =  N
	         *   n % N =  N
	         *   n % I =  n
	         *   0 % n =  0
	         *  -0 % n = -0
	         *   0 % 0 =  N
	         *   0 % N =  N
	         *   0 % I =  0
	         *   N % n =  N
	         *   N % 0 =  N
	         *   N % N =  N
	         *   N % I =  N
	         *   I % n =  N
	         *   I % 0 =  N
	         *   I % N =  N
	         *   I % I =  N
	         *
	         * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
	         * BigNumber(y, b). The result depends on the value of MODULO_MODE.
	         */
	        P.modulo = P.mod = function ( y, b ) {
	            var q, s,
	                x = this;
	
	            id = 11;
	            y = new BigNumber( y, b );
	
	            // Return NaN if x is Infinity or NaN, or y is NaN or zero.
	            if ( !x.c || !y.s || y.c && !y.c[0] ) {
	                return new BigNumber(NaN);
	
	            // Return x if y is Infinity or x is zero.
	            } else if ( !y.c || x.c && !x.c[0] ) {
	                return new BigNumber(x);
	            }
	
	            if ( MODULO_MODE == 9 ) {
	
	                // Euclidian division: q = sign(y) * floor(x / abs(y))
	                // r = x - qy    where  0 <= r < abs(y)
	                s = y.s;
	                y.s = 1;
	                q = div( x, y, 0, 3 );
	                y.s = s;
	                q.s *= s;
	            } else {
	                q = div( x, y, 0, MODULO_MODE );
	            }
	
	            return x.minus( q.times(y) );
	        };
	
	
	        /*
	         * Return a new BigNumber whose value is the value of this BigNumber negated,
	         * i.e. multiplied by -1.
	         */
	        P.negated = P.neg = function () {
	            var x = new BigNumber(this);
	            x.s = -x.s || null;
	            return x;
	        };
	
	
	        /*
	         *  n + 0 = n
	         *  n + N = N
	         *  n + I = I
	         *  0 + n = n
	         *  0 + 0 = 0
	         *  0 + N = N
	         *  0 + I = I
	         *  N + n = N
	         *  N + 0 = N
	         *  N + N = N
	         *  N + I = N
	         *  I + n = I
	         *  I + 0 = I
	         *  I + N = N
	         *  I + I = I
	         *
	         * Return a new BigNumber whose value is the value of this BigNumber plus the value of
	         * BigNumber(y, b).
	         */
	        P.plus = P.add = function ( y, b ) {
	            var t,
	                x = this,
	                a = x.s;
	
	            id = 12;
	            y = new BigNumber( y, b );
	            b = y.s;
	
	            // Either NaN?
	            if ( !a || !b ) return new BigNumber(NaN);
	
	            // Signs differ?
	             if ( a != b ) {
	                y.s = -b;
	                return x.minus(y);
	            }
	
	            var xe = x.e / LOG_BASE,
	                ye = y.e / LOG_BASE,
	                xc = x.c,
	                yc = y.c;
	
	            if ( !xe || !ye ) {
	
	                // Return Infinity if either Infinity.
	                if ( !xc || !yc ) return new BigNumber( a / 0 );
	
	                // Either zero?
	                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
	                if ( !xc[0] || !yc[0] ) return yc[0] ? y : new BigNumber( xc[0] ? x : a * 0 );
	            }
	
	            xe = bitFloor(xe);
	            ye = bitFloor(ye);
	            xc = xc.slice();
	
	            // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
	            if ( a = xe - ye ) {
	                if ( a > 0 ) {
	                    ye = xe;
	                    t = yc;
	                } else {
	                    a = -a;
	                    t = xc;
	                }
	
	                t.reverse();
	                for ( ; a--; t.push(0) );
	                t.reverse();
	            }
	
	            a = xc.length;
	            b = yc.length;
	
	            // Point xc to the longer array, and b to the shorter length.
	            if ( a - b < 0 ) t = yc, yc = xc, xc = t, b = a;
	
	            // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
	            for ( a = 0; b; ) {
	                a = ( xc[--b] = xc[b] + yc[b] + a ) / BASE | 0;
	                xc[b] %= BASE;
	            }
	
	            if (a) {
	                xc.unshift(a);
	                ++ye;
	            }
	
	            // No need to check for zero, as +x + +y != 0 && -x + -y != 0
	            // ye = MAX_EXP + 1 possible
	            return normalise( y, xc, ye );
	        };
	
	
	        /*
	         * Return the number of significant digits of the value of this BigNumber.
	         *
	         * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
	         */
	        P.precision = P.sd = function (z) {
	            var n, v,
	                x = this,
	                c = x.c;
	
	            // 'precision() argument not a boolean or binary digit: {z}'
	            if ( z != null && z !== !!z && z !== 1 && z !== 0 ) {
	                if (ERRORS) raise( 13, 'argument' + notBool, z );
	                if ( z != !!z ) z = null;
	            }
	
	            if ( !c ) return null;
	            v = c.length - 1;
	            n = v * LOG_BASE + 1;
	
	            if ( v = c[v] ) {
	
	                // Subtract the number of trailing zeros of the last element.
	                for ( ; v % 10 == 0; v /= 10, n-- );
	
	                // Add the number of digits of the first element.
	                for ( v = c[0]; v >= 10; v /= 10, n++ );
	            }
	
	            if ( z && x.e + 1 > n ) n = x.e + 1;
	
	            return n;
	        };
	
	
	        /*
	         * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
	         * dp decimal places using rounding mode rm, or to 0 and ROUNDING_MODE respectively if
	         * omitted.
	         *
	         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
	         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	         *
	         * 'round() decimal places out of range: {dp}'
	         * 'round() decimal places not an integer: {dp}'
	         * 'round() rounding mode not an integer: {rm}'
	         * 'round() rounding mode out of range: {rm}'
	         */
	        P.round = function ( dp, rm ) {
	            var n = new BigNumber(this);
	
	            if ( dp == null || isValidInt( dp, 0, MAX, 15 ) ) {
	                round( n, ~~dp + this.e + 1, rm == null ||
	                  !isValidInt( rm, 0, 8, 15, roundingMode ) ? ROUNDING_MODE : rm | 0 );
	            }
	
	            return n;
	        };
	
	
	        /*
	         * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
	         * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
	         *
	         * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
	         *
	         * If k is out of range and ERRORS is false, the result will be 0 if k < 0, or Infinity
	         * otherwise.
	         *
	         * 'shift() argument not an integer: {k}'
	         * 'shift() argument out of range: {k}'
	         */
	        P.shift = function (k) {
	            var n = this;
	            return isValidInt( k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 16, 'argument' )
	
	              // k < 1e+21, or truncate(k) will produce exponential notation.
	              ? n.times( '1e' + truncate(k) )
	              : new BigNumber( n.c && n.c[0] && ( k < -MAX_SAFE_INTEGER || k > MAX_SAFE_INTEGER )
	                ? n.s * ( k < 0 ? 0 : 1 / 0 )
	                : n );
	        };
	
	
	        /*
	         *  sqrt(-n) =  N
	         *  sqrt( N) =  N
	         *  sqrt(-I) =  N
	         *  sqrt( I) =  I
	         *  sqrt( 0) =  0
	         *  sqrt(-0) = -0
	         *
	         * Return a new BigNumber whose value is the square root of the value of this BigNumber,
	         * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
	         */
	        P.squareRoot = P.sqrt = function () {
	            var m, n, r, rep, t,
	                x = this,
	                c = x.c,
	                s = x.s,
	                e = x.e,
	                dp = DECIMAL_PLACES + 4,
	                half = new BigNumber('0.5');
	
	            // Negative/NaN/Infinity/zero?
	            if ( s !== 1 || !c || !c[0] ) {
	                return new BigNumber( !s || s < 0 && ( !c || c[0] ) ? NaN : c ? x : 1 / 0 );
	            }
	
	            // Initial estimate.
	            s = Math.sqrt( +x );
	
	            // Math.sqrt underflow/overflow?
	            // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
	            if ( s == 0 || s == 1 / 0 ) {
	                n = coeffToString(c);
	                if ( ( n.length + e ) % 2 == 0 ) n += '0';
	                s = Math.sqrt(n);
	                e = bitFloor( ( e + 1 ) / 2 ) - ( e < 0 || e % 2 );
	
	                if ( s == 1 / 0 ) {
	                    n = '1e' + e;
	                } else {
	                    n = s.toExponential();
	                    n = n.slice( 0, n.indexOf('e') + 1 ) + e;
	                }
	
	                r = new BigNumber(n);
	            } else {
	                r = new BigNumber( s + '' );
	            }
	
	            // Check for zero.
	            // r could be zero if MIN_EXP is changed after the this value was created.
	            // This would cause a division by zero (x/t) and hence Infinity below, which would cause
	            // coeffToString to throw.
	            if ( r.c[0] ) {
	                e = r.e;
	                s = e + dp;
	                if ( s < 3 ) s = 0;
	
	                // Newton-Raphson iteration.
	                for ( ; ; ) {
	                    t = r;
	                    r = half.times( t.plus( div( x, t, dp, 1 ) ) );
	
	                    if ( coeffToString( t.c   ).slice( 0, s ) === ( n =
	                         coeffToString( r.c ) ).slice( 0, s ) ) {
	
	                        // The exponent of r may here be one less than the final result exponent,
	                        // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
	                        // are indexed correctly.
	                        if ( r.e < e ) --s;
	                        n = n.slice( s - 3, s + 1 );
	
	                        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
	                        // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
	                        // iteration.
	                        if ( n == '9999' || !rep && n == '4999' ) {
	
	                            // On the first iteration only, check to see if rounding up gives the
	                            // exact result as the nines may infinitely repeat.
	                            if ( !rep ) {
	                                round( t, t.e + DECIMAL_PLACES + 2, 0 );
	
	                                if ( t.times(t).eq(x) ) {
	                                    r = t;
	                                    break;
	                                }
	                            }
	
	                            dp += 4;
	                            s += 4;
	                            rep = 1;
	                        } else {
	
	                            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
	                            // result. If not, then there are further digits and m will be truthy.
	                            if ( !+n || !+n.slice(1) && n.charAt(0) == '5' ) {
	
	                                // Truncate to the first rounding digit.
	                                round( r, r.e + DECIMAL_PLACES + 2, 1 );
	                                m = !r.times(r).eq(x);
	                            }
	
	                            break;
	                        }
	                    }
	                }
	            }
	
	            return round( r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m );
	        };
	
	
	        /*
	         *  n * 0 = 0
	         *  n * N = N
	         *  n * I = I
	         *  0 * n = 0
	         *  0 * 0 = 0
	         *  0 * N = N
	         *  0 * I = N
	         *  N * n = N
	         *  N * 0 = N
	         *  N * N = N
	         *  N * I = N
	         *  I * n = I
	         *  I * 0 = N
	         *  I * N = N
	         *  I * I = I
	         *
	         * Return a new BigNumber whose value is the value of this BigNumber times the value of
	         * BigNumber(y, b).
	         */
	        P.times = P.mul = function ( y, b ) {
	            var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
	                base, sqrtBase,
	                x = this,
	                xc = x.c,
	                yc = ( id = 17, y = new BigNumber( y, b ) ).c;
	
	            // Either NaN, Infinity or 0?
	            if ( !xc || !yc || !xc[0] || !yc[0] ) {
	
	                // Return NaN if either is NaN, or one is 0 and the other is Infinity.
	                if ( !x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc ) {
	                    y.c = y.e = y.s = null;
	                } else {
	                    y.s *= x.s;
	
	                    // Return Infinity if either is Infinity.
	                    if ( !xc || !yc ) {
	                        y.c = y.e = null;
	
	                    // Return 0 if either is 0.
	                    } else {
	                        y.c = [0];
	                        y.e = 0;
	                    }
	                }
	
	                return y;
	            }
	
	            e = bitFloor( x.e / LOG_BASE ) + bitFloor( y.e / LOG_BASE );
	            y.s *= x.s;
	            xcL = xc.length;
	            ycL = yc.length;
	
	            // Ensure xc points to longer array and xcL to its length.
	            if ( xcL < ycL ) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;
	
	            // Initialise the result array with zeros.
	            for ( i = xcL + ycL, zc = []; i--; zc.push(0) );
	
	            base = BASE;
	            sqrtBase = SQRT_BASE;
	
	            for ( i = ycL; --i >= 0; ) {
	                c = 0;
	                ylo = yc[i] % sqrtBase;
	                yhi = yc[i] / sqrtBase | 0;
	
	                for ( k = xcL, j = i + k; j > i; ) {
	                    xlo = xc[--k] % sqrtBase;
	                    xhi = xc[k] / sqrtBase | 0;
	                    m = yhi * xlo + xhi * ylo;
	                    xlo = ylo * xlo + ( ( m % sqrtBase ) * sqrtBase ) + zc[j] + c;
	                    c = ( xlo / base | 0 ) + ( m / sqrtBase | 0 ) + yhi * xhi;
	                    zc[j--] = xlo % base;
	                }
	
	                zc[j] = c;
	            }
	
	            if (c) {
	                ++e;
	            } else {
	                zc.shift();
	            }
	
	            return normalise( y, zc, e );
	        };
	
	
	        /*
	         * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
	         * sd significant digits using rounding mode rm, or ROUNDING_MODE if rm is omitted.
	         *
	         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
	         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	         *
	         * 'toDigits() precision out of range: {sd}'
	         * 'toDigits() precision not an integer: {sd}'
	         * 'toDigits() rounding mode not an integer: {rm}'
	         * 'toDigits() rounding mode out of range: {rm}'
	         */
	        P.toDigits = function ( sd, rm ) {
	            var n = new BigNumber(this);
	            sd = sd == null || !isValidInt( sd, 1, MAX, 18, 'precision' ) ? null : sd | 0;
	            rm = rm == null || !isValidInt( rm, 0, 8, 18, roundingMode ) ? ROUNDING_MODE : rm | 0;
	            return sd ? round( n, sd, rm ) : n;
	        };
	
	
	        /*
	         * Return a string representing the value of this BigNumber in exponential notation and
	         * rounded using ROUNDING_MODE to dp fixed decimal places.
	         *
	         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
	         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	         *
	         * 'toExponential() decimal places not an integer: {dp}'
	         * 'toExponential() decimal places out of range: {dp}'
	         * 'toExponential() rounding mode not an integer: {rm}'
	         * 'toExponential() rounding mode out of range: {rm}'
	         */
	        P.toExponential = function ( dp, rm ) {
	            return format( this,
	              dp != null && isValidInt( dp, 0, MAX, 19 ) ? ~~dp + 1 : null, rm, 19 );
	        };
	
	
	        /*
	         * Return a string representing the value of this BigNumber in fixed-point notation rounding
	         * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
	         *
	         * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
	         * but e.g. (-0.00001).toFixed(0) is '-0'.
	         *
	         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
	         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	         *
	         * 'toFixed() decimal places not an integer: {dp}'
	         * 'toFixed() decimal places out of range: {dp}'
	         * 'toFixed() rounding mode not an integer: {rm}'
	         * 'toFixed() rounding mode out of range: {rm}'
	         */
	        P.toFixed = function ( dp, rm ) {
	            return format( this, dp != null && isValidInt( dp, 0, MAX, 20 )
	              ? ~~dp + this.e + 1 : null, rm, 20 );
	        };
	
	
	        /*
	         * Return a string representing the value of this BigNumber in fixed-point notation rounded
	         * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
	         * of the FORMAT object (see BigNumber.config).
	         *
	         * FORMAT = {
	         *      decimalSeparator : '.',
	         *      groupSeparator : ',',
	         *      groupSize : 3,
	         *      secondaryGroupSize : 0,
	         *      fractionGroupSeparator : '\xA0',    // non-breaking space
	         *      fractionGroupSize : 0
	         * };
	         *
	         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
	         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	         *
	         * 'toFormat() decimal places not an integer: {dp}'
	         * 'toFormat() decimal places out of range: {dp}'
	         * 'toFormat() rounding mode not an integer: {rm}'
	         * 'toFormat() rounding mode out of range: {rm}'
	         */
	        P.toFormat = function ( dp, rm ) {
	            var str = format( this, dp != null && isValidInt( dp, 0, MAX, 21 )
	              ? ~~dp + this.e + 1 : null, rm, 21 );
	
	            if ( this.c ) {
	                var i,
	                    arr = str.split('.'),
	                    g1 = +FORMAT.groupSize,
	                    g2 = +FORMAT.secondaryGroupSize,
	                    groupSeparator = FORMAT.groupSeparator,
	                    intPart = arr[0],
	                    fractionPart = arr[1],
	                    isNeg = this.s < 0,
	                    intDigits = isNeg ? intPart.slice(1) : intPart,
	                    len = intDigits.length;
	
	                if (g2) i = g1, g1 = g2, g2 = i, len -= i;
	
	                if ( g1 > 0 && len > 0 ) {
	                    i = len % g1 || g1;
	                    intPart = intDigits.substr( 0, i );
	
	                    for ( ; i < len; i += g1 ) {
	                        intPart += groupSeparator + intDigits.substr( i, g1 );
	                    }
	
	                    if ( g2 > 0 ) intPart += groupSeparator + intDigits.slice(i);
	                    if (isNeg) intPart = '-' + intPart;
	                }
	
	                str = fractionPart
	                  ? intPart + FORMAT.decimalSeparator + ( ( g2 = +FORMAT.fractionGroupSize )
	                    ? fractionPart.replace( new RegExp( '\\d{' + g2 + '}\\B', 'g' ),
	                      '$&' + FORMAT.fractionGroupSeparator )
	                    : fractionPart )
	                  : intPart;
	            }
	
	            return str;
	        };
	
	
	        /*
	         * Return a string array representing the value of this BigNumber as a simple fraction with
	         * an integer numerator and an integer denominator. The denominator will be a positive
	         * non-zero value less than or equal to the specified maximum denominator. If a maximum
	         * denominator is not specified, the denominator will be the lowest value necessary to
	         * represent the number exactly.
	         *
	         * [md] {number|string|BigNumber} Integer >= 1 and < Infinity. The maximum denominator.
	         *
	         * 'toFraction() max denominator not an integer: {md}'
	         * 'toFraction() max denominator out of range: {md}'
	         */
	        P.toFraction = function (md) {
	            var arr, d0, d2, e, exp, n, n0, q, s,
	                k = ERRORS,
	                x = this,
	                xc = x.c,
	                d = new BigNumber(ONE),
	                n1 = d0 = new BigNumber(ONE),
	                d1 = n0 = new BigNumber(ONE);
	
	            if ( md != null ) {
	                ERRORS = false;
	                n = new BigNumber(md);
	                ERRORS = k;
	
	                if ( !( k = n.isInt() ) || n.lt(ONE) ) {
	
	                    if (ERRORS) {
	                        raise( 22,
	                          'max denominator ' + ( k ? 'out of range' : 'not an integer' ), md );
	                    }
	
	                    // ERRORS is false:
	                    // If md is a finite non-integer >= 1, round it to an integer and use it.
	                    md = !k && n.c && round( n, n.e + 1, 1 ).gte(ONE) ? n : null;
	                }
	            }
	
	            if ( !xc ) return x.toString();
	            s = coeffToString(xc);
	
	            // Determine initial denominator.
	            // d is a power of 10 and the minimum max denominator that specifies the value exactly.
	            e = d.e = s.length - x.e - 1;
	            d.c[0] = POWS_TEN[ ( exp = e % LOG_BASE ) < 0 ? LOG_BASE + exp : exp ];
	            md = !md || n.cmp(d) > 0 ? ( e > 0 ? d : n1 ) : n;
	
	            exp = MAX_EXP;
	            MAX_EXP = 1 / 0;
	            n = new BigNumber(s);
	
	            // n0 = d1 = 0
	            n0.c[0] = 0;
	
	            for ( ; ; )  {
	                q = div( n, d, 0, 1 );
	                d2 = d0.plus( q.times(d1) );
	                if ( d2.cmp(md) == 1 ) break;
	                d0 = d1;
	                d1 = d2;
	                n1 = n0.plus( q.times( d2 = n1 ) );
	                n0 = d2;
	                d = n.minus( q.times( d2 = d ) );
	                n = d2;
	            }
	
	            d2 = div( md.minus(d0), d1, 0, 1 );
	            n0 = n0.plus( d2.times(n1) );
	            d0 = d0.plus( d2.times(d1) );
	            n0.s = n1.s = x.s;
	            e *= 2;
	
	            // Determine which fraction is closer to x, n0/d0 or n1/d1
	            arr = div( n1, d1, e, ROUNDING_MODE ).minus(x).abs().cmp(
	                  div( n0, d0, e, ROUNDING_MODE ).minus(x).abs() ) < 1
	                    ? [ n1.toString(), d1.toString() ]
	                    : [ n0.toString(), d0.toString() ];
	
	            MAX_EXP = exp;
	            return arr;
	        };
	
	
	        /*
	         * Return the value of this BigNumber converted to a number primitive.
	         */
	        P.toNumber = function () {
	            var x = this;
	
	            // Ensure zero has correct sign.
	            return +x || ( x.s ? x.s * 0 : NaN );
	        };
	
	
	        /*
	         * Return a BigNumber whose value is the value of this BigNumber raised to the power n.
	         * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
	         * If POW_PRECISION is not 0, round to POW_PRECISION using ROUNDING_MODE.
	         *
	         * n {number} Integer, -9007199254740992 to 9007199254740992 inclusive.
	         * (Performs 54 loop iterations for n of 9007199254740992.)
	         *
	         * 'pow() exponent not an integer: {n}'
	         * 'pow() exponent out of range: {n}'
	         */
	        P.toPower = P.pow = function (n) {
	            var k, y,
	                i = mathfloor( n < 0 ? -n : +n ),
	                x = this;
	
	            // Pass Infinity to Math.pow if exponent is out of range.
	            if ( !isValidInt( n, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 23, 'exponent' ) &&
	              ( !isFinite(n) || i > MAX_SAFE_INTEGER && ( n /= 0 ) ||
	                parseFloat(n) != n && !( n = NaN ) ) ) {
	                return new BigNumber( Math.pow( +x, n ) );
	            }
	
	            // Truncating each coefficient array to a length of k after each multiplication equates
	            // to truncating significant digits to POW_PRECISION + [28, 41], i.e. there will be a
	            // minimum of 28 guard digits retained. (Using + 1.5 would give [9, 21] guard digits.)
	            k = POW_PRECISION ? mathceil( POW_PRECISION / LOG_BASE + 2 ) : 0;
	            y = new BigNumber(ONE);
	
	            for ( ; ; ) {
	
	                if ( i % 2 ) {
	                    y = y.times(x);
	                    if ( !y.c ) break;
	                    if ( k && y.c.length > k ) y.c.length = k;
	                }
	
	                i = mathfloor( i / 2 );
	                if ( !i ) break;
	
	                x = x.times(x);
	                if ( k && x.c && x.c.length > k ) x.c.length = k;
	            }
	
	            if ( n < 0 ) y = ONE.div(y);
	            return k ? round( y, POW_PRECISION, ROUNDING_MODE ) : y;
	        };
	
	
	        /*
	         * Return a string representing the value of this BigNumber rounded to sd significant digits
	         * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
	         * necessary to represent the integer part of the value in fixed-point notation, then use
	         * exponential notation.
	         *
	         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
	         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	         *
	         * 'toPrecision() precision not an integer: {sd}'
	         * 'toPrecision() precision out of range: {sd}'
	         * 'toPrecision() rounding mode not an integer: {rm}'
	         * 'toPrecision() rounding mode out of range: {rm}'
	         */
	        P.toPrecision = function ( sd, rm ) {
	            return format( this, sd != null && isValidInt( sd, 1, MAX, 24, 'precision' )
	              ? sd | 0 : null, rm, 24 );
	        };
	
	
	        /*
	         * Return a string representing the value of this BigNumber in base b, or base 10 if b is
	         * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
	         * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
	         * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
	         * TO_EXP_NEG, return exponential notation.
	         *
	         * [b] {number} Integer, 2 to 64 inclusive.
	         *
	         * 'toString() base not an integer: {b}'
	         * 'toString() base out of range: {b}'
	         */
	        P.toString = function (b) {
	            var str,
	                n = this,
	                s = n.s,
	                e = n.e;
	
	            // Infinity or NaN?
	            if ( e === null ) {
	
	                if (s) {
	                    str = 'Infinity';
	                    if ( s < 0 ) str = '-' + str;
	                } else {
	                    str = 'NaN';
	                }
	            } else {
	                str = coeffToString( n.c );
	
	                if ( b == null || !isValidInt( b, 2, 64, 25, 'base' ) ) {
	                    str = e <= TO_EXP_NEG || e >= TO_EXP_POS
	                      ? toExponential( str, e )
	                      : toFixedPoint( str, e );
	                } else {
	                    str = convertBase( toFixedPoint( str, e ), b | 0, 10, s );
	                }
	
	                if ( s < 0 && n.c[0] ) str = '-' + str;
	            }
	
	            return str;
	        };
	
	
	        /*
	         * Return a new BigNumber whose value is the value of this BigNumber truncated to a whole
	         * number.
	         */
	        P.truncated = P.trunc = function () {
	            return round( new BigNumber(this), this.e + 1, 1 );
	        };
	
	
	
	        /*
	         * Return as toString, but do not accept a base argument.
	         */
	        P.valueOf = P.toJSON = function () {
	            return this.toString();
	        };
	
	
	        // Aliases for BigDecimal methods.
	        //P.add = P.plus;         // P.add included above
	        //P.subtract = P.minus;   // P.sub included above
	        //P.multiply = P.times;   // P.mul included above
	        //P.divide = P.div;
	        //P.remainder = P.mod;
	        //P.compareTo = P.cmp;
	        //P.negate = P.neg;
	
	
	        if ( configObj != null ) BigNumber.config(configObj);
	
	        return BigNumber;
	    }
	
	
	    // PRIVATE HELPER FUNCTIONS
	
	
	    function bitFloor(n) {
	        var i = n | 0;
	        return n > 0 || n === i ? i : i - 1;
	    }
	
	
	    // Return a coefficient array as a string of base 10 digits.
	    function coeffToString(a) {
	        var s, z,
	            i = 1,
	            j = a.length,
	            r = a[0] + '';
	
	        for ( ; i < j; ) {
	            s = a[i++] + '';
	            z = LOG_BASE - s.length;
	            for ( ; z--; s = '0' + s );
	            r += s;
	        }
	
	        // Determine trailing zeros.
	        for ( j = r.length; r.charCodeAt(--j) === 48; );
	        return r.slice( 0, j + 1 || 1 );
	    }
	
	
	    // Compare the value of BigNumbers x and y.
	    function compare( x, y ) {
	        var a, b,
	            xc = x.c,
	            yc = y.c,
	            i = x.s,
	            j = y.s,
	            k = x.e,
	            l = y.e;
	
	        // Either NaN?
	        if ( !i || !j ) return null;
	
	        a = xc && !xc[0];
	        b = yc && !yc[0];
	
	        // Either zero?
	        if ( a || b ) return a ? b ? 0 : -j : i;
	
	        // Signs differ?
	        if ( i != j ) return i;
	
	        a = i < 0;
	        b = k == l;
	
	        // Either Infinity?
	        if ( !xc || !yc ) return b ? 0 : !xc ^ a ? 1 : -1;
	
	        // Compare exponents.
	        if ( !b ) return k > l ^ a ? 1 : -1;
	
	        j = ( k = xc.length ) < ( l = yc.length ) ? k : l;
	
	        // Compare digit by digit.
	        for ( i = 0; i < j; i++ ) if ( xc[i] != yc[i] ) return xc[i] > yc[i] ^ a ? 1 : -1;
	
	        // Compare lengths.
	        return k == l ? 0 : k > l ^ a ? 1 : -1;
	    }
	
	
	    /*
	     * Return true if n is a valid number in range, otherwise false.
	     * Use for argument validation when ERRORS is false.
	     * Note: parseInt('1e+1') == 1 but parseFloat('1e+1') == 10.
	     */
	    function intValidatorNoErrors( n, min, max ) {
	        return ( n = truncate(n) ) >= min && n <= max;
	    }
	
	
	    function isArray(obj) {
	        return Object.prototype.toString.call(obj) == '[object Array]';
	    }
	
	
	    /*
	     * Convert string of baseIn to an array of numbers of baseOut.
	     * Eg. convertBase('255', 10, 16) returns [15, 15].
	     * Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
	     */
	    function toBaseOut( str, baseIn, baseOut ) {
	        var j,
	            arr = [0],
	            arrL,
	            i = 0,
	            len = str.length;
	
	        for ( ; i < len; ) {
	            for ( arrL = arr.length; arrL--; arr[arrL] *= baseIn );
	            arr[ j = 0 ] += ALPHABET.indexOf( str.charAt( i++ ) );
	
	            for ( ; j < arr.length; j++ ) {
	
	                if ( arr[j] > baseOut - 1 ) {
	                    if ( arr[j + 1] == null ) arr[j + 1] = 0;
	                    arr[j + 1] += arr[j] / baseOut | 0;
	                    arr[j] %= baseOut;
	                }
	            }
	        }
	
	        return arr.reverse();
	    }
	
	
	    function toExponential( str, e ) {
	        return ( str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str ) +
	          ( e < 0 ? 'e' : 'e+' ) + e;
	    }
	
	
	    function toFixedPoint( str, e ) {
	        var len, z;
	
	        // Negative exponent?
	        if ( e < 0 ) {
	
	            // Prepend zeros.
	            for ( z = '0.'; ++e; z += '0' );
	            str = z + str;
	
	        // Positive exponent
	        } else {
	            len = str.length;
	
	            // Append zeros.
	            if ( ++e > len ) {
	                for ( z = '0', e -= len; --e; z += '0' );
	                str += z;
	            } else if ( e < len ) {
	                str = str.slice( 0, e ) + '.' + str.slice(e);
	            }
	        }
	
	        return str;
	    }
	
	
	    function truncate(n) {
	        n = parseFloat(n);
	        return n < 0 ? mathceil(n) : mathfloor(n);
	    }
	
	
	    // EXPORT
	
	
	    BigNumber = another();
	
	    // AMD.
	    if ( true ) {
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () { return BigNumber; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	    // Node and other environments that support module.exports.
	    } else if ( typeof module != 'undefined' && module.exports ) {
	        module.exports = BigNumber;
	        if ( !crypto ) try { crypto = require('crypto'); } catch (e) {}
	
	    // Browser.
	    } else {
	        global.BigNumber = BigNumber;
	    }
	})(this);


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	exports.ChangeUser = __webpack_require__(31);
	exports.Handshake = __webpack_require__(60);
	exports.Ping = __webpack_require__(61);
	exports.Query = __webpack_require__(62);
	exports.Quit = __webpack_require__(77);
	exports.Sequence = __webpack_require__(32);
	exports.Statistics = __webpack_require__(78);


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var Sequence = __webpack_require__(32);
	var Util     = __webpack_require__(33);
	var Packets  = __webpack_require__(35);
	var Auth     = __webpack_require__(58);
	
	module.exports = ChangeUser;
	Util.inherits(ChangeUser, Sequence);
	function ChangeUser(options, callback) {
	  Sequence.call(this, options, callback);
	
	  this._user          = options.user;
	  this._password      = options.password;
	  this._database      = options.database;
	  this._charsetNumber = options.charsetNumber;
	  this._currentConfig = options.currentConfig;
	}
	
	ChangeUser.prototype.start = function(handshakeInitializationPacket) {
	  var scrambleBuff = handshakeInitializationPacket.scrambleBuff();
	  scrambleBuff     = Auth.token(this._password, scrambleBuff);
	
	  var packet = new Packets.ComChangeUserPacket({
	    user          : this._user,
	    scrambleBuff  : scrambleBuff,
	    database      : this._database,
	    charsetNumber : this._charsetNumber,
	  });
	
	  this._currentConfig.user          = this._user;
	  this._currentConfig.password      = this._password;
	  this._currentConfig.database      = this._database;
	  this._currentConfig.charsetNumber = this._charsetNumber;
	
	  this.emit('packet', packet);
	};
	
	ChangeUser.prototype['ErrorPacket'] = function(packet) {
	  var err = this._packetToError(packet);
	  err.fatal = true;
	  this.end(err);
	};


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var Util           = __webpack_require__(33);
	var EventEmitter   = __webpack_require__(34).EventEmitter;
	var Packets        = __webpack_require__(35);
	var ErrorConstants = __webpack_require__(57);
	
	var listenerCount = EventEmitter.listenerCount
	  || function(emitter, type){ return emitter.listeners(type).length; };
	
	module.exports = Sequence;
	Util.inherits(Sequence, EventEmitter);
	function Sequence(options, callback) {
	  if (typeof options === 'function') {
	    callback = options;
	    options = {};
	  }
	
	  EventEmitter.call(this);
	
	  options = options || {};
	
	  this._callback = callback;
	  this._callSite = null;
	  this._ended    = false;
	  this._timeout  = options.timeout;
	
	  // For Timers
	  this._idleNext    = null;
	  this._idlePrev    = null;
	  this._idleStart   = null;
	  this._idleTimeout = undefined;
	  this._repeat      = null;
	}
	
	Sequence.determinePacket = function(byte) {
	  switch (byte) {
	    case 0x00: return Packets.OkPacket;
	    case 0xfe: return Packets.EofPacket;
	    case 0xff: return Packets.ErrorPacket;
	  }
	};
	
	Sequence.prototype.hasErrorHandler = function() {
	  return Boolean(this._callback) || listenerCount(this, 'error') > 1;
	};
	
	Sequence.prototype._packetToError = function(packet) {
	  var code = ErrorConstants[packet.errno] || 'UNKNOWN_CODE_PLEASE_REPORT';
	  var err  = new Error(code + ': ' + packet.message);
	  err.code = code;
	  err.errno = packet.errno;
	  err.sqlState = packet.sqlState;
	
	  return err;
	};
	
	Sequence.prototype._addLongStackTrace = function(err) {
	  if (!this._callSite) {
	    return;
	  }
	
	  var delimiter = '\n    --------------------\n' ;
	
	  if (err.stack.indexOf(delimiter) > -1) {
	    return;
	  }
	
	  err.stack += delimiter + this._callSite.stack.replace(/.+\n/, '');
	};
	
	Sequence.prototype.end = function(err) {
	  if (this._ended) {
	    return;
	  }
	
	  this._ended = true;
	
	  if (err) {
	    this._addLongStackTrace(err);
	  }
	
	  // Without this we are leaking memory. This problem was introduced in
	  // 8189925374e7ce3819bbe88b64c7b15abac96b16. I suspect that the error object
	  // causes a cyclic reference that the GC does not detect properly, but I was
	  // unable to produce a standalone version of this leak. This would be a great
	  // challenge for somebody interested in difficult problems : )!
	  this._callSite = null;
	
	  // try...finally for exception safety
	  try {
	    if (err) {
	      this.emit('error', err);
	    }
	  } finally {
	    try {
	      if (this._callback) {
	        this._callback.apply(this, arguments);
	      }
	    } finally {
	      this.emit('end');
	    }
	  }
	};
	
	Sequence.prototype['OkPacket'] = function(packet) {
	  this.end(null, packet);
	};
	
	Sequence.prototype['ErrorPacket'] = function(packet) {
	  this.end(this._packetToError(packet));
	};
	
	// Implemented by child classes
	Sequence.prototype.start = function() {};
	
	Sequence.prototype._onTimeout = function _onTimeout() {
	  this.emit('timeout');
	};


/***/ },
/* 33 */
/***/ function(module, exports) {

	module.exports = require("util");

/***/ },
/* 34 */
/***/ function(module, exports) {

	module.exports = require("events");

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	exports.ClientAuthenticationPacket = __webpack_require__(36);
	exports.ComChangeUserPacket = __webpack_require__(37);
	exports.ComPingPacket = __webpack_require__(38);
	exports.ComQueryPacket = __webpack_require__(39);
	exports.ComQuitPacket = __webpack_require__(40);
	exports.ComStatisticsPacket = __webpack_require__(41);
	exports.EmptyPacket = __webpack_require__(42);
	exports.EofPacket = __webpack_require__(43);
	exports.ErrorPacket = __webpack_require__(44);
	exports.Field = __webpack_require__(45);
	exports.FieldPacket = __webpack_require__(47);
	exports.HandshakeInitializationPacket = __webpack_require__(48);
	exports.LocalDataFilePacket = __webpack_require__(49);
	exports.OkPacket = __webpack_require__(50);
	exports.OldPasswordPacket = __webpack_require__(51);
	exports.ResultSetHeaderPacket = __webpack_require__(52);
	exports.RowDataPacket = __webpack_require__(53);
	exports.SSLRequestPacket = __webpack_require__(54);
	exports.StatisticsPacket = __webpack_require__(55);
	exports.UseOldPasswordPacket = __webpack_require__(56);


/***/ },
/* 36 */
/***/ function(module, exports) {

	module.exports = ClientAuthenticationPacket;
	function ClientAuthenticationPacket(options) {
	  options = options || {};
	
	  this.clientFlags   = options.clientFlags;
	  this.maxPacketSize = options.maxPacketSize;
	  this.charsetNumber = options.charsetNumber;
	  this.filler        = undefined;
	  this.user          = options.user;
	  this.scrambleBuff  = options.scrambleBuff;
	  this.database      = options.database;
	  this.protocol41    = options.protocol41;
	}
	
	ClientAuthenticationPacket.prototype.parse = function(parser) {
	  if (this.protocol41) {
	    this.clientFlags   = parser.parseUnsignedNumber(4);
	    this.maxPacketSize = parser.parseUnsignedNumber(4);
	    this.charsetNumber = parser.parseUnsignedNumber(1);
	    this.filler        = parser.parseFiller(23);
	    this.user          = parser.parseNullTerminatedString();
	    this.scrambleBuff  = parser.parseLengthCodedBuffer();
	    this.database      = parser.parseNullTerminatedString();
	  } else {
	    this.clientFlags   = parser.parseUnsignedNumber(2);
	    this.maxPacketSize = parser.parseUnsignedNumber(3);
	    this.user          = parser.parseNullTerminatedString();
	    this.scrambleBuff  = parser.parseBuffer(8);
	    this.database      = parser.parseLengthCodedBuffer();
	  }
	};
	
	ClientAuthenticationPacket.prototype.write = function(writer) {
	  if (this.protocol41) {
	    writer.writeUnsignedNumber(4, this.clientFlags);
	    writer.writeUnsignedNumber(4, this.maxPacketSize);
	    writer.writeUnsignedNumber(1, this.charsetNumber);
	    writer.writeFiller(23);
	    writer.writeNullTerminatedString(this.user);
	    writer.writeLengthCodedBuffer(this.scrambleBuff);
	    writer.writeNullTerminatedString(this.database);
	  } else {
	    writer.writeUnsignedNumber(2, this.clientFlags);
	    writer.writeUnsignedNumber(3, this.maxPacketSize);
	    writer.writeNullTerminatedString(this.user);
	    writer.writeBuffer(this.scrambleBuff);
	    if (this.database && this.database.length) {
	      writer.writeFiller(1);
	      writer.writeBuffer(new Buffer(this.database));
	    }
	  }
	};


/***/ },
/* 37 */
/***/ function(module, exports) {

	module.exports = ComChangeUserPacket;
	function ComChangeUserPacket(options) {
	  options = options || {};
	
	  this.command       = 0x11;
	  this.user          = options.user;
	  this.scrambleBuff  = options.scrambleBuff;
	  this.database      = options.database;
	  this.charsetNumber = options.charsetNumber;
	}
	
	ComChangeUserPacket.prototype.parse = function(parser) {
	  this.command       = parser.parseUnsignedNumber(1);
	  this.user          = parser.parseNullTerminatedString();
	  this.scrambleBuff  = parser.parseLengthCodedBuffer();
	  this.database      = parser.parseNullTerminatedString();
	  this.charsetNumber = parser.parseUnsignedNumber(1);
	};
	
	ComChangeUserPacket.prototype.write = function(writer) {
	  writer.writeUnsignedNumber(1, this.command);
	  writer.writeNullTerminatedString(this.user);
	  writer.writeLengthCodedBuffer(this.scrambleBuff);
	  writer.writeNullTerminatedString(this.database);
	  writer.writeUnsignedNumber(2, this.charsetNumber);
	};


/***/ },
/* 38 */
/***/ function(module, exports) {

	module.exports = ComPingPacket;
	function ComPingPacket(sql) {
	  this.command = 0x0e;
	}
	
	ComPingPacket.prototype.write = function(writer) {
	  writer.writeUnsignedNumber(1, this.command);
	};
	
	ComPingPacket.prototype.parse = function(parser) {
	  this.command = parser.parseUnsignedNumber(1);
	};


/***/ },
/* 39 */
/***/ function(module, exports) {

	module.exports = ComQueryPacket;
	function ComQueryPacket(sql) {
	  this.command = 0x03;
	  this.sql     = sql;
	}
	
	ComQueryPacket.prototype.write = function(writer) {
	  writer.writeUnsignedNumber(1, this.command);
	  writer.writeString(this.sql);
	};
	
	ComQueryPacket.prototype.parse = function(parser) {
	  this.command = parser.parseUnsignedNumber(1);
	  this.sql     = parser.parsePacketTerminatedString();
	};


/***/ },
/* 40 */
/***/ function(module, exports) {

	module.exports = ComQuitPacket;
	function ComQuitPacket(sql) {
	  this.command = 0x01;
	}
	
	ComQuitPacket.prototype.parse = function parse(parser) {
	  this.command = parser.parseUnsignedNumber(1);
	};
	
	ComQuitPacket.prototype.write = function write(writer) {
	  writer.writeUnsignedNumber(1, this.command);
	};


/***/ },
/* 41 */
/***/ function(module, exports) {

	module.exports = ComStatisticsPacket;
	function ComStatisticsPacket(sql) {
	  this.command = 0x09;
	}
	
	ComStatisticsPacket.prototype.write = function(writer) {
	  writer.writeUnsignedNumber(1, this.command);
	};
	
	ComStatisticsPacket.prototype.parse = function(parser) {
	  this.command = parser.parseUnsignedNumber(1);
	};


/***/ },
/* 42 */
/***/ function(module, exports) {

	module.exports = EmptyPacket;
	function EmptyPacket() {
	}
	
	EmptyPacket.prototype.write = function(writer) {
	};


/***/ },
/* 43 */
/***/ function(module, exports) {

	module.exports = EofPacket;
	function EofPacket(options) {
	  options = options || {};
	
	  this.fieldCount   = undefined;
	  this.warningCount = options.warningCount;
	  this.serverStatus = options.serverStatus;
	  this.protocol41   = options.protocol41;
	}
	
	EofPacket.prototype.parse = function(parser) {
	  this.fieldCount   = parser.parseUnsignedNumber(1);
	  if (this.protocol41) {
	    this.warningCount = parser.parseUnsignedNumber(2);
	    this.serverStatus = parser.parseUnsignedNumber(2);
	  }
	};
	
	EofPacket.prototype.write = function(writer) {
	  writer.writeUnsignedNumber(1, 0xfe);
	  if (this.protocol41) {
	    writer.writeUnsignedNumber(2, this.warningCount);
	    writer.writeUnsignedNumber(2, this.serverStatus);
	  }
	};


/***/ },
/* 44 */
/***/ function(module, exports) {

	module.exports = ErrorPacket;
	function ErrorPacket(options) {
	  options = options || {};
	
	  this.fieldCount     = options.fieldCount;
	  this.errno          = options.errno;
	  this.sqlStateMarker = options.sqlStateMarker;
	  this.sqlState       = options.sqlState;
	  this.message        = options.message;
	}
	
	ErrorPacket.prototype.parse = function(parser) {
	  this.fieldCount = parser.parseUnsignedNumber(1);
	  this.errno      = parser.parseUnsignedNumber(2);
	
	  // sqlStateMarker ('#' = 0x23) indicates error packet format
	  if (parser.peak() === 0x23) {
	    this.sqlStateMarker = parser.parseString(1);
	    this.sqlState       = parser.parseString(5);
	  }
	
	  this.message = parser.parsePacketTerminatedString();
	};
	
	ErrorPacket.prototype.write = function(writer) {
	  writer.writeUnsignedNumber(1, 0xff);
	  writer.writeUnsignedNumber(2, this.errno);
	
	  if (this.sqlStateMarker) {
	    writer.writeString(this.sqlStateMarker);
	    writer.writeString(this.sqlState);
	  }
	
	  writer.writeString(this.message);
	};


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var Types = __webpack_require__(46);
	
	module.exports = Field;
	function Field(options) {
	  options = options || {};
	
	  this.parser = options.parser;
	  this.packet = options.packet;
	  this.db     = options.packet.db;
	  this.table  = options.packet.table;
	  this.name   = options.packet.name;
	  this.type   = typeToString(options.packet.type);
	  this.length = options.packet.length;
	}
	
	Field.prototype.string = function () {
	  return this.parser.parseLengthCodedString();
	};
	
	Field.prototype.buffer = function () {
	  return this.parser.parseLengthCodedBuffer();
	};
	
	Field.prototype.geometry = function () {
	  return this.parser.parseGeometryValue();
	};
	
	function typeToString(t) {
	  for (var k in Types) {
	    if (Types[k] == t) return k;
	  }
	}


/***/ },
/* 46 */
/***/ function(module, exports) {

	// Manually extracted from mysql-5.5.23/include/mysql_com.h
	// some more info here: http://dev.mysql.com/doc/refman/5.5/en/c-api-prepared-statement-type-codes.html
	exports.DECIMAL     = 0x00; // aka DECIMAL (http://dev.mysql.com/doc/refman/5.0/en/precision-math-decimal-changes.html)
	exports.TINY        = 0x01; // aka TINYINT, 1 byte
	exports.SHORT       = 0x02; // aka SMALLINT, 2 bytes
	exports.LONG        = 0x03; // aka INT, 4 bytes
	exports.FLOAT       = 0x04; // aka FLOAT, 4-8 bytes
	exports.DOUBLE      = 0x05; // aka DOUBLE, 8 bytes
	exports.NULL        = 0x06; // NULL (used for prepared statements, I think)
	exports.TIMESTAMP   = 0x07; // aka TIMESTAMP
	exports.LONGLONG    = 0x08; // aka BIGINT, 8 bytes
	exports.INT24       = 0x09; // aka MEDIUMINT, 3 bytes
	exports.DATE        = 0x0a; // aka DATE
	exports.TIME        = 0x0b; // aka TIME
	exports.DATETIME    = 0x0c; // aka DATETIME
	exports.YEAR        = 0x0d; // aka YEAR, 1 byte (don't ask)
	exports.NEWDATE     = 0x0e; // aka ?
	exports.VARCHAR     = 0x0f; // aka VARCHAR (?)
	exports.BIT         = 0x10; // aka BIT, 1-8 byte
	exports.NEWDECIMAL  = 0xf6; // aka DECIMAL
	exports.ENUM        = 0xf7; // aka ENUM
	exports.SET         = 0xf8; // aka SET
	exports.TINY_BLOB   = 0xf9; // aka TINYBLOB, TINYTEXT
	exports.MEDIUM_BLOB = 0xfa; // aka MEDIUMBLOB, MEDIUMTEXT
	exports.LONG_BLOB   = 0xfb; // aka LONGBLOG, LONGTEXT
	exports.BLOB        = 0xfc; // aka BLOB, TEXT
	exports.VAR_STRING  = 0xfd; // aka VARCHAR, VARBINARY
	exports.STRING      = 0xfe; // aka CHAR, BINARY
	exports.GEOMETRY    = 0xff; // aka GEOMETRY


/***/ },
/* 47 */
/***/ function(module, exports) {

	module.exports = FieldPacket;
	function FieldPacket(options) {
	  options = options || {};
	
	  this.catalog    = options.catalog;
	  this.db         = options.db;
	  this.table      = options.table;
	  this.orgTable   = options.orgTable;
	  this.name       = options.name;
	  this.orgName    = options.orgName;
	  this.charsetNr  = options.charsetNr;
	  this.length     = options.length;
	  this.type       = options.type;
	  this.flags      = options.flags;
	  this.decimals   = options.decimals;
	  this.default    = options.default;
	  this.zeroFill   = options.zeroFill;
	  this.protocol41 = options.protocol41
	}
	
	FieldPacket.prototype.parse = function(parser) {
	  if (this.protocol41) {
	    this.catalog     = parser.parseLengthCodedString();
	    this.db          = parser.parseLengthCodedString();
	    this.table       = parser.parseLengthCodedString();
	    this.orgTable    = parser.parseLengthCodedString();
	    this.name        = parser.parseLengthCodedString();
	    this.orgName     = parser.parseLengthCodedString();
	
	    if (parser.parseLengthCodedNumber() !== 0x0c) {
	      var err  = new TypeError('Received invalid field length');
	      err.code = 'PARSER_INVALID_FIELD_LENGTH';
	      throw err;
	    }
	
	    this.charsetNr   = parser.parseUnsignedNumber(2);
	    this.length      = parser.parseUnsignedNumber(4);
	    this.type        = parser.parseUnsignedNumber(1);
	    this.flags       = parser.parseUnsignedNumber(2);
	    this.decimals    = parser.parseUnsignedNumber(1);
	
	    var filler       = parser.parseBuffer(2);
	    if (filler[0] !== 0x0 || filler[1] !== 0x0) {
	      var err  = new TypeError('Received invalid filler');
	      err.code = 'PARSER_INVALID_FILLER';
	      throw err;
	    }
	
	    // parsed flags
	    this.zeroFill    = (this.flags & 0x0040 ? true : false);
	
	    if (parser.reachedPacketEnd()) {
	      return;
	    }
	
	    this.default     = parser.parseLengthCodedString();
	  } else {
	    this.table       = parser.parseLengthCodedString();
	    this.name        = parser.parseLengthCodedString();
	    this.length      = parser.parseUnsignedNumber(parser.parseUnsignedNumber(1));
	    this.type        = parser.parseUnsignedNumber(parser.parseUnsignedNumber(1));
	  }
	};
	
	FieldPacket.prototype.write = function(writer) {
	  if (this.protocol41) {
	    writer.writeLengthCodedString(this.catalog);
	    writer.writeLengthCodedString(this.db);
	    writer.writeLengthCodedString(this.table);
	    writer.writeLengthCodedString(this.orgTable);
	    writer.writeLengthCodedString(this.name);
	    writer.writeLengthCodedString(this.orgName);
	
	    writer.writeLengthCodedNumber(0x0c);
	    writer.writeUnsignedNumber(2, this.charsetNr || 0);
	    writer.writeUnsignedNumber(4, this.length || 0);
	    writer.writeUnsignedNumber(1, this.type || 0);
	    writer.writeUnsignedNumber(2, this.flags || 0);
	    writer.writeUnsignedNumber(1, this.decimals || 0);
	    writer.writeFiller(2);
	
	    if (this.default !== undefined) {
	      writer.writeLengthCodedString(this.default);
	    }
	  } else {
	    writer.writeLengthCodedString(this.table);
	    writer.writeLengthCodedString(this.name);
	    writer.writeUnsignedNumber(1, 0x01);
	    writer.writeUnsignedNumber(1, this.length);
	    writer.writeUnsignedNumber(1, 0x01);
	    writer.writeUnsignedNumber(1, this.type);
	  }
	};


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var Client = __webpack_require__(23);
	
	module.exports = HandshakeInitializationPacket;
	function HandshakeInitializationPacket(options) {
	  options = options || {};
	
	  this.protocolVersion     = options.protocolVersion;
	  this.serverVersion       = options.serverVersion;
	  this.threadId            = options.threadId;
	  this.scrambleBuff1       = options.scrambleBuff1;
	  this.filler1             = options.filler1;
	  this.serverCapabilities1 = options.serverCapabilities1;
	  this.serverLanguage      = options.serverLanguage;
	  this.serverStatus        = options.serverStatus;
	  this.serverCapabilities2 = options.serverCapabilities2;
	  this.scrambleLength      = options.scrambleLength;
	  this.filler2             = options.filler2;
	  this.scrambleBuff2       = options.scrambleBuff2;
	  this.filler3             = options.filler3;
	  this.pluginData          = options.pluginData;
	  this.protocol41          = options.protocol41;
	
	  if (this.protocol41) {
	    // force set the bit in serverCapabilities1
	    this.serverCapabilities1 |= Client.CLIENT_PROTOCOL_41;
	  }
	}
	
	HandshakeInitializationPacket.prototype.parse = function(parser) {
	  this.protocolVersion     = parser.parseUnsignedNumber(1);
	  this.serverVersion       = parser.parseNullTerminatedString();
	  this.threadId            = parser.parseUnsignedNumber(4);
	  this.scrambleBuff1       = parser.parseBuffer(8);
	  this.filler1             = parser.parseFiller(1);
	  this.serverCapabilities1 = parser.parseUnsignedNumber(2);
	  this.serverLanguage      = parser.parseUnsignedNumber(1);
	  this.serverStatus        = parser.parseUnsignedNumber(2);
	
	  this.protocol41          = (this.serverCapabilities1 & (1 << 9)) > 0;
	
	  if (this.protocol41) {
	    this.serverCapabilities2 = parser.parseUnsignedNumber(2);
	    this.scrambleLength      = parser.parseUnsignedNumber(1);
	    this.filler2             = parser.parseFiller(10);
	    // scrambleBuff2 should be 0x00 terminated, but sphinx does not do this
	    // so we assume scrambleBuff2 to be 12 byte and treat the next byte as a
	    // filler byte.
	    this.scrambleBuff2       = parser.parseBuffer(12);
	    this.filler3             = parser.parseFiller(1);
	  } else {
	    this.filler2             = parser.parseFiller(13);
	  }
	
	  if (parser.reachedPacketEnd()) {
	    return;
	  }
	
	  // According to the docs this should be 0x00 terminated, but MariaDB does
	  // not do this, so we assume this string to be packet terminated.
	  this.pluginData = parser.parsePacketTerminatedString();
	
	  // However, if there is a trailing '\0', strip it
	  var lastChar = this.pluginData.length - 1;
	  if (this.pluginData[lastChar] === '\0') {
	    this.pluginData = this.pluginData.substr(0, lastChar);
	  }
	};
	
	HandshakeInitializationPacket.prototype.write = function(writer) {
	  writer.writeUnsignedNumber(1, this.protocolVersion);
	  writer.writeNullTerminatedString(this.serverVersion);
	  writer.writeUnsignedNumber(4, this.threadId);
	  writer.writeBuffer(this.scrambleBuff1);
	  writer.writeFiller(1);
	  writer.writeUnsignedNumber(2, this.serverCapabilities1);
	  writer.writeUnsignedNumber(1, this.serverLanguage);
	  writer.writeUnsignedNumber(2, this.serverStatus);
	  if (this.protocol41) {
	    writer.writeUnsignedNumber(2, this.serverCapabilities2);
	    writer.writeUnsignedNumber(1, this.scrambleLength);
	    writer.writeFiller(10);
	  }
	  writer.writeNullTerminatedBuffer(this.scrambleBuff2);
	
	  if (this.pluginData !== undefined) {
	    writer.writeNullTerminatedString(this.pluginData);
	  }
	};
	
	HandshakeInitializationPacket.prototype.scrambleBuff = function() {
	  var buffer = new Buffer(this.scrambleBuff1.length +
	                          (typeof this.scrambleBuff2 != "undefined" ? this.scrambleBuff2.length : 0));
	
	  this.scrambleBuff1.copy(buffer);
	  if (typeof this.scrambleBuff2 != "undefined") {
	    this.scrambleBuff2.copy(buffer, this.scrambleBuff1.length);
	  }
	
	  return buffer;
	};


/***/ },
/* 49 */
/***/ function(module, exports) {

	module.exports = LocalDataFilePacket;
	/**
	 * @param {Buffer} data
	 */
	function LocalDataFilePacket(data) {
	  this.data = data;
	}
	
	LocalDataFilePacket.prototype.write = function(writer) {
	  writer.writeBuffer(this.data);
	};


/***/ },
/* 50 */
/***/ function(module, exports) {

	module.exports = OkPacket;
	function OkPacket(options) {
	  options = options || {};
	
	  this.fieldCount   = undefined;
	  this.affectedRows = undefined;
	  this.insertId     = undefined;
	  this.serverStatus = undefined;
	  this.warningCount = undefined;
	  this.message      = undefined;
	  this.protocol41   = options.protocol41;
	}
	
	OkPacket.prototype.parse = function(parser) {
	  this.fieldCount   = parser.parseUnsignedNumber(1);
	  this.affectedRows = parser.parseLengthCodedNumber();
	  this.insertId     = parser.parseLengthCodedNumber();
	  if (this.protocol41) {
	    this.serverStatus = parser.parseUnsignedNumber(2);
	    this.warningCount = parser.parseUnsignedNumber(2);
	  }
	  this.message      = parser.parsePacketTerminatedString();
	  this.changedRows  = 0;
	
	  var m = this.message.match(/\schanged:\s*(\d+)/i);
	
	  if (m !== null) {
	    this.changedRows = parseInt(m[1], 10);
	  }
	};
	
	OkPacket.prototype.write = function(writer) {
	  writer.writeUnsignedNumber(1, 0x00);
	  writer.writeLengthCodedNumber(this.affectedRows || 0);
	  writer.writeLengthCodedNumber(this.insertId || 0);
	  if (this.protocol41) {
	    writer.writeUnsignedNumber(2, this.serverStatus || 0);
	    writer.writeUnsignedNumber(2, this.warningCount || 0);
	  }
	  writer.writeString(this.message);
	};


/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = OldPasswordPacket;
	function OldPasswordPacket(options) {
	  options = options || {};
	
	  this.scrambleBuff = options.scrambleBuff;
	}
	
	OldPasswordPacket.prototype.parse = function(parser) {
	  this.scrambleBuff = parser.parseNullTerminatedBuffer();
	};
	
	OldPasswordPacket.prototype.write = function(writer) {
	  writer.writeBuffer(this.scrambleBuff);
	  writer.writeFiller(1);
	};


/***/ },
/* 52 */
/***/ function(module, exports) {

	module.exports = ResultSetHeaderPacket;
	function ResultSetHeaderPacket(options) {
	  options = options || {};
	
	  this.fieldCount = options.fieldCount;
	  this.extra      = options.extra;
	}
	
	ResultSetHeaderPacket.prototype.parse = function(parser) {
	  this.fieldCount = parser.parseLengthCodedNumber();
	
	  if (parser.reachedPacketEnd()) return;
	
	  this.extra = (this.fieldCount === null)
	    ? parser.parsePacketTerminatedString()
	    : parser.parseLengthCodedNumber();
	};
	
	ResultSetHeaderPacket.prototype.write = function(writer) {
	  writer.writeLengthCodedNumber(this.fieldCount);
	
	  if (this.extra !== undefined) {
	    writer.writeLengthCodedNumber(this.extra);
	  }
	};


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var Types                        = __webpack_require__(46);
	var Charsets                     = __webpack_require__(24);
	var Field                        = __webpack_require__(45);
	var IEEE_754_BINARY_64_PRECISION = Math.pow(2, 53);
	
	module.exports = RowDataPacket;
	function RowDataPacket() {
	}
	
	Object.defineProperty(RowDataPacket.prototype, 'parse', {
	  configurable: true,
	  enumerable: false,
	  value: parse
	});
	
	Object.defineProperty(RowDataPacket.prototype, '_typeCast', {
	  configurable: true,
	  enumerable: false,
	  value: typeCast
	});
	
	function parse(parser, fieldPackets, typeCast, nestTables, connection) {
	  var self = this;
	  var next = function () {
	    return self._typeCast(fieldPacket, parser, connection.config.timezone, connection.config.supportBigNumbers, connection.config.bigNumberStrings, connection.config.dateStrings);
	  };
	
	  for (var i = 0; i < fieldPackets.length; i++) {
	    var fieldPacket = fieldPackets[i];
	    var value;
	
	    if (typeof typeCast == "function") {
	      value = typeCast.apply(connection, [ new Field({ packet: fieldPacket, parser: parser }), next ]);
	    } else {
	      value = (typeCast)
	        ? this._typeCast(fieldPacket, parser, connection.config.timezone, connection.config.supportBigNumbers, connection.config.bigNumberStrings, connection.config.dateStrings)
	        : ( (fieldPacket.charsetNr === Charsets.BINARY)
	          ? parser.parseLengthCodedBuffer()
	          : parser.parseLengthCodedString() );
	    }
	
	    if (typeof nestTables == "string" && nestTables.length) {
	      this[fieldPacket.table + nestTables + fieldPacket.name] = value;
	    } else if (nestTables) {
	      this[fieldPacket.table] = this[fieldPacket.table] || {};
	      this[fieldPacket.table][fieldPacket.name] = value;
	    } else {
	      this[fieldPacket.name] = value;
	    }
	  }
	}
	
	function typeCast(field, parser, timeZone, supportBigNumbers, bigNumberStrings, dateStrings) {
	  var numberString;
	
	  switch (field.type) {
	    case Types.TIMESTAMP:
	    case Types.DATE:
	    case Types.DATETIME:
	    case Types.NEWDATE:
	      var dateString = parser.parseLengthCodedString();
	      if (dateStrings) {
	          return dateString;
	      }
	      var dt;
	
	      if (dateString === null) {
	        return null;
	      }
	
	      var originalString = dateString;
	      if (field.type === Types.DATE) {
	        dateString += ' 00:00:00';
	      }
	
	      if (timeZone !== 'local') {
	        dateString += ' ' + timeZone;
	      }
	
	      dt = new Date(dateString);
	      if (isNaN(dt.getTime())) {
	        return originalString;
	      }
	
	      return dt;
	    case Types.TINY:
	    case Types.SHORT:
	    case Types.LONG:
	    case Types.INT24:
	    case Types.YEAR:
	    case Types.FLOAT:
	    case Types.DOUBLE:
	      numberString = parser.parseLengthCodedString();
	      return (numberString === null || (field.zeroFill && numberString[0] == "0"))
	        ? numberString : Number(numberString);
	    case Types.NEWDECIMAL:
	    case Types.LONGLONG:
	      numberString = parser.parseLengthCodedString();
	      return (numberString === null || (field.zeroFill && numberString[0] == "0"))
	        ? numberString
	        : ((supportBigNumbers && (bigNumberStrings || (Number(numberString) > IEEE_754_BINARY_64_PRECISION)))
	          ? numberString
	          : Number(numberString));
	    case Types.BIT:
	      return parser.parseLengthCodedBuffer();
	    case Types.STRING:
	    case Types.VAR_STRING:
	    case Types.TINY_BLOB:
	    case Types.MEDIUM_BLOB:
	    case Types.LONG_BLOB:
	    case Types.BLOB:
	      return (field.charsetNr === Charsets.BINARY)
	        ? parser.parseLengthCodedBuffer()
	        : parser.parseLengthCodedString();
	    case Types.GEOMETRY:
	      return parser.parseGeometryValue();
	    default:
	      return parser.parseLengthCodedString();
	  }
	}


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	// http://dev.mysql.com/doc/internals/en/ssl.html
	// http://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::SSLRequest
	
	var ClientConstants = __webpack_require__(23);
	
	module.exports = SSLRequestPacket;
	
	function SSLRequestPacket(options) {
	  options = options || {};
	  this.clientFlags   = options.clientFlags | ClientConstants.CLIENT_SSL;
	  this.maxPacketSize = options.maxPacketSize;
	  this.charsetNumber = options.charsetNumber;
	}
	
	SSLRequestPacket.prototype.parse = function(parser) {
	  // TODO: check SSLRequest packet v41 vs pre v41
	  this.clientFlags   = parser.parseUnsignedNumber(4);
	  this.maxPacketSize = parser.parseUnsignedNumber(4);
	  this.charsetNumber = parser.parseUnsignedNumber(1);
	};
	
	SSLRequestPacket.prototype.write = function(writer) {
	  writer.writeUnsignedNumber(4, this.clientFlags);
	  writer.writeUnsignedNumber(4, this.maxPacketSize);
	  writer.writeUnsignedNumber(1, this.charsetNumber);
	  writer.writeFiller(23);
	};


/***/ },
/* 55 */
/***/ function(module, exports) {

	module.exports = StatisticsPacket;
	function StatisticsPacket() {
	  this.message      = undefined;
	}
	
	StatisticsPacket.prototype.parse = function(parser) {
	  this.message      = parser.parsePacketTerminatedString();
	
	  var items = this.message.split(/\s\s/);
	  for (var i = 0; i < items.length; i++) {
	    var m = items[i].match(/^(.+)\:\s+(.+)$/);
	    if (m !== null) {
	      this[m[1].toLowerCase().replace(/\s/g, '_')] = Number(m[2]);
	    }
	  }
	};
	
	StatisticsPacket.prototype.write = function(writer) {
	  writer.writeString(this.message);
	};


/***/ },
/* 56 */
/***/ function(module, exports) {

	module.exports = UseOldPasswordPacket;
	function UseOldPasswordPacket(options) {
	  options = options || {};
	
	  this.firstByte = options.firstByte || 0xfe;
	}
	
	UseOldPasswordPacket.prototype.parse = function(parser) {
	  this.firstByte = parser.parseUnsignedNumber(1);
	};
	
	UseOldPasswordPacket.prototype.write = function(writer) {
	  writer.writeUnsignedNumber(1, this.firstByte);
	};


/***/ },
/* 57 */
/***/ function(module, exports) {

	/**
	 * MySQL error constants
	 *
	 * !! Generated by generate-error-constants.js, do not modify by hand !!
	 */
	
	exports.EE_CANTCREATEFILE                                                   = 1;
	exports.EE_READ                                                             = 2;
	exports.EE_WRITE                                                            = 3;
	exports.EE_BADCLOSE                                                         = 4;
	exports.EE_OUTOFMEMORY                                                      = 5;
	exports.EE_DELETE                                                           = 6;
	exports.EE_LINK                                                             = 7;
	exports.EE_EOFERR                                                           = 9;
	exports.EE_CANTLOCK                                                         = 10;
	exports.EE_CANTUNLOCK                                                       = 11;
	exports.EE_DIR                                                              = 12;
	exports.EE_STAT                                                             = 13;
	exports.EE_CANT_CHSIZE                                                      = 14;
	exports.EE_CANT_OPEN_STREAM                                                 = 15;
	exports.EE_GETWD                                                            = 16;
	exports.EE_SETWD                                                            = 17;
	exports.EE_LINK_WARNING                                                     = 18;
	exports.EE_OPEN_WARNING                                                     = 19;
	exports.EE_DISK_FULL                                                        = 20;
	exports.EE_CANT_MKDIR                                                       = 21;
	exports.EE_UNKNOWN_CHARSET                                                  = 22;
	exports.EE_OUT_OF_FILERESOURCES                                             = 23;
	exports.EE_CANT_READLINK                                                    = 24;
	exports.EE_CANT_SYMLINK                                                     = 25;
	exports.EE_REALPATH                                                         = 26;
	exports.EE_SYNC                                                             = 27;
	exports.EE_UNKNOWN_COLLATION                                                = 28;
	exports.EE_FILENOTFOUND                                                     = 29;
	exports.EE_FILE_NOT_CLOSED                                                  = 30;
	exports.EE_CHANGE_OWNERSHIP                                                 = 31;
	exports.EE_CHANGE_PERMISSIONS                                               = 32;
	exports.EE_CANT_SEEK                                                        = 33;
	exports.HA_ERR_KEY_NOT_FOUND                                                = 120;
	exports.HA_ERR_FOUND_DUPP_KEY                                               = 121;
	exports.HA_ERR_INTERNAL_ERROR                                               = 122;
	exports.HA_ERR_RECORD_CHANGED                                               = 123;
	exports.HA_ERR_WRONG_INDEX                                                  = 124;
	exports.HA_ERR_CRASHED                                                      = 126;
	exports.HA_ERR_WRONG_IN_RECORD                                              = 127;
	exports.HA_ERR_OUT_OF_MEM                                                   = 128;
	exports.HA_ERR_NOT_A_TABLE                                                  = 130;
	exports.HA_ERR_WRONG_COMMAND                                                = 131;
	exports.HA_ERR_OLD_FILE                                                     = 132;
	exports.HA_ERR_NO_ACTIVE_RECORD                                             = 133;
	exports.HA_ERR_RECORD_DELETED                                               = 134;
	exports.HA_ERR_RECORD_FILE_FULL                                             = 135;
	exports.HA_ERR_INDEX_FILE_FULL                                              = 136;
	exports.HA_ERR_END_OF_FILE                                                  = 137;
	exports.HA_ERR_UNSUPPORTED                                                  = 138;
	exports.HA_ERR_TO_BIG_ROW                                                   = 139;
	exports.HA_WRONG_CREATE_OPTION                                              = 140;
	exports.HA_ERR_FOUND_DUPP_UNIQUE                                            = 141;
	exports.HA_ERR_UNKNOWN_CHARSET                                              = 142;
	exports.HA_ERR_WRONG_MRG_TABLE_DEF                                          = 143;
	exports.HA_ERR_CRASHED_ON_REPAIR                                            = 144;
	exports.HA_ERR_CRASHED_ON_USAGE                                             = 145;
	exports.HA_ERR_LOCK_WAIT_TIMEOUT                                            = 146;
	exports.HA_ERR_LOCK_TABLE_FULL                                              = 147;
	exports.HA_ERR_READ_ONLY_TRANSACTION                                        = 148;
	exports.HA_ERR_LOCK_DEADLOCK                                                = 149;
	exports.HA_ERR_CANNOT_ADD_FOREIGN                                           = 150;
	exports.HA_ERR_NO_REFERENCED_ROW                                            = 151;
	exports.HA_ERR_ROW_IS_REFERENCED                                            = 152;
	exports.HA_ERR_NO_SAVEPOINT                                                 = 153;
	exports.HA_ERR_NON_UNIQUE_BLOCK_SIZE                                        = 154;
	exports.HA_ERR_NO_SUCH_TABLE                                                = 155;
	exports.HA_ERR_TABLE_EXIST                                                  = 156;
	exports.HA_ERR_NO_CONNECTION                                                = 157;
	exports.HA_ERR_NULL_IN_SPATIAL                                              = 158;
	exports.HA_ERR_TABLE_DEF_CHANGED                                            = 159;
	exports.HA_ERR_NO_PARTITION_FOUND                                           = 160;
	exports.HA_ERR_RBR_LOGGING_FAILED                                           = 161;
	exports.HA_ERR_DROP_INDEX_FK                                                = 162;
	exports.HA_ERR_FOREIGN_DUPLICATE_KEY                                        = 163;
	exports.HA_ERR_TABLE_NEEDS_UPGRADE                                          = 164;
	exports.HA_ERR_TABLE_READONLY                                               = 165;
	exports.HA_ERR_AUTOINC_READ_FAILED                                          = 166;
	exports.HA_ERR_AUTOINC_ERANGE                                               = 167;
	exports.HA_ERR_GENERIC                                                      = 168;
	exports.HA_ERR_RECORD_IS_THE_SAME                                           = 169;
	exports.HA_ERR_LOGGING_IMPOSSIBLE                                           = 170;
	exports.HA_ERR_CORRUPT_EVENT                                                = 171;
	exports.HA_ERR_NEW_FILE                                                     = 172;
	exports.HA_ERR_ROWS_EVENT_APPLY                                             = 173;
	exports.HA_ERR_INITIALIZATION                                               = 174;
	exports.HA_ERR_FILE_TOO_SHORT                                               = 175;
	exports.HA_ERR_WRONG_CRC                                                    = 176;
	exports.HA_ERR_TOO_MANY_CONCURRENT_TRXS                                     = 177;
	exports.HA_ERR_NOT_IN_LOCK_PARTITIONS                                       = 178;
	exports.HA_ERR_INDEX_COL_TOO_LONG                                           = 179;
	exports.HA_ERR_INDEX_CORRUPT                                                = 180;
	exports.HA_ERR_UNDO_REC_TOO_BIG                                             = 181;
	exports.HA_FTS_INVALID_DOCID                                                = 182;
	exports.HA_ERR_TABLE_IN_FK_CHECK                                            = 183;
	exports.HA_ERR_TABLESPACE_EXISTS                                            = 184;
	exports.HA_ERR_TOO_MANY_FIELDS                                              = 185;
	exports.HA_ERR_ROW_IN_WRONG_PARTITION                                       = 186;
	exports.HA_ERR_INNODB_READ_ONLY                                             = 187;
	exports.HA_ERR_FTS_EXCEED_RESULT_CACHE_LIMIT                                = 188;
	exports.HA_ERR_TEMP_FILE_WRITE_FAILURE                                      = 189;
	exports.HA_ERR_INNODB_FORCED_RECOVERY                                       = 190;
	exports.HA_ERR_FTS_TOO_MANY_WORDS_IN_PHRASE                                 = 191;
	exports.ER_HASHCHK                                                          = 1000;
	exports.ER_NISAMCHK                                                         = 1001;
	exports.ER_NO                                                               = 1002;
	exports.ER_YES                                                              = 1003;
	exports.ER_CANT_CREATE_FILE                                                 = 1004;
	exports.ER_CANT_CREATE_TABLE                                                = 1005;
	exports.ER_CANT_CREATE_DB                                                   = 1006;
	exports.ER_DB_CREATE_EXISTS                                                 = 1007;
	exports.ER_DB_DROP_EXISTS                                                   = 1008;
	exports.ER_DB_DROP_DELETE                                                   = 1009;
	exports.ER_DB_DROP_RMDIR                                                    = 1010;
	exports.ER_CANT_DELETE_FILE                                                 = 1011;
	exports.ER_CANT_FIND_SYSTEM_REC                                             = 1012;
	exports.ER_CANT_GET_STAT                                                    = 1013;
	exports.ER_CANT_GET_WD                                                      = 1014;
	exports.ER_CANT_LOCK                                                        = 1015;
	exports.ER_CANT_OPEN_FILE                                                   = 1016;
	exports.ER_FILE_NOT_FOUND                                                   = 1017;
	exports.ER_CANT_READ_DIR                                                    = 1018;
	exports.ER_CANT_SET_WD                                                      = 1019;
	exports.ER_CHECKREAD                                                        = 1020;
	exports.ER_DISK_FULL                                                        = 1021;
	exports.ER_DUP_KEY                                                          = 1022;
	exports.ER_ERROR_ON_CLOSE                                                   = 1023;
	exports.ER_ERROR_ON_READ                                                    = 1024;
	exports.ER_ERROR_ON_RENAME                                                  = 1025;
	exports.ER_ERROR_ON_WRITE                                                   = 1026;
	exports.ER_FILE_USED                                                        = 1027;
	exports.ER_FILSORT_ABORT                                                    = 1028;
	exports.ER_FORM_NOT_FOUND                                                   = 1029;
	exports.ER_GET_ERRNO                                                        = 1030;
	exports.ER_ILLEGAL_HA                                                       = 1031;
	exports.ER_KEY_NOT_FOUND                                                    = 1032;
	exports.ER_NOT_FORM_FILE                                                    = 1033;
	exports.ER_NOT_KEYFILE                                                      = 1034;
	exports.ER_OLD_KEYFILE                                                      = 1035;
	exports.ER_OPEN_AS_READONLY                                                 = 1036;
	exports.ER_OUTOFMEMORY                                                      = 1037;
	exports.ER_OUT_OF_SORTMEMORY                                                = 1038;
	exports.ER_UNEXPECTED_EOF                                                   = 1039;
	exports.ER_CON_COUNT_ERROR                                                  = 1040;
	exports.ER_OUT_OF_RESOURCES                                                 = 1041;
	exports.ER_BAD_HOST_ERROR                                                   = 1042;
	exports.ER_HANDSHAKE_ERROR                                                  = 1043;
	exports.ER_DBACCESS_DENIED_ERROR                                            = 1044;
	exports.ER_ACCESS_DENIED_ERROR                                              = 1045;
	exports.ER_NO_DB_ERROR                                                      = 1046;
	exports.ER_UNKNOWN_COM_ERROR                                                = 1047;
	exports.ER_BAD_NULL_ERROR                                                   = 1048;
	exports.ER_BAD_DB_ERROR                                                     = 1049;
	exports.ER_TABLE_EXISTS_ERROR                                               = 1050;
	exports.ER_BAD_TABLE_ERROR                                                  = 1051;
	exports.ER_NON_UNIQ_ERROR                                                   = 1052;
	exports.ER_SERVER_SHUTDOWN                                                  = 1053;
	exports.ER_BAD_FIELD_ERROR                                                  = 1054;
	exports.ER_WRONG_FIELD_WITH_GROUP                                           = 1055;
	exports.ER_WRONG_GROUP_FIELD                                                = 1056;
	exports.ER_WRONG_SUM_SELECT                                                 = 1057;
	exports.ER_WRONG_VALUE_COUNT                                                = 1058;
	exports.ER_TOO_LONG_IDENT                                                   = 1059;
	exports.ER_DUP_FIELDNAME                                                    = 1060;
	exports.ER_DUP_KEYNAME                                                      = 1061;
	exports.ER_DUP_ENTRY                                                        = 1062;
	exports.ER_WRONG_FIELD_SPEC                                                 = 1063;
	exports.ER_PARSE_ERROR                                                      = 1064;
	exports.ER_EMPTY_QUERY                                                      = 1065;
	exports.ER_NONUNIQ_TABLE                                                    = 1066;
	exports.ER_INVALID_DEFAULT                                                  = 1067;
	exports.ER_MULTIPLE_PRI_KEY                                                 = 1068;
	exports.ER_TOO_MANY_KEYS                                                    = 1069;
	exports.ER_TOO_MANY_KEY_PARTS                                               = 1070;
	exports.ER_TOO_LONG_KEY                                                     = 1071;
	exports.ER_KEY_COLUMN_DOES_NOT_EXITS                                        = 1072;
	exports.ER_BLOB_USED_AS_KEY                                                 = 1073;
	exports.ER_TOO_BIG_FIELDLENGTH                                              = 1074;
	exports.ER_WRONG_AUTO_KEY                                                   = 1075;
	exports.ER_READY                                                            = 1076;
	exports.ER_NORMAL_SHUTDOWN                                                  = 1077;
	exports.ER_GOT_SIGNAL                                                       = 1078;
	exports.ER_SHUTDOWN_COMPLETE                                                = 1079;
	exports.ER_FORCING_CLOSE                                                    = 1080;
	exports.ER_IPSOCK_ERROR                                                     = 1081;
	exports.ER_NO_SUCH_INDEX                                                    = 1082;
	exports.ER_WRONG_FIELD_TERMINATORS                                          = 1083;
	exports.ER_BLOBS_AND_NO_TERMINATED                                          = 1084;
	exports.ER_TEXTFILE_NOT_READABLE                                            = 1085;
	exports.ER_FILE_EXISTS_ERROR                                                = 1086;
	exports.ER_LOAD_INFO                                                        = 1087;
	exports.ER_ALTER_INFO                                                       = 1088;
	exports.ER_WRONG_SUB_KEY                                                    = 1089;
	exports.ER_CANT_REMOVE_ALL_FIELDS                                           = 1090;
	exports.ER_CANT_DROP_FIELD_OR_KEY                                           = 1091;
	exports.ER_INSERT_INFO                                                      = 1092;
	exports.ER_UPDATE_TABLE_USED                                                = 1093;
	exports.ER_NO_SUCH_THREAD                                                   = 1094;
	exports.ER_KILL_DENIED_ERROR                                                = 1095;
	exports.ER_NO_TABLES_USED                                                   = 1096;
	exports.ER_TOO_BIG_SET                                                      = 1097;
	exports.ER_NO_UNIQUE_LOGFILE                                                = 1098;
	exports.ER_TABLE_NOT_LOCKED_FOR_WRITE                                       = 1099;
	exports.ER_TABLE_NOT_LOCKED                                                 = 1100;
	exports.ER_BLOB_CANT_HAVE_DEFAULT                                           = 1101;
	exports.ER_WRONG_DB_NAME                                                    = 1102;
	exports.ER_WRONG_TABLE_NAME                                                 = 1103;
	exports.ER_TOO_BIG_SELECT                                                   = 1104;
	exports.ER_UNKNOWN_ERROR                                                    = 1105;
	exports.ER_UNKNOWN_PROCEDURE                                                = 1106;
	exports.ER_WRONG_PARAMCOUNT_TO_PROCEDURE                                    = 1107;
	exports.ER_WRONG_PARAMETERS_TO_PROCEDURE                                    = 1108;
	exports.ER_UNKNOWN_TABLE                                                    = 1109;
	exports.ER_FIELD_SPECIFIED_TWICE                                            = 1110;
	exports.ER_INVALID_GROUP_FUNC_USE                                           = 1111;
	exports.ER_UNSUPPORTED_EXTENSION                                            = 1112;
	exports.ER_TABLE_MUST_HAVE_COLUMNS                                          = 1113;
	exports.ER_RECORD_FILE_FULL                                                 = 1114;
	exports.ER_UNKNOWN_CHARACTER_SET                                            = 1115;
	exports.ER_TOO_MANY_TABLES                                                  = 1116;
	exports.ER_TOO_MANY_FIELDS                                                  = 1117;
	exports.ER_TOO_BIG_ROWSIZE                                                  = 1118;
	exports.ER_STACK_OVERRUN                                                    = 1119;
	exports.ER_WRONG_OUTER_JOIN                                                 = 1120;
	exports.ER_NULL_COLUMN_IN_INDEX                                             = 1121;
	exports.ER_CANT_FIND_UDF                                                    = 1122;
	exports.ER_CANT_INITIALIZE_UDF                                              = 1123;
	exports.ER_UDF_NO_PATHS                                                     = 1124;
	exports.ER_UDF_EXISTS                                                       = 1125;
	exports.ER_CANT_OPEN_LIBRARY                                                = 1126;
	exports.ER_CANT_FIND_DL_ENTRY                                               = 1127;
	exports.ER_FUNCTION_NOT_DEFINED                                             = 1128;
	exports.ER_HOST_IS_BLOCKED                                                  = 1129;
	exports.ER_HOST_NOT_PRIVILEGED                                              = 1130;
	exports.ER_PASSWORD_ANONYMOUS_USER                                          = 1131;
	exports.ER_PASSWORD_NOT_ALLOWED                                             = 1132;
	exports.ER_PASSWORD_NO_MATCH                                                = 1133;
	exports.ER_UPDATE_INFO                                                      = 1134;
	exports.ER_CANT_CREATE_THREAD                                               = 1135;
	exports.ER_WRONG_VALUE_COUNT_ON_ROW                                         = 1136;
	exports.ER_CANT_REOPEN_TABLE                                                = 1137;
	exports.ER_INVALID_USE_OF_NULL                                              = 1138;
	exports.ER_REGEXP_ERROR                                                     = 1139;
	exports.ER_MIX_OF_GROUP_FUNC_AND_FIELDS                                     = 1140;
	exports.ER_NONEXISTING_GRANT                                                = 1141;
	exports.ER_TABLEACCESS_DENIED_ERROR                                         = 1142;
	exports.ER_COLUMNACCESS_DENIED_ERROR                                        = 1143;
	exports.ER_ILLEGAL_GRANT_FOR_TABLE                                          = 1144;
	exports.ER_GRANT_WRONG_HOST_OR_USER                                         = 1145;
	exports.ER_NO_SUCH_TABLE                                                    = 1146;
	exports.ER_NONEXISTING_TABLE_GRANT                                          = 1147;
	exports.ER_NOT_ALLOWED_COMMAND                                              = 1148;
	exports.ER_SYNTAX_ERROR                                                     = 1149;
	exports.ER_DELAYED_CANT_CHANGE_LOCK                                         = 1150;
	exports.ER_TOO_MANY_DELAYED_THREADS                                         = 1151;
	exports.ER_ABORTING_CONNECTION                                              = 1152;
	exports.ER_NET_PACKET_TOO_LARGE                                             = 1153;
	exports.ER_NET_READ_ERROR_FROM_PIPE                                         = 1154;
	exports.ER_NET_FCNTL_ERROR                                                  = 1155;
	exports.ER_NET_PACKETS_OUT_OF_ORDER                                         = 1156;
	exports.ER_NET_UNCOMPRESS_ERROR                                             = 1157;
	exports.ER_NET_READ_ERROR                                                   = 1158;
	exports.ER_NET_READ_INTERRUPTED                                             = 1159;
	exports.ER_NET_ERROR_ON_WRITE                                               = 1160;
	exports.ER_NET_WRITE_INTERRUPTED                                            = 1161;
	exports.ER_TOO_LONG_STRING                                                  = 1162;
	exports.ER_TABLE_CANT_HANDLE_BLOB                                           = 1163;
	exports.ER_TABLE_CANT_HANDLE_AUTO_INCREMENT                                 = 1164;
	exports.ER_DELAYED_INSERT_TABLE_LOCKED                                      = 1165;
	exports.ER_WRONG_COLUMN_NAME                                                = 1166;
	exports.ER_WRONG_KEY_COLUMN                                                 = 1167;
	exports.ER_WRONG_MRG_TABLE                                                  = 1168;
	exports.ER_DUP_UNIQUE                                                       = 1169;
	exports.ER_BLOB_KEY_WITHOUT_LENGTH                                          = 1170;
	exports.ER_PRIMARY_CANT_HAVE_NULL                                           = 1171;
	exports.ER_TOO_MANY_ROWS                                                    = 1172;
	exports.ER_REQUIRES_PRIMARY_KEY                                             = 1173;
	exports.ER_NO_RAID_COMPILED                                                 = 1174;
	exports.ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE                                  = 1175;
	exports.ER_KEY_DOES_NOT_EXITS                                               = 1176;
	exports.ER_CHECK_NO_SUCH_TABLE                                              = 1177;
	exports.ER_CHECK_NOT_IMPLEMENTED                                            = 1178;
	exports.ER_CANT_DO_THIS_DURING_AN_TRANSACTION                               = 1179;
	exports.ER_ERROR_DURING_COMMIT                                              = 1180;
	exports.ER_ERROR_DURING_ROLLBACK                                            = 1181;
	exports.ER_ERROR_DURING_FLUSH_LOGS                                          = 1182;
	exports.ER_ERROR_DURING_CHECKPOINT                                          = 1183;
	exports.ER_NEW_ABORTING_CONNECTION                                          = 1184;
	exports.ER_DUMP_NOT_IMPLEMENTED                                             = 1185;
	exports.ER_FLUSH_MASTER_BINLOG_CLOSED                                       = 1186;
	exports.ER_INDEX_REBUILD                                                    = 1187;
	exports.ER_MASTER                                                           = 1188;
	exports.ER_MASTER_NET_READ                                                  = 1189;
	exports.ER_MASTER_NET_WRITE                                                 = 1190;
	exports.ER_FT_MATCHING_KEY_NOT_FOUND                                        = 1191;
	exports.ER_LOCK_OR_ACTIVE_TRANSACTION                                       = 1192;
	exports.ER_UNKNOWN_SYSTEM_VARIABLE                                          = 1193;
	exports.ER_CRASHED_ON_USAGE                                                 = 1194;
	exports.ER_CRASHED_ON_REPAIR                                                = 1195;
	exports.ER_WARNING_NOT_COMPLETE_ROLLBACK                                    = 1196;
	exports.ER_TRANS_CACHE_FULL                                                 = 1197;
	exports.ER_SLAVE_MUST_STOP                                                  = 1198;
	exports.ER_SLAVE_NOT_RUNNING                                                = 1199;
	exports.ER_BAD_SLAVE                                                        = 1200;
	exports.ER_MASTER_INFO                                                      = 1201;
	exports.ER_SLAVE_THREAD                                                     = 1202;
	exports.ER_TOO_MANY_USER_CONNECTIONS                                        = 1203;
	exports.ER_SET_CONSTANTS_ONLY                                               = 1204;
	exports.ER_LOCK_WAIT_TIMEOUT                                                = 1205;
	exports.ER_LOCK_TABLE_FULL                                                  = 1206;
	exports.ER_READ_ONLY_TRANSACTION                                            = 1207;
	exports.ER_DROP_DB_WITH_READ_LOCK                                           = 1208;
	exports.ER_CREATE_DB_WITH_READ_LOCK                                         = 1209;
	exports.ER_WRONG_ARGUMENTS                                                  = 1210;
	exports.ER_NO_PERMISSION_TO_CREATE_USER                                     = 1211;
	exports.ER_UNION_TABLES_IN_DIFFERENT_DIR                                    = 1212;
	exports.ER_LOCK_DEADLOCK                                                    = 1213;
	exports.ER_TABLE_CANT_HANDLE_FT                                             = 1214;
	exports.ER_CANNOT_ADD_FOREIGN                                               = 1215;
	exports.ER_NO_REFERENCED_ROW                                                = 1216;
	exports.ER_ROW_IS_REFERENCED                                                = 1217;
	exports.ER_CONNECT_TO_MASTER                                                = 1218;
	exports.ER_QUERY_ON_MASTER                                                  = 1219;
	exports.ER_ERROR_WHEN_EXECUTING_COMMAND                                     = 1220;
	exports.ER_WRONG_USAGE                                                      = 1221;
	exports.ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT                                = 1222;
	exports.ER_CANT_UPDATE_WITH_READLOCK                                        = 1223;
	exports.ER_MIXING_NOT_ALLOWED                                               = 1224;
	exports.ER_DUP_ARGUMENT                                                     = 1225;
	exports.ER_USER_LIMIT_REACHED                                               = 1226;
	exports.ER_SPECIFIC_ACCESS_DENIED_ERROR                                     = 1227;
	exports.ER_LOCAL_VARIABLE                                                   = 1228;
	exports.ER_GLOBAL_VARIABLE                                                  = 1229;
	exports.ER_NO_DEFAULT                                                       = 1230;
	exports.ER_WRONG_VALUE_FOR_VAR                                              = 1231;
	exports.ER_WRONG_TYPE_FOR_VAR                                               = 1232;
	exports.ER_VAR_CANT_BE_READ                                                 = 1233;
	exports.ER_CANT_USE_OPTION_HERE                                             = 1234;
	exports.ER_NOT_SUPPORTED_YET                                                = 1235;
	exports.ER_MASTER_FATAL_ERROR_READING_BINLOG                                = 1236;
	exports.ER_SLAVE_IGNORED_TABLE                                              = 1237;
	exports.ER_INCORRECT_GLOBAL_LOCAL_VAR                                       = 1238;
	exports.ER_WRONG_FK_DEF                                                     = 1239;
	exports.ER_KEY_REF_DO_NOT_MATCH_TABLE_REF                                   = 1240;
	exports.ER_OPERAND_COLUMNS                                                  = 1241;
	exports.ER_SUBQUERY_NO_1_ROW                                                = 1242;
	exports.ER_UNKNOWN_STMT_HANDLER                                             = 1243;
	exports.ER_CORRUPT_HELP_DB                                                  = 1244;
	exports.ER_CYCLIC_REFERENCE                                                 = 1245;
	exports.ER_AUTO_CONVERT                                                     = 1246;
	exports.ER_ILLEGAL_REFERENCE                                                = 1247;
	exports.ER_DERIVED_MUST_HAVE_ALIAS                                          = 1248;
	exports.ER_SELECT_REDUCED                                                   = 1249;
	exports.ER_TABLENAME_NOT_ALLOWED_HERE                                       = 1250;
	exports.ER_NOT_SUPPORTED_AUTH_MODE                                          = 1251;
	exports.ER_SPATIAL_CANT_HAVE_NULL                                           = 1252;
	exports.ER_COLLATION_CHARSET_MISMATCH                                       = 1253;
	exports.ER_SLAVE_WAS_RUNNING                                                = 1254;
	exports.ER_SLAVE_WAS_NOT_RUNNING                                            = 1255;
	exports.ER_TOO_BIG_FOR_UNCOMPRESS                                           = 1256;
	exports.ER_ZLIB_Z_MEM_ERROR                                                 = 1257;
	exports.ER_ZLIB_Z_BUF_ERROR                                                 = 1258;
	exports.ER_ZLIB_Z_DATA_ERROR                                                = 1259;
	exports.ER_CUT_VALUE_GROUP_CONCAT                                           = 1260;
	exports.ER_WARN_TOO_FEW_RECORDS                                             = 1261;
	exports.ER_WARN_TOO_MANY_RECORDS                                            = 1262;
	exports.ER_WARN_NULL_TO_NOTNULL                                             = 1263;
	exports.ER_WARN_DATA_OUT_OF_RANGE                                           = 1264;
	exports.WARN_DATA_TRUNCATED                                                 = 1265;
	exports.ER_WARN_USING_OTHER_HANDLER                                         = 1266;
	exports.ER_CANT_AGGREGATE_2COLLATIONS                                       = 1267;
	exports.ER_DROP_USER                                                        = 1268;
	exports.ER_REVOKE_GRANTS                                                    = 1269;
	exports.ER_CANT_AGGREGATE_3COLLATIONS                                       = 1270;
	exports.ER_CANT_AGGREGATE_NCOLLATIONS                                       = 1271;
	exports.ER_VARIABLE_IS_NOT_STRUCT                                           = 1272;
	exports.ER_UNKNOWN_COLLATION                                                = 1273;
	exports.ER_SLAVE_IGNORED_SSL_PARAMS                                         = 1274;
	exports.ER_SERVER_IS_IN_SECURE_AUTH_MODE                                    = 1275;
	exports.ER_WARN_FIELD_RESOLVED                                              = 1276;
	exports.ER_BAD_SLAVE_UNTIL_COND                                             = 1277;
	exports.ER_MISSING_SKIP_SLAVE                                               = 1278;
	exports.ER_UNTIL_COND_IGNORED                                               = 1279;
	exports.ER_WRONG_NAME_FOR_INDEX                                             = 1280;
	exports.ER_WRONG_NAME_FOR_CATALOG                                           = 1281;
	exports.ER_WARN_QC_RESIZE                                                   = 1282;
	exports.ER_BAD_FT_COLUMN                                                    = 1283;
	exports.ER_UNKNOWN_KEY_CACHE                                                = 1284;
	exports.ER_WARN_HOSTNAME_WONT_WORK                                          = 1285;
	exports.ER_UNKNOWN_STORAGE_ENGINE                                           = 1286;
	exports.ER_WARN_DEPRECATED_SYNTAX                                           = 1287;
	exports.ER_NON_UPDATABLE_TABLE                                              = 1288;
	exports.ER_FEATURE_DISABLED                                                 = 1289;
	exports.ER_OPTION_PREVENTS_STATEMENT                                        = 1290;
	exports.ER_DUPLICATED_VALUE_IN_TYPE                                         = 1291;
	exports.ER_TRUNCATED_WRONG_VALUE                                            = 1292;
	exports.ER_TOO_MUCH_AUTO_TIMESTAMP_COLS                                     = 1293;
	exports.ER_INVALID_ON_UPDATE                                                = 1294;
	exports.ER_UNSUPPORTED_PS                                                   = 1295;
	exports.ER_GET_ERRMSG                                                       = 1296;
	exports.ER_GET_TEMPORARY_ERRMSG                                             = 1297;
	exports.ER_UNKNOWN_TIME_ZONE                                                = 1298;
	exports.ER_WARN_INVALID_TIMESTAMP                                           = 1299;
	exports.ER_INVALID_CHARACTER_STRING                                         = 1300;
	exports.ER_WARN_ALLOWED_PACKET_OVERFLOWED                                   = 1301;
	exports.ER_CONFLICTING_DECLARATIONS                                         = 1302;
	exports.ER_SP_NO_RECURSIVE_CREATE                                           = 1303;
	exports.ER_SP_ALREADY_EXISTS                                                = 1304;
	exports.ER_SP_DOES_NOT_EXIST                                                = 1305;
	exports.ER_SP_DROP_FAILED                                                   = 1306;
	exports.ER_SP_STORE_FAILED                                                  = 1307;
	exports.ER_SP_LILABEL_MISMATCH                                              = 1308;
	exports.ER_SP_LABEL_REDEFINE                                                = 1309;
	exports.ER_SP_LABEL_MISMATCH                                                = 1310;
	exports.ER_SP_UNINIT_VAR                                                    = 1311;
	exports.ER_SP_BADSELECT                                                     = 1312;
	exports.ER_SP_BADRETURN                                                     = 1313;
	exports.ER_SP_BADSTATEMENT                                                  = 1314;
	exports.ER_UPDATE_LOG_DEPRECATED_IGNORED                                    = 1315;
	exports.ER_UPDATE_LOG_DEPRECATED_TRANSLATED                                 = 1316;
	exports.ER_QUERY_INTERRUPTED                                                = 1317;
	exports.ER_SP_WRONG_NO_OF_ARGS                                              = 1318;
	exports.ER_SP_COND_MISMATCH                                                 = 1319;
	exports.ER_SP_NORETURN                                                      = 1320;
	exports.ER_SP_NORETURNEND                                                   = 1321;
	exports.ER_SP_BAD_CURSOR_QUERY                                              = 1322;
	exports.ER_SP_BAD_CURSOR_SELECT                                             = 1323;
	exports.ER_SP_CURSOR_MISMATCH                                               = 1324;
	exports.ER_SP_CURSOR_ALREADY_OPEN                                           = 1325;
	exports.ER_SP_CURSOR_NOT_OPEN                                               = 1326;
	exports.ER_SP_UNDECLARED_VAR                                                = 1327;
	exports.ER_SP_WRONG_NO_OF_FETCH_ARGS                                        = 1328;
	exports.ER_SP_FETCH_NO_DATA                                                 = 1329;
	exports.ER_SP_DUP_PARAM                                                     = 1330;
	exports.ER_SP_DUP_VAR                                                       = 1331;
	exports.ER_SP_DUP_COND                                                      = 1332;
	exports.ER_SP_DUP_CURS                                                      = 1333;
	exports.ER_SP_CANT_ALTER                                                    = 1334;
	exports.ER_SP_SUBSELECT_NYI                                                 = 1335;
	exports.ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG                                    = 1336;
	exports.ER_SP_VARCOND_AFTER_CURSHNDLR                                       = 1337;
	exports.ER_SP_CURSOR_AFTER_HANDLER                                          = 1338;
	exports.ER_SP_CASE_NOT_FOUND                                                = 1339;
	exports.ER_FPARSER_TOO_BIG_FILE                                             = 1340;
	exports.ER_FPARSER_BAD_HEADER                                               = 1341;
	exports.ER_FPARSER_EOF_IN_COMMENT                                           = 1342;
	exports.ER_FPARSER_ERROR_IN_PARAMETER                                       = 1343;
	exports.ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER                                 = 1344;
	exports.ER_VIEW_NO_EXPLAIN                                                  = 1345;
	exports.ER_FRM_UNKNOWN_TYPE                                                 = 1346;
	exports.ER_WRONG_OBJECT                                                     = 1347;
	exports.ER_NONUPDATEABLE_COLUMN                                             = 1348;
	exports.ER_VIEW_SELECT_DERIVED                                              = 1349;
	exports.ER_VIEW_SELECT_CLAUSE                                               = 1350;
	exports.ER_VIEW_SELECT_VARIABLE                                             = 1351;
	exports.ER_VIEW_SELECT_TMPTABLE                                             = 1352;
	exports.ER_VIEW_WRONG_LIST                                                  = 1353;
	exports.ER_WARN_VIEW_MERGE                                                  = 1354;
	exports.ER_WARN_VIEW_WITHOUT_KEY                                            = 1355;
	exports.ER_VIEW_INVALID                                                     = 1356;
	exports.ER_SP_NO_DROP_SP                                                    = 1357;
	exports.ER_SP_GOTO_IN_HNDLR                                                 = 1358;
	exports.ER_TRG_ALREADY_EXISTS                                               = 1359;
	exports.ER_TRG_DOES_NOT_EXIST                                               = 1360;
	exports.ER_TRG_ON_VIEW_OR_TEMP_TABLE                                        = 1361;
	exports.ER_TRG_CANT_CHANGE_ROW                                              = 1362;
	exports.ER_TRG_NO_SUCH_ROW_IN_TRG                                           = 1363;
	exports.ER_NO_DEFAULT_FOR_FIELD                                             = 1364;
	exports.ER_DIVISION_BY_ZERO                                                 = 1365;
	exports.ER_TRUNCATED_WRONG_VALUE_FOR_FIELD                                  = 1366;
	exports.ER_ILLEGAL_VALUE_FOR_TYPE                                           = 1367;
	exports.ER_VIEW_NONUPD_CHECK                                                = 1368;
	exports.ER_VIEW_CHECK_FAILED                                                = 1369;
	exports.ER_PROCACCESS_DENIED_ERROR                                          = 1370;
	exports.ER_RELAY_LOG_FAIL                                                   = 1371;
	exports.ER_PASSWD_LENGTH                                                    = 1372;
	exports.ER_UNKNOWN_TARGET_BINLOG                                            = 1373;
	exports.ER_IO_ERR_LOG_INDEX_READ                                            = 1374;
	exports.ER_BINLOG_PURGE_PROHIBITED                                          = 1375;
	exports.ER_FSEEK_FAIL                                                       = 1376;
	exports.ER_BINLOG_PURGE_FATAL_ERR                                           = 1377;
	exports.ER_LOG_IN_USE                                                       = 1378;
	exports.ER_LOG_PURGE_UNKNOWN_ERR                                            = 1379;
	exports.ER_RELAY_LOG_INIT                                                   = 1380;
	exports.ER_NO_BINARY_LOGGING                                                = 1381;
	exports.ER_RESERVED_SYNTAX                                                  = 1382;
	exports.ER_WSAS_FAILED                                                      = 1383;
	exports.ER_DIFF_GROUPS_PROC                                                 = 1384;
	exports.ER_NO_GROUP_FOR_PROC                                                = 1385;
	exports.ER_ORDER_WITH_PROC                                                  = 1386;
	exports.ER_LOGGING_PROHIBIT_CHANGING_OF                                     = 1387;
	exports.ER_NO_FILE_MAPPING                                                  = 1388;
	exports.ER_WRONG_MAGIC                                                      = 1389;
	exports.ER_PS_MANY_PARAM                                                    = 1390;
	exports.ER_KEY_PART_0                                                       = 1391;
	exports.ER_VIEW_CHECKSUM                                                    = 1392;
	exports.ER_VIEW_MULTIUPDATE                                                 = 1393;
	exports.ER_VIEW_NO_INSERT_FIELD_LIST                                        = 1394;
	exports.ER_VIEW_DELETE_MERGE_VIEW                                           = 1395;
	exports.ER_CANNOT_USER                                                      = 1396;
	exports.ER_XAER_NOTA                                                        = 1397;
	exports.ER_XAER_INVAL                                                       = 1398;
	exports.ER_XAER_RMFAIL                                                      = 1399;
	exports.ER_XAER_OUTSIDE                                                     = 1400;
	exports.ER_XAER_RMERR                                                       = 1401;
	exports.ER_XA_RBROLLBACK                                                    = 1402;
	exports.ER_NONEXISTING_PROC_GRANT                                           = 1403;
	exports.ER_PROC_AUTO_GRANT_FAIL                                             = 1404;
	exports.ER_PROC_AUTO_REVOKE_FAIL                                            = 1405;
	exports.ER_DATA_TOO_LONG                                                    = 1406;
	exports.ER_SP_BAD_SQLSTATE                                                  = 1407;
	exports.ER_STARTUP                                                          = 1408;
	exports.ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR                                 = 1409;
	exports.ER_CANT_CREATE_USER_WITH_GRANT                                      = 1410;
	exports.ER_WRONG_VALUE_FOR_TYPE                                             = 1411;
	exports.ER_TABLE_DEF_CHANGED                                                = 1412;
	exports.ER_SP_DUP_HANDLER                                                   = 1413;
	exports.ER_SP_NOT_VAR_ARG                                                   = 1414;
	exports.ER_SP_NO_RETSET                                                     = 1415;
	exports.ER_CANT_CREATE_GEOMETRY_OBJECT                                      = 1416;
	exports.ER_FAILED_ROUTINE_BREAK_BINLOG                                      = 1417;
	exports.ER_BINLOG_UNSAFE_ROUTINE                                            = 1418;
	exports.ER_BINLOG_CREATE_ROUTINE_NEED_SUPER                                 = 1419;
	exports.ER_EXEC_STMT_WITH_OPEN_CURSOR                                       = 1420;
	exports.ER_STMT_HAS_NO_OPEN_CURSOR                                          = 1421;
	exports.ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG                                  = 1422;
	exports.ER_NO_DEFAULT_FOR_VIEW_FIELD                                        = 1423;
	exports.ER_SP_NO_RECURSION                                                  = 1424;
	exports.ER_TOO_BIG_SCALE                                                    = 1425;
	exports.ER_TOO_BIG_PRECISION                                                = 1426;
	exports.ER_M_BIGGER_THAN_D                                                  = 1427;
	exports.ER_WRONG_LOCK_OF_SYSTEM_TABLE                                       = 1428;
	exports.ER_CONNECT_TO_FOREIGN_DATA_SOURCE                                   = 1429;
	exports.ER_QUERY_ON_FOREIGN_DATA_SOURCE                                     = 1430;
	exports.ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST                                 = 1431;
	exports.ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE                          = 1432;
	exports.ER_FOREIGN_DATA_STRING_INVALID                                      = 1433;
	exports.ER_CANT_CREATE_FEDERATED_TABLE                                      = 1434;
	exports.ER_TRG_IN_WRONG_SCHEMA                                              = 1435;
	exports.ER_STACK_OVERRUN_NEED_MORE                                          = 1436;
	exports.ER_TOO_LONG_BODY                                                    = 1437;
	exports.ER_WARN_CANT_DROP_DEFAULT_KEYCACHE                                  = 1438;
	exports.ER_TOO_BIG_DISPLAYWIDTH                                             = 1439;
	exports.ER_XAER_DUPID                                                       = 1440;
	exports.ER_DATETIME_FUNCTION_OVERFLOW                                       = 1441;
	exports.ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG                              = 1442;
	exports.ER_VIEW_PREVENT_UPDATE                                              = 1443;
	exports.ER_PS_NO_RECURSION                                                  = 1444;
	exports.ER_SP_CANT_SET_AUTOCOMMIT                                           = 1445;
	exports.ER_MALFORMED_DEFINER                                                = 1446;
	exports.ER_VIEW_FRM_NO_USER                                                 = 1447;
	exports.ER_VIEW_OTHER_USER                                                  = 1448;
	exports.ER_NO_SUCH_USER                                                     = 1449;
	exports.ER_FORBID_SCHEMA_CHANGE                                             = 1450;
	exports.ER_ROW_IS_REFERENCED_2                                              = 1451;
	exports.ER_NO_REFERENCED_ROW_2                                              = 1452;
	exports.ER_SP_BAD_VAR_SHADOW                                                = 1453;
	exports.ER_TRG_NO_DEFINER                                                   = 1454;
	exports.ER_OLD_FILE_FORMAT                                                  = 1455;
	exports.ER_SP_RECURSION_LIMIT                                               = 1456;
	exports.ER_SP_PROC_TABLE_CORRUPT                                            = 1457;
	exports.ER_SP_WRONG_NAME                                                    = 1458;
	exports.ER_TABLE_NEEDS_UPGRADE                                              = 1459;
	exports.ER_SP_NO_AGGREGATE                                                  = 1460;
	exports.ER_MAX_PREPARED_STMT_COUNT_REACHED                                  = 1461;
	exports.ER_VIEW_RECURSIVE                                                   = 1462;
	exports.ER_NON_GROUPING_FIELD_USED                                          = 1463;
	exports.ER_TABLE_CANT_HANDLE_SPKEYS                                         = 1464;
	exports.ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA                                     = 1465;
	exports.ER_REMOVED_SPACES                                                   = 1466;
	exports.ER_AUTOINC_READ_FAILED                                              = 1467;
	exports.ER_USERNAME                                                         = 1468;
	exports.ER_HOSTNAME                                                         = 1469;
	exports.ER_WRONG_STRING_LENGTH                                              = 1470;
	exports.ER_NON_INSERTABLE_TABLE                                             = 1471;
	exports.ER_ADMIN_WRONG_MRG_TABLE                                            = 1472;
	exports.ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT                             = 1473;
	exports.ER_NAME_BECOMES_EMPTY                                               = 1474;
	exports.ER_AMBIGUOUS_FIELD_TERM                                             = 1475;
	exports.ER_FOREIGN_SERVER_EXISTS                                            = 1476;
	exports.ER_FOREIGN_SERVER_DOESNT_EXIST                                      = 1477;
	exports.ER_ILLEGAL_HA_CREATE_OPTION                                         = 1478;
	exports.ER_PARTITION_REQUIRES_VALUES_ERROR                                  = 1479;
	exports.ER_PARTITION_WRONG_VALUES_ERROR                                     = 1480;
	exports.ER_PARTITION_MAXVALUE_ERROR                                         = 1481;
	exports.ER_PARTITION_SUBPARTITION_ERROR                                     = 1482;
	exports.ER_PARTITION_SUBPART_MIX_ERROR                                      = 1483;
	exports.ER_PARTITION_WRONG_NO_PART_ERROR                                    = 1484;
	exports.ER_PARTITION_WRONG_NO_SUBPART_ERROR                                 = 1485;
	exports.ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR                               = 1486;
	exports.ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR                             = 1487;
	exports.ER_FIELD_NOT_FOUND_PART_ERROR                                       = 1488;
	exports.ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR                                = 1489;
	exports.ER_INCONSISTENT_PARTITION_INFO_ERROR                                = 1490;
	exports.ER_PARTITION_FUNC_NOT_ALLOWED_ERROR                                 = 1491;
	exports.ER_PARTITIONS_MUST_BE_DEFINED_ERROR                                 = 1492;
	exports.ER_RANGE_NOT_INCREASING_ERROR                                       = 1493;
	exports.ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR                             = 1494;
	exports.ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR                            = 1495;
	exports.ER_PARTITION_ENTRY_ERROR                                            = 1496;
	exports.ER_MIX_HANDLER_ERROR                                                = 1497;
	exports.ER_PARTITION_NOT_DEFINED_ERROR                                      = 1498;
	exports.ER_TOO_MANY_PARTITIONS_ERROR                                        = 1499;
	exports.ER_SUBPARTITION_ERROR                                               = 1500;
	exports.ER_CANT_CREATE_HANDLER_FILE                                         = 1501;
	exports.ER_BLOB_FIELD_IN_PART_FUNC_ERROR                                    = 1502;
	exports.ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF                                 = 1503;
	exports.ER_NO_PARTS_ERROR                                                   = 1504;
	exports.ER_PARTITION_MGMT_ON_NONPARTITIONED                                 = 1505;
	exports.ER_FOREIGN_KEY_ON_PARTITIONED                                       = 1506;
	exports.ER_DROP_PARTITION_NON_EXISTENT                                      = 1507;
	exports.ER_DROP_LAST_PARTITION                                              = 1508;
	exports.ER_COALESCE_ONLY_ON_HASH_PARTITION                                  = 1509;
	exports.ER_REORG_HASH_ONLY_ON_SAME_NO                                       = 1510;
	exports.ER_REORG_NO_PARAM_ERROR                                             = 1511;
	exports.ER_ONLY_ON_RANGE_LIST_PARTITION                                     = 1512;
	exports.ER_ADD_PARTITION_SUBPART_ERROR                                      = 1513;
	exports.ER_ADD_PARTITION_NO_NEW_PARTITION                                   = 1514;
	exports.ER_COALESCE_PARTITION_NO_PARTITION                                  = 1515;
	exports.ER_REORG_PARTITION_NOT_EXIST                                        = 1516;
	exports.ER_SAME_NAME_PARTITION                                              = 1517;
	exports.ER_NO_BINLOG_ERROR                                                  = 1518;
	exports.ER_CONSECUTIVE_REORG_PARTITIONS                                     = 1519;
	exports.ER_REORG_OUTSIDE_RANGE                                              = 1520;
	exports.ER_PARTITION_FUNCTION_FAILURE                                       = 1521;
	exports.ER_PART_STATE_ERROR                                                 = 1522;
	exports.ER_LIMITED_PART_RANGE                                               = 1523;
	exports.ER_PLUGIN_IS_NOT_LOADED                                             = 1524;
	exports.ER_WRONG_VALUE                                                      = 1525;
	exports.ER_NO_PARTITION_FOR_GIVEN_VALUE                                     = 1526;
	exports.ER_FILEGROUP_OPTION_ONLY_ONCE                                       = 1527;
	exports.ER_CREATE_FILEGROUP_FAILED                                          = 1528;
	exports.ER_DROP_FILEGROUP_FAILED                                            = 1529;
	exports.ER_TABLESPACE_AUTO_EXTEND_ERROR                                     = 1530;
	exports.ER_WRONG_SIZE_NUMBER                                                = 1531;
	exports.ER_SIZE_OVERFLOW_ERROR                                              = 1532;
	exports.ER_ALTER_FILEGROUP_FAILED                                           = 1533;
	exports.ER_BINLOG_ROW_LOGGING_FAILED                                        = 1534;
	exports.ER_BINLOG_ROW_WRONG_TABLE_DEF                                       = 1535;
	exports.ER_BINLOG_ROW_RBR_TO_SBR                                            = 1536;
	exports.ER_EVENT_ALREADY_EXISTS                                             = 1537;
	exports.ER_EVENT_STORE_FAILED                                               = 1538;
	exports.ER_EVENT_DOES_NOT_EXIST                                             = 1539;
	exports.ER_EVENT_CANT_ALTER                                                 = 1540;
	exports.ER_EVENT_DROP_FAILED                                                = 1541;
	exports.ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG                           = 1542;
	exports.ER_EVENT_ENDS_BEFORE_STARTS                                         = 1543;
	exports.ER_EVENT_EXEC_TIME_IN_THE_PAST                                      = 1544;
	exports.ER_EVENT_OPEN_TABLE_FAILED                                          = 1545;
	exports.ER_EVENT_NEITHER_M_EXPR_NOR_M_AT                                    = 1546;
	exports.ER_COL_COUNT_DOESNT_MATCH_CORRUPTED                                 = 1547;
	exports.ER_CANNOT_LOAD_FROM_TABLE                                           = 1548;
	exports.ER_EVENT_CANNOT_DELETE                                              = 1549;
	exports.ER_EVENT_COMPILE_ERROR                                              = 1550;
	exports.ER_EVENT_SAME_NAME                                                  = 1551;
	exports.ER_EVENT_DATA_TOO_LONG                                              = 1552;
	exports.ER_DROP_INDEX_FK                                                    = 1553;
	exports.ER_WARN_DEPRECATED_SYNTAX_WITH_VER                                  = 1554;
	exports.ER_CANT_WRITE_LOCK_LOG_TABLE                                        = 1555;
	exports.ER_CANT_LOCK_LOG_TABLE                                              = 1556;
	exports.ER_FOREIGN_DUPLICATE_KEY                                            = 1557;
	exports.ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE                             = 1558;
	exports.ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR                            = 1559;
	exports.ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT                    = 1560;
	exports.ER_NDB_CANT_SWITCH_BINLOG_FORMAT                                    = 1561;
	exports.ER_PARTITION_NO_TEMPORARY                                           = 1562;
	exports.ER_PARTITION_CONST_DOMAIN_ERROR                                     = 1563;
	exports.ER_PARTITION_FUNCTION_IS_NOT_ALLOWED                                = 1564;
	exports.ER_DDL_LOG_ERROR                                                    = 1565;
	exports.ER_NULL_IN_VALUES_LESS_THAN                                         = 1566;
	exports.ER_WRONG_PARTITION_NAME                                             = 1567;
	exports.ER_CANT_CHANGE_TX_CHARACTERISTICS                                   = 1568;
	exports.ER_DUP_ENTRY_AUTOINCREMENT_CASE                                     = 1569;
	exports.ER_EVENT_MODIFY_QUEUE_ERROR                                         = 1570;
	exports.ER_EVENT_SET_VAR_ERROR                                              = 1571;
	exports.ER_PARTITION_MERGE_ERROR                                            = 1572;
	exports.ER_CANT_ACTIVATE_LOG                                                = 1573;
	exports.ER_RBR_NOT_AVAILABLE                                                = 1574;
	exports.ER_BASE64_DECODE_ERROR                                              = 1575;
	exports.ER_EVENT_RECURSION_FORBIDDEN                                        = 1576;
	exports.ER_EVENTS_DB_ERROR                                                  = 1577;
	exports.ER_ONLY_INTEGERS_ALLOWED                                            = 1578;
	exports.ER_UNSUPORTED_LOG_ENGINE                                            = 1579;
	exports.ER_BAD_LOG_STATEMENT                                                = 1580;
	exports.ER_CANT_RENAME_LOG_TABLE                                            = 1581;
	exports.ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT                                   = 1582;
	exports.ER_WRONG_PARAMETERS_TO_NATIVE_FCT                                   = 1583;
	exports.ER_WRONG_PARAMETERS_TO_STORED_FCT                                   = 1584;
	exports.ER_NATIVE_FCT_NAME_COLLISION                                        = 1585;
	exports.ER_DUP_ENTRY_WITH_KEY_NAME                                          = 1586;
	exports.ER_BINLOG_PURGE_EMFILE                                              = 1587;
	exports.ER_EVENT_CANNOT_CREATE_IN_THE_PAST                                  = 1588;
	exports.ER_EVENT_CANNOT_ALTER_IN_THE_PAST                                   = 1589;
	exports.ER_SLAVE_INCIDENT                                                   = 1590;
	exports.ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT                              = 1591;
	exports.ER_BINLOG_UNSAFE_STATEMENT                                          = 1592;
	exports.ER_SLAVE_FATAL_ERROR                                                = 1593;
	exports.ER_SLAVE_RELAY_LOG_READ_FAILURE                                     = 1594;
	exports.ER_SLAVE_RELAY_LOG_WRITE_FAILURE                                    = 1595;
	exports.ER_SLAVE_CREATE_EVENT_FAILURE                                       = 1596;
	exports.ER_SLAVE_MASTER_COM_FAILURE                                         = 1597;
	exports.ER_BINLOG_LOGGING_IMPOSSIBLE                                        = 1598;
	exports.ER_VIEW_NO_CREATION_CTX                                             = 1599;
	exports.ER_VIEW_INVALID_CREATION_CTX                                        = 1600;
	exports.ER_SR_INVALID_CREATION_CTX                                          = 1601;
	exports.ER_TRG_CORRUPTED_FILE                                               = 1602;
	exports.ER_TRG_NO_CREATION_CTX                                              = 1603;
	exports.ER_TRG_INVALID_CREATION_CTX                                         = 1604;
	exports.ER_EVENT_INVALID_CREATION_CTX                                       = 1605;
	exports.ER_TRG_CANT_OPEN_TABLE                                              = 1606;
	exports.ER_CANT_CREATE_SROUTINE                                             = 1607;
	exports.ER_NEVER_USED                                                       = 1608;
	exports.ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT              = 1609;
	exports.ER_SLAVE_CORRUPT_EVENT                                              = 1610;
	exports.ER_LOAD_DATA_INVALID_COLUMN                                         = 1611;
	exports.ER_LOG_PURGE_NO_FILE                                                = 1612;
	exports.ER_XA_RBTIMEOUT                                                     = 1613;
	exports.ER_XA_RBDEADLOCK                                                    = 1614;
	exports.ER_NEED_REPREPARE                                                   = 1615;
	exports.ER_DELAYED_NOT_SUPPORTED                                            = 1616;
	exports.WARN_NO_MASTER_INFO                                                 = 1617;
	exports.WARN_OPTION_IGNORED                                                 = 1618;
	exports.WARN_PLUGIN_DELETE_BUILTIN                                          = 1619;
	exports.WARN_PLUGIN_BUSY                                                    = 1620;
	exports.ER_VARIABLE_IS_READONLY                                             = 1621;
	exports.ER_WARN_ENGINE_TRANSACTION_ROLLBACK                                 = 1622;
	exports.ER_SLAVE_HEARTBEAT_FAILURE                                          = 1623;
	exports.ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE                               = 1624;
	exports.ER_NDB_REPLICATION_SCHEMA_ERROR                                     = 1625;
	exports.ER_CONFLICT_FN_PARSE_ERROR                                          = 1626;
	exports.ER_EXCEPTIONS_WRITE_ERROR                                           = 1627;
	exports.ER_TOO_LONG_TABLE_COMMENT                                           = 1628;
	exports.ER_TOO_LONG_FIELD_COMMENT                                           = 1629;
	exports.ER_FUNC_INEXISTENT_NAME_COLLISION                                   = 1630;
	exports.ER_DATABASE_NAME                                                    = 1631;
	exports.ER_TABLE_NAME                                                       = 1632;
	exports.ER_PARTITION_NAME                                                   = 1633;
	exports.ER_SUBPARTITION_NAME                                                = 1634;
	exports.ER_TEMPORARY_NAME                                                   = 1635;
	exports.ER_RENAMED_NAME                                                     = 1636;
	exports.ER_TOO_MANY_CONCURRENT_TRXS                                         = 1637;
	exports.WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED                            = 1638;
	exports.ER_DEBUG_SYNC_TIMEOUT                                               = 1639;
	exports.ER_DEBUG_SYNC_HIT_LIMIT                                             = 1640;
	exports.ER_DUP_SIGNAL_SET                                                   = 1641;
	exports.ER_SIGNAL_WARN                                                      = 1642;
	exports.ER_SIGNAL_NOT_FOUND                                                 = 1643;
	exports.ER_SIGNAL_EXCEPTION                                                 = 1644;
	exports.ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER                                  = 1645;
	exports.ER_SIGNAL_BAD_CONDITION_TYPE                                        = 1646;
	exports.WARN_COND_ITEM_TRUNCATED                                            = 1647;
	exports.ER_COND_ITEM_TOO_LONG                                               = 1648;
	exports.ER_UNKNOWN_LOCALE                                                   = 1649;
	exports.ER_SLAVE_IGNORE_SERVER_IDS                                          = 1650;
	exports.ER_QUERY_CACHE_DISABLED                                             = 1651;
	exports.ER_SAME_NAME_PARTITION_FIELD                                        = 1652;
	exports.ER_PARTITION_COLUMN_LIST_ERROR                                      = 1653;
	exports.ER_WRONG_TYPE_COLUMN_VALUE_ERROR                                    = 1654;
	exports.ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR                             = 1655;
	exports.ER_MAXVALUE_IN_VALUES_IN                                            = 1656;
	exports.ER_TOO_MANY_VALUES_ERROR                                            = 1657;
	exports.ER_ROW_SINGLE_PARTITION_FIELD_ERROR                                 = 1658;
	exports.ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD                        = 1659;
	exports.ER_PARTITION_FIELDS_TOO_LONG                                        = 1660;
	exports.ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE                                = 1661;
	exports.ER_BINLOG_ROW_MODE_AND_STMT_ENGINE                                  = 1662;
	exports.ER_BINLOG_UNSAFE_AND_STMT_ENGINE                                    = 1663;
	exports.ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE                             = 1664;
	exports.ER_BINLOG_STMT_MODE_AND_ROW_ENGINE                                  = 1665;
	exports.ER_BINLOG_ROW_INJECTION_AND_STMT_MODE                               = 1666;
	exports.ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE                  = 1667;
	exports.ER_BINLOG_UNSAFE_LIMIT                                              = 1668;
	exports.ER_BINLOG_UNSAFE_INSERT_DELAYED                                     = 1669;
	exports.ER_BINLOG_UNSAFE_SYSTEM_TABLE                                       = 1670;
	exports.ER_BINLOG_UNSAFE_AUTOINC_COLUMNS                                    = 1671;
	exports.ER_BINLOG_UNSAFE_UDF                                                = 1672;
	exports.ER_BINLOG_UNSAFE_SYSTEM_VARIABLE                                    = 1673;
	exports.ER_BINLOG_UNSAFE_SYSTEM_FUNCTION                                    = 1674;
	exports.ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS                               = 1675;
	exports.ER_MESSAGE_AND_STATEMENT                                            = 1676;
	exports.ER_SLAVE_CONVERSION_FAILED                                          = 1677;
	exports.ER_SLAVE_CANT_CREATE_CONVERSION                                     = 1678;
	exports.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT                 = 1679;
	exports.ER_PATH_LENGTH                                                      = 1680;
	exports.ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT                            = 1681;
	exports.ER_WRONG_NATIVE_TABLE_STRUCTURE                                     = 1682;
	exports.ER_WRONG_PERFSCHEMA_USAGE                                           = 1683;
	exports.ER_WARN_I_S_SKIPPED_TABLE                                           = 1684;
	exports.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT                 = 1685;
	exports.ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT                    = 1686;
	exports.ER_SPATIAL_MUST_HAVE_GEOM_COL                                       = 1687;
	exports.ER_TOO_LONG_INDEX_COMMENT                                           = 1688;
	exports.ER_LOCK_ABORTED                                                     = 1689;
	exports.ER_DATA_OUT_OF_RANGE                                                = 1690;
	exports.ER_WRONG_SPVAR_TYPE_IN_LIMIT                                        = 1691;
	exports.ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE           = 1692;
	exports.ER_BINLOG_UNSAFE_MIXED_STATEMENT                                    = 1693;
	exports.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN                   = 1694;
	exports.ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN                      = 1695;
	exports.ER_FAILED_READ_FROM_PAR_FILE                                        = 1696;
	exports.ER_VALUES_IS_NOT_INT_TYPE_ERROR                                     = 1697;
	exports.ER_ACCESS_DENIED_NO_PASSWORD_ERROR                                  = 1698;
	exports.ER_SET_PASSWORD_AUTH_PLUGIN                                         = 1699;
	exports.ER_GRANT_PLUGIN_USER_EXISTS                                         = 1700;
	exports.ER_TRUNCATE_ILLEGAL_FK                                              = 1701;
	exports.ER_PLUGIN_IS_PERMANENT                                              = 1702;
	exports.ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN                           = 1703;
	exports.ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX                           = 1704;
	exports.ER_STMT_CACHE_FULL                                                  = 1705;
	exports.ER_MULTI_UPDATE_KEY_CONFLICT                                        = 1706;
	exports.ER_TABLE_NEEDS_REBUILD                                              = 1707;
	exports.WARN_OPTION_BELOW_LIMIT                                             = 1708;
	exports.ER_INDEX_COLUMN_TOO_LONG                                            = 1709;
	exports.ER_ERROR_IN_TRIGGER_BODY                                            = 1710;
	exports.ER_ERROR_IN_UNKNOWN_TRIGGER_BODY                                    = 1711;
	exports.ER_INDEX_CORRUPT                                                    = 1712;
	exports.ER_UNDO_RECORD_TOO_BIG                                              = 1713;
	exports.ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT                               = 1714;
	exports.ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE                               = 1715;
	exports.ER_BINLOG_UNSAFE_REPLACE_SELECT                                     = 1716;
	exports.ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT                               = 1717;
	exports.ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT                              = 1718;
	exports.ER_BINLOG_UNSAFE_UPDATE_IGNORE                                      = 1719;
	exports.ER_PLUGIN_NO_UNINSTALL                                              = 1720;
	exports.ER_PLUGIN_NO_INSTALL                                                = 1721;
	exports.ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT                               = 1722;
	exports.ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC                              = 1723;
	exports.ER_BINLOG_UNSAFE_INSERT_TWO_KEYS                                    = 1724;
	exports.ER_TABLE_IN_FK_CHECK                                                = 1725;
	exports.ER_UNSUPPORTED_ENGINE                                               = 1726;
	exports.ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST                                  = 1727;
	exports.ER_CANNOT_LOAD_FROM_TABLE_V2                                        = 1728;
	exports.ER_MASTER_DELAY_VALUE_OUT_OF_RANGE                                  = 1729;
	exports.ER_ONLY_FD_AND_RBR_EVENTS_ALLOWED_IN_BINLOG_STATEMENT               = 1730;
	exports.ER_PARTITION_EXCHANGE_DIFFERENT_OPTION                              = 1731;
	exports.ER_PARTITION_EXCHANGE_PART_TABLE                                    = 1732;
	exports.ER_PARTITION_EXCHANGE_TEMP_TABLE                                    = 1733;
	exports.ER_PARTITION_INSTEAD_OF_SUBPARTITION                                = 1734;
	exports.ER_UNKNOWN_PARTITION                                                = 1735;
	exports.ER_TABLES_DIFFERENT_METADATA                                        = 1736;
	exports.ER_ROW_DOES_NOT_MATCH_PARTITION                                     = 1737;
	exports.ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX                               = 1738;
	exports.ER_WARN_INDEX_NOT_APPLICABLE                                        = 1739;
	exports.ER_PARTITION_EXCHANGE_FOREIGN_KEY                                   = 1740;
	exports.ER_NO_SUCH_KEY_VALUE                                                = 1741;
	exports.ER_RPL_INFO_DATA_TOO_LONG                                           = 1742;
	exports.ER_NETWORK_READ_EVENT_CHECKSUM_FAILURE                              = 1743;
	exports.ER_BINLOG_READ_EVENT_CHECKSUM_FAILURE                               = 1744;
	exports.ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX                          = 1745;
	exports.ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT                         = 1746;
	exports.ER_PARTITION_CLAUSE_ON_NONPARTITIONED                               = 1747;
	exports.ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET                           = 1748;
	exports.ER_NO_SUCH_PARTITION                                                = 1749;
	exports.ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE                               = 1750;
	exports.ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE            = 1751;
	exports.ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE            = 1752;
	exports.ER_MTS_FEATURE_IS_NOT_SUPPORTED                                     = 1753;
	exports.ER_MTS_UPDATED_DBS_GREATER_MAX                                      = 1754;
	exports.ER_MTS_CANT_PARALLEL                                                = 1755;
	exports.ER_MTS_INCONSISTENT_DATA                                            = 1756;
	exports.ER_FULLTEXT_NOT_SUPPORTED_WITH_PARTITIONING                         = 1757;
	exports.ER_DA_INVALID_CONDITION_NUMBER                                      = 1758;
	exports.ER_INSECURE_PLAIN_TEXT                                              = 1759;
	exports.ER_INSECURE_CHANGE_MASTER                                           = 1760;
	exports.ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO                            = 1761;
	exports.ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO                         = 1762;
	exports.ER_SQLTHREAD_WITH_SECURE_SLAVE                                      = 1763;
	exports.ER_TABLE_HAS_NO_FT                                                  = 1764;
	exports.ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER                           = 1765;
	exports.ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION                             = 1766;
	exports.ER_GTID_NEXT_IS_NOT_IN_GTID_NEXT_LIST                               = 1767;
	exports.ER_CANT_CHANGE_GTID_NEXT_IN_TRANSACTION_WHEN_GTID_NEXT_LIST_IS_NULL = 1768;
	exports.ER_SET_STATEMENT_CANNOT_INVOKE_FUNCTION                             = 1769;
	exports.ER_GTID_NEXT_CANT_BE_AUTOMATIC_IF_GTID_NEXT_LIST_IS_NON_NULL        = 1770;
	exports.ER_SKIPPING_LOGGED_TRANSACTION                                      = 1771;
	exports.ER_MALFORMED_GTID_SET_SPECIFICATION                                 = 1772;
	exports.ER_MALFORMED_GTID_SET_ENCODING                                      = 1773;
	exports.ER_MALFORMED_GTID_SPECIFICATION                                     = 1774;
	exports.ER_GNO_EXHAUSTED                                                    = 1775;
	exports.ER_BAD_SLAVE_AUTO_POSITION                                          = 1776;
	exports.ER_AUTO_POSITION_REQUIRES_GTID_MODE_ON                              = 1777;
	exports.ER_CANT_DO_IMPLICIT_COMMIT_IN_TRX_WHEN_GTID_NEXT_IS_SET             = 1778;
	exports.ER_GTID_MODE_2_OR_3_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON            = 1779;
	exports.ER_GTID_MODE_REQUIRES_BINLOG                                        = 1780;
	exports.ER_CANT_SET_GTID_NEXT_TO_GTID_WHEN_GTID_MODE_IS_OFF                 = 1781;
	exports.ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON             = 1782;
	exports.ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF        = 1783;
	exports.ER_FOUND_GTID_EVENT_WHEN_GTID_MODE_IS_OFF                           = 1784;
	exports.ER_GTID_UNSAFE_NON_TRANSACTIONAL_TABLE                              = 1785;
	exports.ER_GTID_UNSAFE_CREATE_SELECT                                        = 1786;
	exports.ER_GTID_UNSAFE_CREATE_DROP_TEMPORARY_TABLE_IN_TRANSACTION           = 1787;
	exports.ER_GTID_MODE_CAN_ONLY_CHANGE_ONE_STEP_AT_A_TIME                     = 1788;
	exports.ER_MASTER_HAS_PURGED_REQUIRED_GTIDS                                 = 1789;
	exports.ER_CANT_SET_GTID_NEXT_WHEN_OWNING_GTID                              = 1790;
	exports.ER_UNKNOWN_EXPLAIN_FORMAT                                           = 1791;
	exports.ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION                            = 1792;
	exports.ER_TOO_LONG_TABLE_PARTITION_COMMENT                                 = 1793;
	exports.ER_SLAVE_CONFIGURATION                                              = 1794;
	exports.ER_INNODB_FT_LIMIT                                                  = 1795;
	exports.ER_INNODB_NO_FT_TEMP_TABLE                                          = 1796;
	exports.ER_INNODB_FT_WRONG_DOCID_COLUMN                                     = 1797;
	exports.ER_INNODB_FT_WRONG_DOCID_INDEX                                      = 1798;
	exports.ER_INNODB_ONLINE_LOG_TOO_BIG                                        = 1799;
	exports.ER_UNKNOWN_ALTER_ALGORITHM                                          = 1800;
	exports.ER_UNKNOWN_ALTER_LOCK                                               = 1801;
	exports.ER_MTS_CHANGE_MASTER_CANT_RUN_WITH_GAPS                             = 1802;
	exports.ER_MTS_RECOVERY_FAILURE                                             = 1803;
	exports.ER_MTS_RESET_WORKERS                                                = 1804;
	exports.ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2                              = 1805;
	exports.ER_SLAVE_SILENT_RETRY_TRANSACTION                                   = 1806;
	exports.ER_DISCARD_FK_CHECKS_RUNNING                                        = 1807;
	exports.ER_TABLE_SCHEMA_MISMATCH                                            = 1808;
	exports.ER_TABLE_IN_SYSTEM_TABLESPACE                                       = 1809;
	exports.ER_IO_READ_ERROR                                                    = 1810;
	exports.ER_IO_WRITE_ERROR                                                   = 1811;
	exports.ER_TABLESPACE_MISSING                                               = 1812;
	exports.ER_TABLESPACE_EXISTS                                                = 1813;
	exports.ER_TABLESPACE_DISCARDED                                             = 1814;
	exports.ER_INTERNAL_ERROR                                                   = 1815;
	exports.ER_INNODB_IMPORT_ERROR                                              = 1816;
	exports.ER_INNODB_INDEX_CORRUPT                                             = 1817;
	exports.ER_INVALID_YEAR_COLUMN_LENGTH                                       = 1818;
	exports.ER_NOT_VALID_PASSWORD                                               = 1819;
	exports.ER_MUST_CHANGE_PASSWORD                                             = 1820;
	exports.ER_FK_NO_INDEX_CHILD                                                = 1821;
	exports.ER_FK_NO_INDEX_PARENT                                               = 1822;
	exports.ER_FK_FAIL_ADD_SYSTEM                                               = 1823;
	exports.ER_FK_CANNOT_OPEN_PARENT                                            = 1824;
	exports.ER_FK_INCORRECT_OPTION                                              = 1825;
	exports.ER_FK_DUP_NAME                                                      = 1826;
	exports.ER_PASSWORD_FORMAT                                                  = 1827;
	exports.ER_FK_COLUMN_CANNOT_DROP                                            = 1828;
	exports.ER_FK_COLUMN_CANNOT_DROP_CHILD                                      = 1829;
	exports.ER_FK_COLUMN_NOT_NULL                                               = 1830;
	exports.ER_DUP_INDEX                                                        = 1831;
	exports.ER_FK_COLUMN_CANNOT_CHANGE                                          = 1832;
	exports.ER_FK_COLUMN_CANNOT_CHANGE_CHILD                                    = 1833;
	exports.ER_FK_CANNOT_DELETE_PARENT                                          = 1834;
	exports.ER_MALFORMED_PACKET                                                 = 1835;
	exports.ER_READ_ONLY_MODE                                                   = 1836;
	exports.ER_GTID_NEXT_TYPE_UNDEFINED_GROUP                                   = 1837;
	exports.ER_VARIABLE_NOT_SETTABLE_IN_SP                                      = 1838;
	exports.ER_CANT_SET_GTID_PURGED_WHEN_GTID_MODE_IS_OFF                       = 1839;
	exports.ER_CANT_SET_GTID_PURGED_WHEN_GTID_EXECUTED_IS_NOT_EMPTY             = 1840;
	exports.ER_CANT_SET_GTID_PURGED_WHEN_OWNED_GTIDS_IS_NOT_EMPTY               = 1841;
	exports.ER_GTID_PURGED_WAS_CHANGED                                          = 1842;
	exports.ER_GTID_EXECUTED_WAS_CHANGED                                        = 1843;
	exports.ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES                              = 1844;
	exports.ER_ALTER_OPERATION_NOT_SUPPORTED                                    = 1845;
	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON                             = 1846;
	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY                        = 1847;
	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_PARTITION                   = 1848;
	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_RENAME                   = 1849;
	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE                 = 1850;
	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_CHECK                    = 1851;
	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_IGNORE                      = 1852;
	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOPK                        = 1853;
	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_AUTOINC                     = 1854;
	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_HIDDEN_FTS                  = 1855;
	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_CHANGE_FTS                  = 1856;
	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FTS                         = 1857;
	exports.ER_SQL_SLAVE_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE                 = 1858;
	exports.ER_DUP_UNKNOWN_IN_INDEX                                             = 1859;
	exports.ER_IDENT_CAUSES_TOO_LONG_PATH                                       = 1860;
	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOT_NULL                    = 1861;
	exports.ER_MUST_CHANGE_PASSWORD_LOGIN                                       = 1862;
	exports.ER_ROW_IN_WRONG_PARTITION                                           = 1863;
	exports.ER_MTS_EVENT_BIGGER_PENDING_JOBS_SIZE_MAX                           = 1864;
	exports.ER_INNODB_NO_FT_USES_PARSER                                         = 1865;
	exports.ER_BINLOG_LOGICAL_CORRUPTION                                        = 1866;
	exports.ER_WARN_PURGE_LOG_IN_USE                                            = 1867;
	exports.ER_WARN_PURGE_LOG_IS_ACTIVE                                         = 1868;
	exports.ER_AUTO_INCREMENT_CONFLICT                                          = 1869;
	exports.WARN_ON_BLOCKHOLE_IN_RBR                                            = 1870;
	exports.ER_SLAVE_MI_INIT_REPOSITORY                                         = 1871;
	exports.ER_SLAVE_RLI_INIT_REPOSITORY                                        = 1872;
	exports.ER_ACCESS_DENIED_CHANGE_USER_ERROR                                  = 1873;
	exports.ER_INNODB_READ_ONLY                                                 = 1874;
	exports.ER_STOP_SLAVE_SQL_THREAD_TIMEOUT                                    = 1875;
	exports.ER_STOP_SLAVE_IO_THREAD_TIMEOUT                                     = 1876;
	exports.ER_TABLE_CORRUPT                                                    = 1877;
	exports.ER_TEMP_FILE_WRITE_FAILURE                                          = 1878;
	exports.ER_INNODB_FT_AUX_NOT_HEX_ID                                         = 1879;
	exports.ER_OLD_TEMPORALS_UPGRADED                                           = 1880;
	exports.ER_INNODB_FORCED_RECOVERY                                           = 1881;
	exports.ER_AES_INVALID_IV                                                   = 1882;
	
	// Lookup-by-number table
	exports[1]    = 'EE_CANTCREATEFILE';
	exports[2]    = 'EE_READ';
	exports[3]    = 'EE_WRITE';
	exports[4]    = 'EE_BADCLOSE';
	exports[5]    = 'EE_OUTOFMEMORY';
	exports[6]    = 'EE_DELETE';
	exports[7]    = 'EE_LINK';
	exports[9]    = 'EE_EOFERR';
	exports[10]   = 'EE_CANTLOCK';
	exports[11]   = 'EE_CANTUNLOCK';
	exports[12]   = 'EE_DIR';
	exports[13]   = 'EE_STAT';
	exports[14]   = 'EE_CANT_CHSIZE';
	exports[15]   = 'EE_CANT_OPEN_STREAM';
	exports[16]   = 'EE_GETWD';
	exports[17]   = 'EE_SETWD';
	exports[18]   = 'EE_LINK_WARNING';
	exports[19]   = 'EE_OPEN_WARNING';
	exports[20]   = 'EE_DISK_FULL';
	exports[21]   = 'EE_CANT_MKDIR';
	exports[22]   = 'EE_UNKNOWN_CHARSET';
	exports[23]   = 'EE_OUT_OF_FILERESOURCES';
	exports[24]   = 'EE_CANT_READLINK';
	exports[25]   = 'EE_CANT_SYMLINK';
	exports[26]   = 'EE_REALPATH';
	exports[27]   = 'EE_SYNC';
	exports[28]   = 'EE_UNKNOWN_COLLATION';
	exports[29]   = 'EE_FILENOTFOUND';
	exports[30]   = 'EE_FILE_NOT_CLOSED';
	exports[31]   = 'EE_CHANGE_OWNERSHIP';
	exports[32]   = 'EE_CHANGE_PERMISSIONS';
	exports[33]   = 'EE_CANT_SEEK';
	exports[120]  = 'HA_ERR_KEY_NOT_FOUND';
	exports[121]  = 'HA_ERR_FOUND_DUPP_KEY';
	exports[122]  = 'HA_ERR_INTERNAL_ERROR';
	exports[123]  = 'HA_ERR_RECORD_CHANGED';
	exports[124]  = 'HA_ERR_WRONG_INDEX';
	exports[126]  = 'HA_ERR_CRASHED';
	exports[127]  = 'HA_ERR_WRONG_IN_RECORD';
	exports[128]  = 'HA_ERR_OUT_OF_MEM';
	exports[130]  = 'HA_ERR_NOT_A_TABLE';
	exports[131]  = 'HA_ERR_WRONG_COMMAND';
	exports[132]  = 'HA_ERR_OLD_FILE';
	exports[133]  = 'HA_ERR_NO_ACTIVE_RECORD';
	exports[134]  = 'HA_ERR_RECORD_DELETED';
	exports[135]  = 'HA_ERR_RECORD_FILE_FULL';
	exports[136]  = 'HA_ERR_INDEX_FILE_FULL';
	exports[137]  = 'HA_ERR_END_OF_FILE';
	exports[138]  = 'HA_ERR_UNSUPPORTED';
	exports[139]  = 'HA_ERR_TO_BIG_ROW';
	exports[140]  = 'HA_WRONG_CREATE_OPTION';
	exports[141]  = 'HA_ERR_FOUND_DUPP_UNIQUE';
	exports[142]  = 'HA_ERR_UNKNOWN_CHARSET';
	exports[143]  = 'HA_ERR_WRONG_MRG_TABLE_DEF';
	exports[144]  = 'HA_ERR_CRASHED_ON_REPAIR';
	exports[145]  = 'HA_ERR_CRASHED_ON_USAGE';
	exports[146]  = 'HA_ERR_LOCK_WAIT_TIMEOUT';
	exports[147]  = 'HA_ERR_LOCK_TABLE_FULL';
	exports[148]  = 'HA_ERR_READ_ONLY_TRANSACTION';
	exports[149]  = 'HA_ERR_LOCK_DEADLOCK';
	exports[150]  = 'HA_ERR_CANNOT_ADD_FOREIGN';
	exports[151]  = 'HA_ERR_NO_REFERENCED_ROW';
	exports[152]  = 'HA_ERR_ROW_IS_REFERENCED';
	exports[153]  = 'HA_ERR_NO_SAVEPOINT';
	exports[154]  = 'HA_ERR_NON_UNIQUE_BLOCK_SIZE';
	exports[155]  = 'HA_ERR_NO_SUCH_TABLE';
	exports[156]  = 'HA_ERR_TABLE_EXIST';
	exports[157]  = 'HA_ERR_NO_CONNECTION';
	exports[158]  = 'HA_ERR_NULL_IN_SPATIAL';
	exports[159]  = 'HA_ERR_TABLE_DEF_CHANGED';
	exports[160]  = 'HA_ERR_NO_PARTITION_FOUND';
	exports[161]  = 'HA_ERR_RBR_LOGGING_FAILED';
	exports[162]  = 'HA_ERR_DROP_INDEX_FK';
	exports[163]  = 'HA_ERR_FOREIGN_DUPLICATE_KEY';
	exports[164]  = 'HA_ERR_TABLE_NEEDS_UPGRADE';
	exports[165]  = 'HA_ERR_TABLE_READONLY';
	exports[166]  = 'HA_ERR_AUTOINC_READ_FAILED';
	exports[167]  = 'HA_ERR_AUTOINC_ERANGE';
	exports[168]  = 'HA_ERR_GENERIC';
	exports[169]  = 'HA_ERR_RECORD_IS_THE_SAME';
	exports[170]  = 'HA_ERR_LOGGING_IMPOSSIBLE';
	exports[171]  = 'HA_ERR_CORRUPT_EVENT';
	exports[172]  = 'HA_ERR_NEW_FILE';
	exports[173]  = 'HA_ERR_ROWS_EVENT_APPLY';
	exports[174]  = 'HA_ERR_INITIALIZATION';
	exports[175]  = 'HA_ERR_FILE_TOO_SHORT';
	exports[176]  = 'HA_ERR_WRONG_CRC';
	exports[177]  = 'HA_ERR_TOO_MANY_CONCURRENT_TRXS';
	exports[178]  = 'HA_ERR_NOT_IN_LOCK_PARTITIONS';
	exports[179]  = 'HA_ERR_INDEX_COL_TOO_LONG';
	exports[180]  = 'HA_ERR_INDEX_CORRUPT';
	exports[181]  = 'HA_ERR_UNDO_REC_TOO_BIG';
	exports[182]  = 'HA_FTS_INVALID_DOCID';
	exports[183]  = 'HA_ERR_TABLE_IN_FK_CHECK';
	exports[184]  = 'HA_ERR_TABLESPACE_EXISTS';
	exports[185]  = 'HA_ERR_TOO_MANY_FIELDS';
	exports[186]  = 'HA_ERR_ROW_IN_WRONG_PARTITION';
	exports[187]  = 'HA_ERR_INNODB_READ_ONLY';
	exports[188]  = 'HA_ERR_FTS_EXCEED_RESULT_CACHE_LIMIT';
	exports[189]  = 'HA_ERR_TEMP_FILE_WRITE_FAILURE';
	exports[190]  = 'HA_ERR_INNODB_FORCED_RECOVERY';
	exports[191]  = 'HA_ERR_FTS_TOO_MANY_WORDS_IN_PHRASE';
	exports[1000] = 'ER_HASHCHK';
	exports[1001] = 'ER_NISAMCHK';
	exports[1002] = 'ER_NO';
	exports[1003] = 'ER_YES';
	exports[1004] = 'ER_CANT_CREATE_FILE';
	exports[1005] = 'ER_CANT_CREATE_TABLE';
	exports[1006] = 'ER_CANT_CREATE_DB';
	exports[1007] = 'ER_DB_CREATE_EXISTS';
	exports[1008] = 'ER_DB_DROP_EXISTS';
	exports[1009] = 'ER_DB_DROP_DELETE';
	exports[1010] = 'ER_DB_DROP_RMDIR';
	exports[1011] = 'ER_CANT_DELETE_FILE';
	exports[1012] = 'ER_CANT_FIND_SYSTEM_REC';
	exports[1013] = 'ER_CANT_GET_STAT';
	exports[1014] = 'ER_CANT_GET_WD';
	exports[1015] = 'ER_CANT_LOCK';
	exports[1016] = 'ER_CANT_OPEN_FILE';
	exports[1017] = 'ER_FILE_NOT_FOUND';
	exports[1018] = 'ER_CANT_READ_DIR';
	exports[1019] = 'ER_CANT_SET_WD';
	exports[1020] = 'ER_CHECKREAD';
	exports[1021] = 'ER_DISK_FULL';
	exports[1022] = 'ER_DUP_KEY';
	exports[1023] = 'ER_ERROR_ON_CLOSE';
	exports[1024] = 'ER_ERROR_ON_READ';
	exports[1025] = 'ER_ERROR_ON_RENAME';
	exports[1026] = 'ER_ERROR_ON_WRITE';
	exports[1027] = 'ER_FILE_USED';
	exports[1028] = 'ER_FILSORT_ABORT';
	exports[1029] = 'ER_FORM_NOT_FOUND';
	exports[1030] = 'ER_GET_ERRNO';
	exports[1031] = 'ER_ILLEGAL_HA';
	exports[1032] = 'ER_KEY_NOT_FOUND';
	exports[1033] = 'ER_NOT_FORM_FILE';
	exports[1034] = 'ER_NOT_KEYFILE';
	exports[1035] = 'ER_OLD_KEYFILE';
	exports[1036] = 'ER_OPEN_AS_READONLY';
	exports[1037] = 'ER_OUTOFMEMORY';
	exports[1038] = 'ER_OUT_OF_SORTMEMORY';
	exports[1039] = 'ER_UNEXPECTED_EOF';
	exports[1040] = 'ER_CON_COUNT_ERROR';
	exports[1041] = 'ER_OUT_OF_RESOURCES';
	exports[1042] = 'ER_BAD_HOST_ERROR';
	exports[1043] = 'ER_HANDSHAKE_ERROR';
	exports[1044] = 'ER_DBACCESS_DENIED_ERROR';
	exports[1045] = 'ER_ACCESS_DENIED_ERROR';
	exports[1046] = 'ER_NO_DB_ERROR';
	exports[1047] = 'ER_UNKNOWN_COM_ERROR';
	exports[1048] = 'ER_BAD_NULL_ERROR';
	exports[1049] = 'ER_BAD_DB_ERROR';
	exports[1050] = 'ER_TABLE_EXISTS_ERROR';
	exports[1051] = 'ER_BAD_TABLE_ERROR';
	exports[1052] = 'ER_NON_UNIQ_ERROR';
	exports[1053] = 'ER_SERVER_SHUTDOWN';
	exports[1054] = 'ER_BAD_FIELD_ERROR';
	exports[1055] = 'ER_WRONG_FIELD_WITH_GROUP';
	exports[1056] = 'ER_WRONG_GROUP_FIELD';
	exports[1057] = 'ER_WRONG_SUM_SELECT';
	exports[1058] = 'ER_WRONG_VALUE_COUNT';
	exports[1059] = 'ER_TOO_LONG_IDENT';
	exports[1060] = 'ER_DUP_FIELDNAME';
	exports[1061] = 'ER_DUP_KEYNAME';
	exports[1062] = 'ER_DUP_ENTRY';
	exports[1063] = 'ER_WRONG_FIELD_SPEC';
	exports[1064] = 'ER_PARSE_ERROR';
	exports[1065] = 'ER_EMPTY_QUERY';
	exports[1066] = 'ER_NONUNIQ_TABLE';
	exports[1067] = 'ER_INVALID_DEFAULT';
	exports[1068] = 'ER_MULTIPLE_PRI_KEY';
	exports[1069] = 'ER_TOO_MANY_KEYS';
	exports[1070] = 'ER_TOO_MANY_KEY_PARTS';
	exports[1071] = 'ER_TOO_LONG_KEY';
	exports[1072] = 'ER_KEY_COLUMN_DOES_NOT_EXITS';
	exports[1073] = 'ER_BLOB_USED_AS_KEY';
	exports[1074] = 'ER_TOO_BIG_FIELDLENGTH';
	exports[1075] = 'ER_WRONG_AUTO_KEY';
	exports[1076] = 'ER_READY';
	exports[1077] = 'ER_NORMAL_SHUTDOWN';
	exports[1078] = 'ER_GOT_SIGNAL';
	exports[1079] = 'ER_SHUTDOWN_COMPLETE';
	exports[1080] = 'ER_FORCING_CLOSE';
	exports[1081] = 'ER_IPSOCK_ERROR';
	exports[1082] = 'ER_NO_SUCH_INDEX';
	exports[1083] = 'ER_WRONG_FIELD_TERMINATORS';
	exports[1084] = 'ER_BLOBS_AND_NO_TERMINATED';
	exports[1085] = 'ER_TEXTFILE_NOT_READABLE';
	exports[1086] = 'ER_FILE_EXISTS_ERROR';
	exports[1087] = 'ER_LOAD_INFO';
	exports[1088] = 'ER_ALTER_INFO';
	exports[1089] = 'ER_WRONG_SUB_KEY';
	exports[1090] = 'ER_CANT_REMOVE_ALL_FIELDS';
	exports[1091] = 'ER_CANT_DROP_FIELD_OR_KEY';
	exports[1092] = 'ER_INSERT_INFO';
	exports[1093] = 'ER_UPDATE_TABLE_USED';
	exports[1094] = 'ER_NO_SUCH_THREAD';
	exports[1095] = 'ER_KILL_DENIED_ERROR';
	exports[1096] = 'ER_NO_TABLES_USED';
	exports[1097] = 'ER_TOO_BIG_SET';
	exports[1098] = 'ER_NO_UNIQUE_LOGFILE';
	exports[1099] = 'ER_TABLE_NOT_LOCKED_FOR_WRITE';
	exports[1100] = 'ER_TABLE_NOT_LOCKED';
	exports[1101] = 'ER_BLOB_CANT_HAVE_DEFAULT';
	exports[1102] = 'ER_WRONG_DB_NAME';
	exports[1103] = 'ER_WRONG_TABLE_NAME';
	exports[1104] = 'ER_TOO_BIG_SELECT';
	exports[1105] = 'ER_UNKNOWN_ERROR';
	exports[1106] = 'ER_UNKNOWN_PROCEDURE';
	exports[1107] = 'ER_WRONG_PARAMCOUNT_TO_PROCEDURE';
	exports[1108] = 'ER_WRONG_PARAMETERS_TO_PROCEDURE';
	exports[1109] = 'ER_UNKNOWN_TABLE';
	exports[1110] = 'ER_FIELD_SPECIFIED_TWICE';
	exports[1111] = 'ER_INVALID_GROUP_FUNC_USE';
	exports[1112] = 'ER_UNSUPPORTED_EXTENSION';
	exports[1113] = 'ER_TABLE_MUST_HAVE_COLUMNS';
	exports[1114] = 'ER_RECORD_FILE_FULL';
	exports[1115] = 'ER_UNKNOWN_CHARACTER_SET';
	exports[1116] = 'ER_TOO_MANY_TABLES';
	exports[1117] = 'ER_TOO_MANY_FIELDS';
	exports[1118] = 'ER_TOO_BIG_ROWSIZE';
	exports[1119] = 'ER_STACK_OVERRUN';
	exports[1120] = 'ER_WRONG_OUTER_JOIN';
	exports[1121] = 'ER_NULL_COLUMN_IN_INDEX';
	exports[1122] = 'ER_CANT_FIND_UDF';
	exports[1123] = 'ER_CANT_INITIALIZE_UDF';
	exports[1124] = 'ER_UDF_NO_PATHS';
	exports[1125] = 'ER_UDF_EXISTS';
	exports[1126] = 'ER_CANT_OPEN_LIBRARY';
	exports[1127] = 'ER_CANT_FIND_DL_ENTRY';
	exports[1128] = 'ER_FUNCTION_NOT_DEFINED';
	exports[1129] = 'ER_HOST_IS_BLOCKED';
	exports[1130] = 'ER_HOST_NOT_PRIVILEGED';
	exports[1131] = 'ER_PASSWORD_ANONYMOUS_USER';
	exports[1132] = 'ER_PASSWORD_NOT_ALLOWED';
	exports[1133] = 'ER_PASSWORD_NO_MATCH';
	exports[1134] = 'ER_UPDATE_INFO';
	exports[1135] = 'ER_CANT_CREATE_THREAD';
	exports[1136] = 'ER_WRONG_VALUE_COUNT_ON_ROW';
	exports[1137] = 'ER_CANT_REOPEN_TABLE';
	exports[1138] = 'ER_INVALID_USE_OF_NULL';
	exports[1139] = 'ER_REGEXP_ERROR';
	exports[1140] = 'ER_MIX_OF_GROUP_FUNC_AND_FIELDS';
	exports[1141] = 'ER_NONEXISTING_GRANT';
	exports[1142] = 'ER_TABLEACCESS_DENIED_ERROR';
	exports[1143] = 'ER_COLUMNACCESS_DENIED_ERROR';
	exports[1144] = 'ER_ILLEGAL_GRANT_FOR_TABLE';
	exports[1145] = 'ER_GRANT_WRONG_HOST_OR_USER';
	exports[1146] = 'ER_NO_SUCH_TABLE';
	exports[1147] = 'ER_NONEXISTING_TABLE_GRANT';
	exports[1148] = 'ER_NOT_ALLOWED_COMMAND';
	exports[1149] = 'ER_SYNTAX_ERROR';
	exports[1150] = 'ER_DELAYED_CANT_CHANGE_LOCK';
	exports[1151] = 'ER_TOO_MANY_DELAYED_THREADS';
	exports[1152] = 'ER_ABORTING_CONNECTION';
	exports[1153] = 'ER_NET_PACKET_TOO_LARGE';
	exports[1154] = 'ER_NET_READ_ERROR_FROM_PIPE';
	exports[1155] = 'ER_NET_FCNTL_ERROR';
	exports[1156] = 'ER_NET_PACKETS_OUT_OF_ORDER';
	exports[1157] = 'ER_NET_UNCOMPRESS_ERROR';
	exports[1158] = 'ER_NET_READ_ERROR';
	exports[1159] = 'ER_NET_READ_INTERRUPTED';
	exports[1160] = 'ER_NET_ERROR_ON_WRITE';
	exports[1161] = 'ER_NET_WRITE_INTERRUPTED';
	exports[1162] = 'ER_TOO_LONG_STRING';
	exports[1163] = 'ER_TABLE_CANT_HANDLE_BLOB';
	exports[1164] = 'ER_TABLE_CANT_HANDLE_AUTO_INCREMENT';
	exports[1165] = 'ER_DELAYED_INSERT_TABLE_LOCKED';
	exports[1166] = 'ER_WRONG_COLUMN_NAME';
	exports[1167] = 'ER_WRONG_KEY_COLUMN';
	exports[1168] = 'ER_WRONG_MRG_TABLE';
	exports[1169] = 'ER_DUP_UNIQUE';
	exports[1170] = 'ER_BLOB_KEY_WITHOUT_LENGTH';
	exports[1171] = 'ER_PRIMARY_CANT_HAVE_NULL';
	exports[1172] = 'ER_TOO_MANY_ROWS';
	exports[1173] = 'ER_REQUIRES_PRIMARY_KEY';
	exports[1174] = 'ER_NO_RAID_COMPILED';
	exports[1175] = 'ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE';
	exports[1176] = 'ER_KEY_DOES_NOT_EXITS';
	exports[1177] = 'ER_CHECK_NO_SUCH_TABLE';
	exports[1178] = 'ER_CHECK_NOT_IMPLEMENTED';
	exports[1179] = 'ER_CANT_DO_THIS_DURING_AN_TRANSACTION';
	exports[1180] = 'ER_ERROR_DURING_COMMIT';
	exports[1181] = 'ER_ERROR_DURING_ROLLBACK';
	exports[1182] = 'ER_ERROR_DURING_FLUSH_LOGS';
	exports[1183] = 'ER_ERROR_DURING_CHECKPOINT';
	exports[1184] = 'ER_NEW_ABORTING_CONNECTION';
	exports[1185] = 'ER_DUMP_NOT_IMPLEMENTED';
	exports[1186] = 'ER_FLUSH_MASTER_BINLOG_CLOSED';
	exports[1187] = 'ER_INDEX_REBUILD';
	exports[1188] = 'ER_MASTER';
	exports[1189] = 'ER_MASTER_NET_READ';
	exports[1190] = 'ER_MASTER_NET_WRITE';
	exports[1191] = 'ER_FT_MATCHING_KEY_NOT_FOUND';
	exports[1192] = 'ER_LOCK_OR_ACTIVE_TRANSACTION';
	exports[1193] = 'ER_UNKNOWN_SYSTEM_VARIABLE';
	exports[1194] = 'ER_CRASHED_ON_USAGE';
	exports[1195] = 'ER_CRASHED_ON_REPAIR';
	exports[1196] = 'ER_WARNING_NOT_COMPLETE_ROLLBACK';
	exports[1197] = 'ER_TRANS_CACHE_FULL';
	exports[1198] = 'ER_SLAVE_MUST_STOP';
	exports[1199] = 'ER_SLAVE_NOT_RUNNING';
	exports[1200] = 'ER_BAD_SLAVE';
	exports[1201] = 'ER_MASTER_INFO';
	exports[1202] = 'ER_SLAVE_THREAD';
	exports[1203] = 'ER_TOO_MANY_USER_CONNECTIONS';
	exports[1204] = 'ER_SET_CONSTANTS_ONLY';
	exports[1205] = 'ER_LOCK_WAIT_TIMEOUT';
	exports[1206] = 'ER_LOCK_TABLE_FULL';
	exports[1207] = 'ER_READ_ONLY_TRANSACTION';
	exports[1208] = 'ER_DROP_DB_WITH_READ_LOCK';
	exports[1209] = 'ER_CREATE_DB_WITH_READ_LOCK';
	exports[1210] = 'ER_WRONG_ARGUMENTS';
	exports[1211] = 'ER_NO_PERMISSION_TO_CREATE_USER';
	exports[1212] = 'ER_UNION_TABLES_IN_DIFFERENT_DIR';
	exports[1213] = 'ER_LOCK_DEADLOCK';
	exports[1214] = 'ER_TABLE_CANT_HANDLE_FT';
	exports[1215] = 'ER_CANNOT_ADD_FOREIGN';
	exports[1216] = 'ER_NO_REFERENCED_ROW';
	exports[1217] = 'ER_ROW_IS_REFERENCED';
	exports[1218] = 'ER_CONNECT_TO_MASTER';
	exports[1219] = 'ER_QUERY_ON_MASTER';
	exports[1220] = 'ER_ERROR_WHEN_EXECUTING_COMMAND';
	exports[1221] = 'ER_WRONG_USAGE';
	exports[1222] = 'ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT';
	exports[1223] = 'ER_CANT_UPDATE_WITH_READLOCK';
	exports[1224] = 'ER_MIXING_NOT_ALLOWED';
	exports[1225] = 'ER_DUP_ARGUMENT';
	exports[1226] = 'ER_USER_LIMIT_REACHED';
	exports[1227] = 'ER_SPECIFIC_ACCESS_DENIED_ERROR';
	exports[1228] = 'ER_LOCAL_VARIABLE';
	exports[1229] = 'ER_GLOBAL_VARIABLE';
	exports[1230] = 'ER_NO_DEFAULT';
	exports[1231] = 'ER_WRONG_VALUE_FOR_VAR';
	exports[1232] = 'ER_WRONG_TYPE_FOR_VAR';
	exports[1233] = 'ER_VAR_CANT_BE_READ';
	exports[1234] = 'ER_CANT_USE_OPTION_HERE';
	exports[1235] = 'ER_NOT_SUPPORTED_YET';
	exports[1236] = 'ER_MASTER_FATAL_ERROR_READING_BINLOG';
	exports[1237] = 'ER_SLAVE_IGNORED_TABLE';
	exports[1238] = 'ER_INCORRECT_GLOBAL_LOCAL_VAR';
	exports[1239] = 'ER_WRONG_FK_DEF';
	exports[1240] = 'ER_KEY_REF_DO_NOT_MATCH_TABLE_REF';
	exports[1241] = 'ER_OPERAND_COLUMNS';
	exports[1242] = 'ER_SUBQUERY_NO_1_ROW';
	exports[1243] = 'ER_UNKNOWN_STMT_HANDLER';
	exports[1244] = 'ER_CORRUPT_HELP_DB';
	exports[1245] = 'ER_CYCLIC_REFERENCE';
	exports[1246] = 'ER_AUTO_CONVERT';
	exports[1247] = 'ER_ILLEGAL_REFERENCE';
	exports[1248] = 'ER_DERIVED_MUST_HAVE_ALIAS';
	exports[1249] = 'ER_SELECT_REDUCED';
	exports[1250] = 'ER_TABLENAME_NOT_ALLOWED_HERE';
	exports[1251] = 'ER_NOT_SUPPORTED_AUTH_MODE';
	exports[1252] = 'ER_SPATIAL_CANT_HAVE_NULL';
	exports[1253] = 'ER_COLLATION_CHARSET_MISMATCH';
	exports[1254] = 'ER_SLAVE_WAS_RUNNING';
	exports[1255] = 'ER_SLAVE_WAS_NOT_RUNNING';
	exports[1256] = 'ER_TOO_BIG_FOR_UNCOMPRESS';
	exports[1257] = 'ER_ZLIB_Z_MEM_ERROR';
	exports[1258] = 'ER_ZLIB_Z_BUF_ERROR';
	exports[1259] = 'ER_ZLIB_Z_DATA_ERROR';
	exports[1260] = 'ER_CUT_VALUE_GROUP_CONCAT';
	exports[1261] = 'ER_WARN_TOO_FEW_RECORDS';
	exports[1262] = 'ER_WARN_TOO_MANY_RECORDS';
	exports[1263] = 'ER_WARN_NULL_TO_NOTNULL';
	exports[1264] = 'ER_WARN_DATA_OUT_OF_RANGE';
	exports[1265] = 'WARN_DATA_TRUNCATED';
	exports[1266] = 'ER_WARN_USING_OTHER_HANDLER';
	exports[1267] = 'ER_CANT_AGGREGATE_2COLLATIONS';
	exports[1268] = 'ER_DROP_USER';
	exports[1269] = 'ER_REVOKE_GRANTS';
	exports[1270] = 'ER_CANT_AGGREGATE_3COLLATIONS';
	exports[1271] = 'ER_CANT_AGGREGATE_NCOLLATIONS';
	exports[1272] = 'ER_VARIABLE_IS_NOT_STRUCT';
	exports[1273] = 'ER_UNKNOWN_COLLATION';
	exports[1274] = 'ER_SLAVE_IGNORED_SSL_PARAMS';
	exports[1275] = 'ER_SERVER_IS_IN_SECURE_AUTH_MODE';
	exports[1276] = 'ER_WARN_FIELD_RESOLVED';
	exports[1277] = 'ER_BAD_SLAVE_UNTIL_COND';
	exports[1278] = 'ER_MISSING_SKIP_SLAVE';
	exports[1279] = 'ER_UNTIL_COND_IGNORED';
	exports[1280] = 'ER_WRONG_NAME_FOR_INDEX';
	exports[1281] = 'ER_WRONG_NAME_FOR_CATALOG';
	exports[1282] = 'ER_WARN_QC_RESIZE';
	exports[1283] = 'ER_BAD_FT_COLUMN';
	exports[1284] = 'ER_UNKNOWN_KEY_CACHE';
	exports[1285] = 'ER_WARN_HOSTNAME_WONT_WORK';
	exports[1286] = 'ER_UNKNOWN_STORAGE_ENGINE';
	exports[1287] = 'ER_WARN_DEPRECATED_SYNTAX';
	exports[1288] = 'ER_NON_UPDATABLE_TABLE';
	exports[1289] = 'ER_FEATURE_DISABLED';
	exports[1290] = 'ER_OPTION_PREVENTS_STATEMENT';
	exports[1291] = 'ER_DUPLICATED_VALUE_IN_TYPE';
	exports[1292] = 'ER_TRUNCATED_WRONG_VALUE';
	exports[1293] = 'ER_TOO_MUCH_AUTO_TIMESTAMP_COLS';
	exports[1294] = 'ER_INVALID_ON_UPDATE';
	exports[1295] = 'ER_UNSUPPORTED_PS';
	exports[1296] = 'ER_GET_ERRMSG';
	exports[1297] = 'ER_GET_TEMPORARY_ERRMSG';
	exports[1298] = 'ER_UNKNOWN_TIME_ZONE';
	exports[1299] = 'ER_WARN_INVALID_TIMESTAMP';
	exports[1300] = 'ER_INVALID_CHARACTER_STRING';
	exports[1301] = 'ER_WARN_ALLOWED_PACKET_OVERFLOWED';
	exports[1302] = 'ER_CONFLICTING_DECLARATIONS';
	exports[1303] = 'ER_SP_NO_RECURSIVE_CREATE';
	exports[1304] = 'ER_SP_ALREADY_EXISTS';
	exports[1305] = 'ER_SP_DOES_NOT_EXIST';
	exports[1306] = 'ER_SP_DROP_FAILED';
	exports[1307] = 'ER_SP_STORE_FAILED';
	exports[1308] = 'ER_SP_LILABEL_MISMATCH';
	exports[1309] = 'ER_SP_LABEL_REDEFINE';
	exports[1310] = 'ER_SP_LABEL_MISMATCH';
	exports[1311] = 'ER_SP_UNINIT_VAR';
	exports[1312] = 'ER_SP_BADSELECT';
	exports[1313] = 'ER_SP_BADRETURN';
	exports[1314] = 'ER_SP_BADSTATEMENT';
	exports[1315] = 'ER_UPDATE_LOG_DEPRECATED_IGNORED';
	exports[1316] = 'ER_UPDATE_LOG_DEPRECATED_TRANSLATED';
	exports[1317] = 'ER_QUERY_INTERRUPTED';
	exports[1318] = 'ER_SP_WRONG_NO_OF_ARGS';
	exports[1319] = 'ER_SP_COND_MISMATCH';
	exports[1320] = 'ER_SP_NORETURN';
	exports[1321] = 'ER_SP_NORETURNEND';
	exports[1322] = 'ER_SP_BAD_CURSOR_QUERY';
	exports[1323] = 'ER_SP_BAD_CURSOR_SELECT';
	exports[1324] = 'ER_SP_CURSOR_MISMATCH';
	exports[1325] = 'ER_SP_CURSOR_ALREADY_OPEN';
	exports[1326] = 'ER_SP_CURSOR_NOT_OPEN';
	exports[1327] = 'ER_SP_UNDECLARED_VAR';
	exports[1328] = 'ER_SP_WRONG_NO_OF_FETCH_ARGS';
	exports[1329] = 'ER_SP_FETCH_NO_DATA';
	exports[1330] = 'ER_SP_DUP_PARAM';
	exports[1331] = 'ER_SP_DUP_VAR';
	exports[1332] = 'ER_SP_DUP_COND';
	exports[1333] = 'ER_SP_DUP_CURS';
	exports[1334] = 'ER_SP_CANT_ALTER';
	exports[1335] = 'ER_SP_SUBSELECT_NYI';
	exports[1336] = 'ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG';
	exports[1337] = 'ER_SP_VARCOND_AFTER_CURSHNDLR';
	exports[1338] = 'ER_SP_CURSOR_AFTER_HANDLER';
	exports[1339] = 'ER_SP_CASE_NOT_FOUND';
	exports[1340] = 'ER_FPARSER_TOO_BIG_FILE';
	exports[1341] = 'ER_FPARSER_BAD_HEADER';
	exports[1342] = 'ER_FPARSER_EOF_IN_COMMENT';
	exports[1343] = 'ER_FPARSER_ERROR_IN_PARAMETER';
	exports[1344] = 'ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER';
	exports[1345] = 'ER_VIEW_NO_EXPLAIN';
	exports[1346] = 'ER_FRM_UNKNOWN_TYPE';
	exports[1347] = 'ER_WRONG_OBJECT';
	exports[1348] = 'ER_NONUPDATEABLE_COLUMN';
	exports[1349] = 'ER_VIEW_SELECT_DERIVED';
	exports[1350] = 'ER_VIEW_SELECT_CLAUSE';
	exports[1351] = 'ER_VIEW_SELECT_VARIABLE';
	exports[1352] = 'ER_VIEW_SELECT_TMPTABLE';
	exports[1353] = 'ER_VIEW_WRONG_LIST';
	exports[1354] = 'ER_WARN_VIEW_MERGE';
	exports[1355] = 'ER_WARN_VIEW_WITHOUT_KEY';
	exports[1356] = 'ER_VIEW_INVALID';
	exports[1357] = 'ER_SP_NO_DROP_SP';
	exports[1358] = 'ER_SP_GOTO_IN_HNDLR';
	exports[1359] = 'ER_TRG_ALREADY_EXISTS';
	exports[1360] = 'ER_TRG_DOES_NOT_EXIST';
	exports[1361] = 'ER_TRG_ON_VIEW_OR_TEMP_TABLE';
	exports[1362] = 'ER_TRG_CANT_CHANGE_ROW';
	exports[1363] = 'ER_TRG_NO_SUCH_ROW_IN_TRG';
	exports[1364] = 'ER_NO_DEFAULT_FOR_FIELD';
	exports[1365] = 'ER_DIVISION_BY_ZERO';
	exports[1366] = 'ER_TRUNCATED_WRONG_VALUE_FOR_FIELD';
	exports[1367] = 'ER_ILLEGAL_VALUE_FOR_TYPE';
	exports[1368] = 'ER_VIEW_NONUPD_CHECK';
	exports[1369] = 'ER_VIEW_CHECK_FAILED';
	exports[1370] = 'ER_PROCACCESS_DENIED_ERROR';
	exports[1371] = 'ER_RELAY_LOG_FAIL';
	exports[1372] = 'ER_PASSWD_LENGTH';
	exports[1373] = 'ER_UNKNOWN_TARGET_BINLOG';
	exports[1374] = 'ER_IO_ERR_LOG_INDEX_READ';
	exports[1375] = 'ER_BINLOG_PURGE_PROHIBITED';
	exports[1376] = 'ER_FSEEK_FAIL';
	exports[1377] = 'ER_BINLOG_PURGE_FATAL_ERR';
	exports[1378] = 'ER_LOG_IN_USE';
	exports[1379] = 'ER_LOG_PURGE_UNKNOWN_ERR';
	exports[1380] = 'ER_RELAY_LOG_INIT';
	exports[1381] = 'ER_NO_BINARY_LOGGING';
	exports[1382] = 'ER_RESERVED_SYNTAX';
	exports[1383] = 'ER_WSAS_FAILED';
	exports[1384] = 'ER_DIFF_GROUPS_PROC';
	exports[1385] = 'ER_NO_GROUP_FOR_PROC';
	exports[1386] = 'ER_ORDER_WITH_PROC';
	exports[1387] = 'ER_LOGGING_PROHIBIT_CHANGING_OF';
	exports[1388] = 'ER_NO_FILE_MAPPING';
	exports[1389] = 'ER_WRONG_MAGIC';
	exports[1390] = 'ER_PS_MANY_PARAM';
	exports[1391] = 'ER_KEY_PART_0';
	exports[1392] = 'ER_VIEW_CHECKSUM';
	exports[1393] = 'ER_VIEW_MULTIUPDATE';
	exports[1394] = 'ER_VIEW_NO_INSERT_FIELD_LIST';
	exports[1395] = 'ER_VIEW_DELETE_MERGE_VIEW';
	exports[1396] = 'ER_CANNOT_USER';
	exports[1397] = 'ER_XAER_NOTA';
	exports[1398] = 'ER_XAER_INVAL';
	exports[1399] = 'ER_XAER_RMFAIL';
	exports[1400] = 'ER_XAER_OUTSIDE';
	exports[1401] = 'ER_XAER_RMERR';
	exports[1402] = 'ER_XA_RBROLLBACK';
	exports[1403] = 'ER_NONEXISTING_PROC_GRANT';
	exports[1404] = 'ER_PROC_AUTO_GRANT_FAIL';
	exports[1405] = 'ER_PROC_AUTO_REVOKE_FAIL';
	exports[1406] = 'ER_DATA_TOO_LONG';
	exports[1407] = 'ER_SP_BAD_SQLSTATE';
	exports[1408] = 'ER_STARTUP';
	exports[1409] = 'ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR';
	exports[1410] = 'ER_CANT_CREATE_USER_WITH_GRANT';
	exports[1411] = 'ER_WRONG_VALUE_FOR_TYPE';
	exports[1412] = 'ER_TABLE_DEF_CHANGED';
	exports[1413] = 'ER_SP_DUP_HANDLER';
	exports[1414] = 'ER_SP_NOT_VAR_ARG';
	exports[1415] = 'ER_SP_NO_RETSET';
	exports[1416] = 'ER_CANT_CREATE_GEOMETRY_OBJECT';
	exports[1417] = 'ER_FAILED_ROUTINE_BREAK_BINLOG';
	exports[1418] = 'ER_BINLOG_UNSAFE_ROUTINE';
	exports[1419] = 'ER_BINLOG_CREATE_ROUTINE_NEED_SUPER';
	exports[1420] = 'ER_EXEC_STMT_WITH_OPEN_CURSOR';
	exports[1421] = 'ER_STMT_HAS_NO_OPEN_CURSOR';
	exports[1422] = 'ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG';
	exports[1423] = 'ER_NO_DEFAULT_FOR_VIEW_FIELD';
	exports[1424] = 'ER_SP_NO_RECURSION';
	exports[1425] = 'ER_TOO_BIG_SCALE';
	exports[1426] = 'ER_TOO_BIG_PRECISION';
	exports[1427] = 'ER_M_BIGGER_THAN_D';
	exports[1428] = 'ER_WRONG_LOCK_OF_SYSTEM_TABLE';
	exports[1429] = 'ER_CONNECT_TO_FOREIGN_DATA_SOURCE';
	exports[1430] = 'ER_QUERY_ON_FOREIGN_DATA_SOURCE';
	exports[1431] = 'ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST';
	exports[1432] = 'ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE';
	exports[1433] = 'ER_FOREIGN_DATA_STRING_INVALID';
	exports[1434] = 'ER_CANT_CREATE_FEDERATED_TABLE';
	exports[1435] = 'ER_TRG_IN_WRONG_SCHEMA';
	exports[1436] = 'ER_STACK_OVERRUN_NEED_MORE';
	exports[1437] = 'ER_TOO_LONG_BODY';
	exports[1438] = 'ER_WARN_CANT_DROP_DEFAULT_KEYCACHE';
	exports[1439] = 'ER_TOO_BIG_DISPLAYWIDTH';
	exports[1440] = 'ER_XAER_DUPID';
	exports[1441] = 'ER_DATETIME_FUNCTION_OVERFLOW';
	exports[1442] = 'ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG';
	exports[1443] = 'ER_VIEW_PREVENT_UPDATE';
	exports[1444] = 'ER_PS_NO_RECURSION';
	exports[1445] = 'ER_SP_CANT_SET_AUTOCOMMIT';
	exports[1446] = 'ER_MALFORMED_DEFINER';
	exports[1447] = 'ER_VIEW_FRM_NO_USER';
	exports[1448] = 'ER_VIEW_OTHER_USER';
	exports[1449] = 'ER_NO_SUCH_USER';
	exports[1450] = 'ER_FORBID_SCHEMA_CHANGE';
	exports[1451] = 'ER_ROW_IS_REFERENCED_2';
	exports[1452] = 'ER_NO_REFERENCED_ROW_2';
	exports[1453] = 'ER_SP_BAD_VAR_SHADOW';
	exports[1454] = 'ER_TRG_NO_DEFINER';
	exports[1455] = 'ER_OLD_FILE_FORMAT';
	exports[1456] = 'ER_SP_RECURSION_LIMIT';
	exports[1457] = 'ER_SP_PROC_TABLE_CORRUPT';
	exports[1458] = 'ER_SP_WRONG_NAME';
	exports[1459] = 'ER_TABLE_NEEDS_UPGRADE';
	exports[1460] = 'ER_SP_NO_AGGREGATE';
	exports[1461] = 'ER_MAX_PREPARED_STMT_COUNT_REACHED';
	exports[1462] = 'ER_VIEW_RECURSIVE';
	exports[1463] = 'ER_NON_GROUPING_FIELD_USED';
	exports[1464] = 'ER_TABLE_CANT_HANDLE_SPKEYS';
	exports[1465] = 'ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA';
	exports[1466] = 'ER_REMOVED_SPACES';
	exports[1467] = 'ER_AUTOINC_READ_FAILED';
	exports[1468] = 'ER_USERNAME';
	exports[1469] = 'ER_HOSTNAME';
	exports[1470] = 'ER_WRONG_STRING_LENGTH';
	exports[1471] = 'ER_NON_INSERTABLE_TABLE';
	exports[1472] = 'ER_ADMIN_WRONG_MRG_TABLE';
	exports[1473] = 'ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT';
	exports[1474] = 'ER_NAME_BECOMES_EMPTY';
	exports[1475] = 'ER_AMBIGUOUS_FIELD_TERM';
	exports[1476] = 'ER_FOREIGN_SERVER_EXISTS';
	exports[1477] = 'ER_FOREIGN_SERVER_DOESNT_EXIST';
	exports[1478] = 'ER_ILLEGAL_HA_CREATE_OPTION';
	exports[1479] = 'ER_PARTITION_REQUIRES_VALUES_ERROR';
	exports[1480] = 'ER_PARTITION_WRONG_VALUES_ERROR';
	exports[1481] = 'ER_PARTITION_MAXVALUE_ERROR';
	exports[1482] = 'ER_PARTITION_SUBPARTITION_ERROR';
	exports[1483] = 'ER_PARTITION_SUBPART_MIX_ERROR';
	exports[1484] = 'ER_PARTITION_WRONG_NO_PART_ERROR';
	exports[1485] = 'ER_PARTITION_WRONG_NO_SUBPART_ERROR';
	exports[1486] = 'ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR';
	exports[1487] = 'ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR';
	exports[1488] = 'ER_FIELD_NOT_FOUND_PART_ERROR';
	exports[1489] = 'ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR';
	exports[1490] = 'ER_INCONSISTENT_PARTITION_INFO_ERROR';
	exports[1491] = 'ER_PARTITION_FUNC_NOT_ALLOWED_ERROR';
	exports[1492] = 'ER_PARTITIONS_MUST_BE_DEFINED_ERROR';
	exports[1493] = 'ER_RANGE_NOT_INCREASING_ERROR';
	exports[1494] = 'ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR';
	exports[1495] = 'ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR';
	exports[1496] = 'ER_PARTITION_ENTRY_ERROR';
	exports[1497] = 'ER_MIX_HANDLER_ERROR';
	exports[1498] = 'ER_PARTITION_NOT_DEFINED_ERROR';
	exports[1499] = 'ER_TOO_MANY_PARTITIONS_ERROR';
	exports[1500] = 'ER_SUBPARTITION_ERROR';
	exports[1501] = 'ER_CANT_CREATE_HANDLER_FILE';
	exports[1502] = 'ER_BLOB_FIELD_IN_PART_FUNC_ERROR';
	exports[1503] = 'ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF';
	exports[1504] = 'ER_NO_PARTS_ERROR';
	exports[1505] = 'ER_PARTITION_MGMT_ON_NONPARTITIONED';
	exports[1506] = 'ER_FOREIGN_KEY_ON_PARTITIONED';
	exports[1507] = 'ER_DROP_PARTITION_NON_EXISTENT';
	exports[1508] = 'ER_DROP_LAST_PARTITION';
	exports[1509] = 'ER_COALESCE_ONLY_ON_HASH_PARTITION';
	exports[1510] = 'ER_REORG_HASH_ONLY_ON_SAME_NO';
	exports[1511] = 'ER_REORG_NO_PARAM_ERROR';
	exports[1512] = 'ER_ONLY_ON_RANGE_LIST_PARTITION';
	exports[1513] = 'ER_ADD_PARTITION_SUBPART_ERROR';
	exports[1514] = 'ER_ADD_PARTITION_NO_NEW_PARTITION';
	exports[1515] = 'ER_COALESCE_PARTITION_NO_PARTITION';
	exports[1516] = 'ER_REORG_PARTITION_NOT_EXIST';
	exports[1517] = 'ER_SAME_NAME_PARTITION';
	exports[1518] = 'ER_NO_BINLOG_ERROR';
	exports[1519] = 'ER_CONSECUTIVE_REORG_PARTITIONS';
	exports[1520] = 'ER_REORG_OUTSIDE_RANGE';
	exports[1521] = 'ER_PARTITION_FUNCTION_FAILURE';
	exports[1522] = 'ER_PART_STATE_ERROR';
	exports[1523] = 'ER_LIMITED_PART_RANGE';
	exports[1524] = 'ER_PLUGIN_IS_NOT_LOADED';
	exports[1525] = 'ER_WRONG_VALUE';
	exports[1526] = 'ER_NO_PARTITION_FOR_GIVEN_VALUE';
	exports[1527] = 'ER_FILEGROUP_OPTION_ONLY_ONCE';
	exports[1528] = 'ER_CREATE_FILEGROUP_FAILED';
	exports[1529] = 'ER_DROP_FILEGROUP_FAILED';
	exports[1530] = 'ER_TABLESPACE_AUTO_EXTEND_ERROR';
	exports[1531] = 'ER_WRONG_SIZE_NUMBER';
	exports[1532] = 'ER_SIZE_OVERFLOW_ERROR';
	exports[1533] = 'ER_ALTER_FILEGROUP_FAILED';
	exports[1534] = 'ER_BINLOG_ROW_LOGGING_FAILED';
	exports[1535] = 'ER_BINLOG_ROW_WRONG_TABLE_DEF';
	exports[1536] = 'ER_BINLOG_ROW_RBR_TO_SBR';
	exports[1537] = 'ER_EVENT_ALREADY_EXISTS';
	exports[1538] = 'ER_EVENT_STORE_FAILED';
	exports[1539] = 'ER_EVENT_DOES_NOT_EXIST';
	exports[1540] = 'ER_EVENT_CANT_ALTER';
	exports[1541] = 'ER_EVENT_DROP_FAILED';
	exports[1542] = 'ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG';
	exports[1543] = 'ER_EVENT_ENDS_BEFORE_STARTS';
	exports[1544] = 'ER_EVENT_EXEC_TIME_IN_THE_PAST';
	exports[1545] = 'ER_EVENT_OPEN_TABLE_FAILED';
	exports[1546] = 'ER_EVENT_NEITHER_M_EXPR_NOR_M_AT';
	exports[1547] = 'ER_COL_COUNT_DOESNT_MATCH_CORRUPTED';
	exports[1548] = 'ER_CANNOT_LOAD_FROM_TABLE';
	exports[1549] = 'ER_EVENT_CANNOT_DELETE';
	exports[1550] = 'ER_EVENT_COMPILE_ERROR';
	exports[1551] = 'ER_EVENT_SAME_NAME';
	exports[1552] = 'ER_EVENT_DATA_TOO_LONG';
	exports[1553] = 'ER_DROP_INDEX_FK';
	exports[1554] = 'ER_WARN_DEPRECATED_SYNTAX_WITH_VER';
	exports[1555] = 'ER_CANT_WRITE_LOCK_LOG_TABLE';
	exports[1556] = 'ER_CANT_LOCK_LOG_TABLE';
	exports[1557] = 'ER_FOREIGN_DUPLICATE_KEY';
	exports[1558] = 'ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE';
	exports[1559] = 'ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR';
	exports[1560] = 'ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT';
	exports[1561] = 'ER_NDB_CANT_SWITCH_BINLOG_FORMAT';
	exports[1562] = 'ER_PARTITION_NO_TEMPORARY';
	exports[1563] = 'ER_PARTITION_CONST_DOMAIN_ERROR';
	exports[1564] = 'ER_PARTITION_FUNCTION_IS_NOT_ALLOWED';
	exports[1565] = 'ER_DDL_LOG_ERROR';
	exports[1566] = 'ER_NULL_IN_VALUES_LESS_THAN';
	exports[1567] = 'ER_WRONG_PARTITION_NAME';
	exports[1568] = 'ER_CANT_CHANGE_TX_CHARACTERISTICS';
	exports[1569] = 'ER_DUP_ENTRY_AUTOINCREMENT_CASE';
	exports[1570] = 'ER_EVENT_MODIFY_QUEUE_ERROR';
	exports[1571] = 'ER_EVENT_SET_VAR_ERROR';
	exports[1572] = 'ER_PARTITION_MERGE_ERROR';
	exports[1573] = 'ER_CANT_ACTIVATE_LOG';
	exports[1574] = 'ER_RBR_NOT_AVAILABLE';
	exports[1575] = 'ER_BASE64_DECODE_ERROR';
	exports[1576] = 'ER_EVENT_RECURSION_FORBIDDEN';
	exports[1577] = 'ER_EVENTS_DB_ERROR';
	exports[1578] = 'ER_ONLY_INTEGERS_ALLOWED';
	exports[1579] = 'ER_UNSUPORTED_LOG_ENGINE';
	exports[1580] = 'ER_BAD_LOG_STATEMENT';
	exports[1581] = 'ER_CANT_RENAME_LOG_TABLE';
	exports[1582] = 'ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT';
	exports[1583] = 'ER_WRONG_PARAMETERS_TO_NATIVE_FCT';
	exports[1584] = 'ER_WRONG_PARAMETERS_TO_STORED_FCT';
	exports[1585] = 'ER_NATIVE_FCT_NAME_COLLISION';
	exports[1586] = 'ER_DUP_ENTRY_WITH_KEY_NAME';
	exports[1587] = 'ER_BINLOG_PURGE_EMFILE';
	exports[1588] = 'ER_EVENT_CANNOT_CREATE_IN_THE_PAST';
	exports[1589] = 'ER_EVENT_CANNOT_ALTER_IN_THE_PAST';
	exports[1590] = 'ER_SLAVE_INCIDENT';
	exports[1591] = 'ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT';
	exports[1592] = 'ER_BINLOG_UNSAFE_STATEMENT';
	exports[1593] = 'ER_SLAVE_FATAL_ERROR';
	exports[1594] = 'ER_SLAVE_RELAY_LOG_READ_FAILURE';
	exports[1595] = 'ER_SLAVE_RELAY_LOG_WRITE_FAILURE';
	exports[1596] = 'ER_SLAVE_CREATE_EVENT_FAILURE';
	exports[1597] = 'ER_SLAVE_MASTER_COM_FAILURE';
	exports[1598] = 'ER_BINLOG_LOGGING_IMPOSSIBLE';
	exports[1599] = 'ER_VIEW_NO_CREATION_CTX';
	exports[1600] = 'ER_VIEW_INVALID_CREATION_CTX';
	exports[1601] = 'ER_SR_INVALID_CREATION_CTX';
	exports[1602] = 'ER_TRG_CORRUPTED_FILE';
	exports[1603] = 'ER_TRG_NO_CREATION_CTX';
	exports[1604] = 'ER_TRG_INVALID_CREATION_CTX';
	exports[1605] = 'ER_EVENT_INVALID_CREATION_CTX';
	exports[1606] = 'ER_TRG_CANT_OPEN_TABLE';
	exports[1607] = 'ER_CANT_CREATE_SROUTINE';
	exports[1608] = 'ER_NEVER_USED';
	exports[1609] = 'ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT';
	exports[1610] = 'ER_SLAVE_CORRUPT_EVENT';
	exports[1611] = 'ER_LOAD_DATA_INVALID_COLUMN';
	exports[1612] = 'ER_LOG_PURGE_NO_FILE';
	exports[1613] = 'ER_XA_RBTIMEOUT';
	exports[1614] = 'ER_XA_RBDEADLOCK';
	exports[1615] = 'ER_NEED_REPREPARE';
	exports[1616] = 'ER_DELAYED_NOT_SUPPORTED';
	exports[1617] = 'WARN_NO_MASTER_INFO';
	exports[1618] = 'WARN_OPTION_IGNORED';
	exports[1619] = 'WARN_PLUGIN_DELETE_BUILTIN';
	exports[1620] = 'WARN_PLUGIN_BUSY';
	exports[1621] = 'ER_VARIABLE_IS_READONLY';
	exports[1622] = 'ER_WARN_ENGINE_TRANSACTION_ROLLBACK';
	exports[1623] = 'ER_SLAVE_HEARTBEAT_FAILURE';
	exports[1624] = 'ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE';
	exports[1625] = 'ER_NDB_REPLICATION_SCHEMA_ERROR';
	exports[1626] = 'ER_CONFLICT_FN_PARSE_ERROR';
	exports[1627] = 'ER_EXCEPTIONS_WRITE_ERROR';
	exports[1628] = 'ER_TOO_LONG_TABLE_COMMENT';
	exports[1629] = 'ER_TOO_LONG_FIELD_COMMENT';
	exports[1630] = 'ER_FUNC_INEXISTENT_NAME_COLLISION';
	exports[1631] = 'ER_DATABASE_NAME';
	exports[1632] = 'ER_TABLE_NAME';
	exports[1633] = 'ER_PARTITION_NAME';
	exports[1634] = 'ER_SUBPARTITION_NAME';
	exports[1635] = 'ER_TEMPORARY_NAME';
	exports[1636] = 'ER_RENAMED_NAME';
	exports[1637] = 'ER_TOO_MANY_CONCURRENT_TRXS';
	exports[1638] = 'WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED';
	exports[1639] = 'ER_DEBUG_SYNC_TIMEOUT';
	exports[1640] = 'ER_DEBUG_SYNC_HIT_LIMIT';
	exports[1641] = 'ER_DUP_SIGNAL_SET';
	exports[1642] = 'ER_SIGNAL_WARN';
	exports[1643] = 'ER_SIGNAL_NOT_FOUND';
	exports[1644] = 'ER_SIGNAL_EXCEPTION';
	exports[1645] = 'ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER';
	exports[1646] = 'ER_SIGNAL_BAD_CONDITION_TYPE';
	exports[1647] = 'WARN_COND_ITEM_TRUNCATED';
	exports[1648] = 'ER_COND_ITEM_TOO_LONG';
	exports[1649] = 'ER_UNKNOWN_LOCALE';
	exports[1650] = 'ER_SLAVE_IGNORE_SERVER_IDS';
	exports[1651] = 'ER_QUERY_CACHE_DISABLED';
	exports[1652] = 'ER_SAME_NAME_PARTITION_FIELD';
	exports[1653] = 'ER_PARTITION_COLUMN_LIST_ERROR';
	exports[1654] = 'ER_WRONG_TYPE_COLUMN_VALUE_ERROR';
	exports[1655] = 'ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR';
	exports[1656] = 'ER_MAXVALUE_IN_VALUES_IN';
	exports[1657] = 'ER_TOO_MANY_VALUES_ERROR';
	exports[1658] = 'ER_ROW_SINGLE_PARTITION_FIELD_ERROR';
	exports[1659] = 'ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD';
	exports[1660] = 'ER_PARTITION_FIELDS_TOO_LONG';
	exports[1661] = 'ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE';
	exports[1662] = 'ER_BINLOG_ROW_MODE_AND_STMT_ENGINE';
	exports[1663] = 'ER_BINLOG_UNSAFE_AND_STMT_ENGINE';
	exports[1664] = 'ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE';
	exports[1665] = 'ER_BINLOG_STMT_MODE_AND_ROW_ENGINE';
	exports[1666] = 'ER_BINLOG_ROW_INJECTION_AND_STMT_MODE';
	exports[1667] = 'ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE';
	exports[1668] = 'ER_BINLOG_UNSAFE_LIMIT';
	exports[1669] = 'ER_BINLOG_UNSAFE_INSERT_DELAYED';
	exports[1670] = 'ER_BINLOG_UNSAFE_SYSTEM_TABLE';
	exports[1671] = 'ER_BINLOG_UNSAFE_AUTOINC_COLUMNS';
	exports[1672] = 'ER_BINLOG_UNSAFE_UDF';
	exports[1673] = 'ER_BINLOG_UNSAFE_SYSTEM_VARIABLE';
	exports[1674] = 'ER_BINLOG_UNSAFE_SYSTEM_FUNCTION';
	exports[1675] = 'ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS';
	exports[1676] = 'ER_MESSAGE_AND_STATEMENT';
	exports[1677] = 'ER_SLAVE_CONVERSION_FAILED';
	exports[1678] = 'ER_SLAVE_CANT_CREATE_CONVERSION';
	exports[1679] = 'ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT';
	exports[1680] = 'ER_PATH_LENGTH';
	exports[1681] = 'ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT';
	exports[1682] = 'ER_WRONG_NATIVE_TABLE_STRUCTURE';
	exports[1683] = 'ER_WRONG_PERFSCHEMA_USAGE';
	exports[1684] = 'ER_WARN_I_S_SKIPPED_TABLE';
	exports[1685] = 'ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT';
	exports[1686] = 'ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT';
	exports[1687] = 'ER_SPATIAL_MUST_HAVE_GEOM_COL';
	exports[1688] = 'ER_TOO_LONG_INDEX_COMMENT';
	exports[1689] = 'ER_LOCK_ABORTED';
	exports[1690] = 'ER_DATA_OUT_OF_RANGE';
	exports[1691] = 'ER_WRONG_SPVAR_TYPE_IN_LIMIT';
	exports[1692] = 'ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE';
	exports[1693] = 'ER_BINLOG_UNSAFE_MIXED_STATEMENT';
	exports[1694] = 'ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN';
	exports[1695] = 'ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN';
	exports[1696] = 'ER_FAILED_READ_FROM_PAR_FILE';
	exports[1697] = 'ER_VALUES_IS_NOT_INT_TYPE_ERROR';
	exports[1698] = 'ER_ACCESS_DENIED_NO_PASSWORD_ERROR';
	exports[1699] = 'ER_SET_PASSWORD_AUTH_PLUGIN';
	exports[1700] = 'ER_GRANT_PLUGIN_USER_EXISTS';
	exports[1701] = 'ER_TRUNCATE_ILLEGAL_FK';
	exports[1702] = 'ER_PLUGIN_IS_PERMANENT';
	exports[1703] = 'ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN';
	exports[1704] = 'ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX';
	exports[1705] = 'ER_STMT_CACHE_FULL';
	exports[1706] = 'ER_MULTI_UPDATE_KEY_CONFLICT';
	exports[1707] = 'ER_TABLE_NEEDS_REBUILD';
	exports[1708] = 'WARN_OPTION_BELOW_LIMIT';
	exports[1709] = 'ER_INDEX_COLUMN_TOO_LONG';
	exports[1710] = 'ER_ERROR_IN_TRIGGER_BODY';
	exports[1711] = 'ER_ERROR_IN_UNKNOWN_TRIGGER_BODY';
	exports[1712] = 'ER_INDEX_CORRUPT';
	exports[1713] = 'ER_UNDO_RECORD_TOO_BIG';
	exports[1714] = 'ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT';
	exports[1715] = 'ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE';
	exports[1716] = 'ER_BINLOG_UNSAFE_REPLACE_SELECT';
	exports[1717] = 'ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT';
	exports[1718] = 'ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT';
	exports[1719] = 'ER_BINLOG_UNSAFE_UPDATE_IGNORE';
	exports[1720] = 'ER_PLUGIN_NO_UNINSTALL';
	exports[1721] = 'ER_PLUGIN_NO_INSTALL';
	exports[1722] = 'ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT';
	exports[1723] = 'ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC';
	exports[1724] = 'ER_BINLOG_UNSAFE_INSERT_TWO_KEYS';
	exports[1725] = 'ER_TABLE_IN_FK_CHECK';
	exports[1726] = 'ER_UNSUPPORTED_ENGINE';
	exports[1727] = 'ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST';
	exports[1728] = 'ER_CANNOT_LOAD_FROM_TABLE_V2';
	exports[1729] = 'ER_MASTER_DELAY_VALUE_OUT_OF_RANGE';
	exports[1730] = 'ER_ONLY_FD_AND_RBR_EVENTS_ALLOWED_IN_BINLOG_STATEMENT';
	exports[1731] = 'ER_PARTITION_EXCHANGE_DIFFERENT_OPTION';
	exports[1732] = 'ER_PARTITION_EXCHANGE_PART_TABLE';
	exports[1733] = 'ER_PARTITION_EXCHANGE_TEMP_TABLE';
	exports[1734] = 'ER_PARTITION_INSTEAD_OF_SUBPARTITION';
	exports[1735] = 'ER_UNKNOWN_PARTITION';
	exports[1736] = 'ER_TABLES_DIFFERENT_METADATA';
	exports[1737] = 'ER_ROW_DOES_NOT_MATCH_PARTITION';
	exports[1738] = 'ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX';
	exports[1739] = 'ER_WARN_INDEX_NOT_APPLICABLE';
	exports[1740] = 'ER_PARTITION_EXCHANGE_FOREIGN_KEY';
	exports[1741] = 'ER_NO_SUCH_KEY_VALUE';
	exports[1742] = 'ER_RPL_INFO_DATA_TOO_LONG';
	exports[1743] = 'ER_NETWORK_READ_EVENT_CHECKSUM_FAILURE';
	exports[1744] = 'ER_BINLOG_READ_EVENT_CHECKSUM_FAILURE';
	exports[1745] = 'ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX';
	exports[1746] = 'ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT';
	exports[1747] = 'ER_PARTITION_CLAUSE_ON_NONPARTITIONED';
	exports[1748] = 'ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET';
	exports[1749] = 'ER_NO_SUCH_PARTITION';
	exports[1750] = 'ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE';
	exports[1751] = 'ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE';
	exports[1752] = 'ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE';
	exports[1753] = 'ER_MTS_FEATURE_IS_NOT_SUPPORTED';
	exports[1754] = 'ER_MTS_UPDATED_DBS_GREATER_MAX';
	exports[1755] = 'ER_MTS_CANT_PARALLEL';
	exports[1756] = 'ER_MTS_INCONSISTENT_DATA';
	exports[1757] = 'ER_FULLTEXT_NOT_SUPPORTED_WITH_PARTITIONING';
	exports[1758] = 'ER_DA_INVALID_CONDITION_NUMBER';
	exports[1759] = 'ER_INSECURE_PLAIN_TEXT';
	exports[1760] = 'ER_INSECURE_CHANGE_MASTER';
	exports[1761] = 'ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO';
	exports[1762] = 'ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO';
	exports[1763] = 'ER_SQLTHREAD_WITH_SECURE_SLAVE';
	exports[1764] = 'ER_TABLE_HAS_NO_FT';
	exports[1765] = 'ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER';
	exports[1766] = 'ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION';
	exports[1767] = 'ER_GTID_NEXT_IS_NOT_IN_GTID_NEXT_LIST';
	exports[1768] = 'ER_CANT_CHANGE_GTID_NEXT_IN_TRANSACTION_WHEN_GTID_NEXT_LIST_IS_NULL';
	exports[1769] = 'ER_SET_STATEMENT_CANNOT_INVOKE_FUNCTION';
	exports[1770] = 'ER_GTID_NEXT_CANT_BE_AUTOMATIC_IF_GTID_NEXT_LIST_IS_NON_NULL';
	exports[1771] = 'ER_SKIPPING_LOGGED_TRANSACTION';
	exports[1772] = 'ER_MALFORMED_GTID_SET_SPECIFICATION';
	exports[1773] = 'ER_MALFORMED_GTID_SET_ENCODING';
	exports[1774] = 'ER_MALFORMED_GTID_SPECIFICATION';
	exports[1775] = 'ER_GNO_EXHAUSTED';
	exports[1776] = 'ER_BAD_SLAVE_AUTO_POSITION';
	exports[1777] = 'ER_AUTO_POSITION_REQUIRES_GTID_MODE_ON';
	exports[1778] = 'ER_CANT_DO_IMPLICIT_COMMIT_IN_TRX_WHEN_GTID_NEXT_IS_SET';
	exports[1779] = 'ER_GTID_MODE_2_OR_3_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON';
	exports[1780] = 'ER_GTID_MODE_REQUIRES_BINLOG';
	exports[1781] = 'ER_CANT_SET_GTID_NEXT_TO_GTID_WHEN_GTID_MODE_IS_OFF';
	exports[1782] = 'ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON';
	exports[1783] = 'ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF';
	exports[1784] = 'ER_FOUND_GTID_EVENT_WHEN_GTID_MODE_IS_OFF';
	exports[1785] = 'ER_GTID_UNSAFE_NON_TRANSACTIONAL_TABLE';
	exports[1786] = 'ER_GTID_UNSAFE_CREATE_SELECT';
	exports[1787] = 'ER_GTID_UNSAFE_CREATE_DROP_TEMPORARY_TABLE_IN_TRANSACTION';
	exports[1788] = 'ER_GTID_MODE_CAN_ONLY_CHANGE_ONE_STEP_AT_A_TIME';
	exports[1789] = 'ER_MASTER_HAS_PURGED_REQUIRED_GTIDS';
	exports[1790] = 'ER_CANT_SET_GTID_NEXT_WHEN_OWNING_GTID';
	exports[1791] = 'ER_UNKNOWN_EXPLAIN_FORMAT';
	exports[1792] = 'ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION';
	exports[1793] = 'ER_TOO_LONG_TABLE_PARTITION_COMMENT';
	exports[1794] = 'ER_SLAVE_CONFIGURATION';
	exports[1795] = 'ER_INNODB_FT_LIMIT';
	exports[1796] = 'ER_INNODB_NO_FT_TEMP_TABLE';
	exports[1797] = 'ER_INNODB_FT_WRONG_DOCID_COLUMN';
	exports[1798] = 'ER_INNODB_FT_WRONG_DOCID_INDEX';
	exports[1799] = 'ER_INNODB_ONLINE_LOG_TOO_BIG';
	exports[1800] = 'ER_UNKNOWN_ALTER_ALGORITHM';
	exports[1801] = 'ER_UNKNOWN_ALTER_LOCK';
	exports[1802] = 'ER_MTS_CHANGE_MASTER_CANT_RUN_WITH_GAPS';
	exports[1803] = 'ER_MTS_RECOVERY_FAILURE';
	exports[1804] = 'ER_MTS_RESET_WORKERS';
	exports[1805] = 'ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2';
	exports[1806] = 'ER_SLAVE_SILENT_RETRY_TRANSACTION';
	exports[1807] = 'ER_DISCARD_FK_CHECKS_RUNNING';
	exports[1808] = 'ER_TABLE_SCHEMA_MISMATCH';
	exports[1809] = 'ER_TABLE_IN_SYSTEM_TABLESPACE';
	exports[1810] = 'ER_IO_READ_ERROR';
	exports[1811] = 'ER_IO_WRITE_ERROR';
	exports[1812] = 'ER_TABLESPACE_MISSING';
	exports[1813] = 'ER_TABLESPACE_EXISTS';
	exports[1814] = 'ER_TABLESPACE_DISCARDED';
	exports[1815] = 'ER_INTERNAL_ERROR';
	exports[1816] = 'ER_INNODB_IMPORT_ERROR';
	exports[1817] = 'ER_INNODB_INDEX_CORRUPT';
	exports[1818] = 'ER_INVALID_YEAR_COLUMN_LENGTH';
	exports[1819] = 'ER_NOT_VALID_PASSWORD';
	exports[1820] = 'ER_MUST_CHANGE_PASSWORD';
	exports[1821] = 'ER_FK_NO_INDEX_CHILD';
	exports[1822] = 'ER_FK_NO_INDEX_PARENT';
	exports[1823] = 'ER_FK_FAIL_ADD_SYSTEM';
	exports[1824] = 'ER_FK_CANNOT_OPEN_PARENT';
	exports[1825] = 'ER_FK_INCORRECT_OPTION';
	exports[1826] = 'ER_FK_DUP_NAME';
	exports[1827] = 'ER_PASSWORD_FORMAT';
	exports[1828] = 'ER_FK_COLUMN_CANNOT_DROP';
	exports[1829] = 'ER_FK_COLUMN_CANNOT_DROP_CHILD';
	exports[1830] = 'ER_FK_COLUMN_NOT_NULL';
	exports[1831] = 'ER_DUP_INDEX';
	exports[1832] = 'ER_FK_COLUMN_CANNOT_CHANGE';
	exports[1833] = 'ER_FK_COLUMN_CANNOT_CHANGE_CHILD';
	exports[1834] = 'ER_FK_CANNOT_DELETE_PARENT';
	exports[1835] = 'ER_MALFORMED_PACKET';
	exports[1836] = 'ER_READ_ONLY_MODE';
	exports[1837] = 'ER_GTID_NEXT_TYPE_UNDEFINED_GROUP';
	exports[1838] = 'ER_VARIABLE_NOT_SETTABLE_IN_SP';
	exports[1839] = 'ER_CANT_SET_GTID_PURGED_WHEN_GTID_MODE_IS_OFF';
	exports[1840] = 'ER_CANT_SET_GTID_PURGED_WHEN_GTID_EXECUTED_IS_NOT_EMPTY';
	exports[1841] = 'ER_CANT_SET_GTID_PURGED_WHEN_OWNED_GTIDS_IS_NOT_EMPTY';
	exports[1842] = 'ER_GTID_PURGED_WAS_CHANGED';
	exports[1843] = 'ER_GTID_EXECUTED_WAS_CHANGED';
	exports[1844] = 'ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES';
	exports[1845] = 'ER_ALTER_OPERATION_NOT_SUPPORTED';
	exports[1846] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON';
	exports[1847] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY';
	exports[1848] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_PARTITION';
	exports[1849] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_RENAME';
	exports[1850] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE';
	exports[1851] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_CHECK';
	exports[1852] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_IGNORE';
	exports[1853] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOPK';
	exports[1854] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_AUTOINC';
	exports[1855] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_HIDDEN_FTS';
	exports[1856] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_CHANGE_FTS';
	exports[1857] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FTS';
	exports[1858] = 'ER_SQL_SLAVE_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE';
	exports[1859] = 'ER_DUP_UNKNOWN_IN_INDEX';
	exports[1860] = 'ER_IDENT_CAUSES_TOO_LONG_PATH';
	exports[1861] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOT_NULL';
	exports[1862] = 'ER_MUST_CHANGE_PASSWORD_LOGIN';
	exports[1863] = 'ER_ROW_IN_WRONG_PARTITION';
	exports[1864] = 'ER_MTS_EVENT_BIGGER_PENDING_JOBS_SIZE_MAX';
	exports[1865] = 'ER_INNODB_NO_FT_USES_PARSER';
	exports[1866] = 'ER_BINLOG_LOGICAL_CORRUPTION';
	exports[1867] = 'ER_WARN_PURGE_LOG_IN_USE';
	exports[1868] = 'ER_WARN_PURGE_LOG_IS_ACTIVE';
	exports[1869] = 'ER_AUTO_INCREMENT_CONFLICT';
	exports[1870] = 'WARN_ON_BLOCKHOLE_IN_RBR';
	exports[1871] = 'ER_SLAVE_MI_INIT_REPOSITORY';
	exports[1872] = 'ER_SLAVE_RLI_INIT_REPOSITORY';
	exports[1873] = 'ER_ACCESS_DENIED_CHANGE_USER_ERROR';
	exports[1874] = 'ER_INNODB_READ_ONLY';
	exports[1875] = 'ER_STOP_SLAVE_SQL_THREAD_TIMEOUT';
	exports[1876] = 'ER_STOP_SLAVE_IO_THREAD_TIMEOUT';
	exports[1877] = 'ER_TABLE_CORRUPT';
	exports[1878] = 'ER_TEMP_FILE_WRITE_FAILURE';
	exports[1879] = 'ER_INNODB_FT_AUX_NOT_HEX_ID';
	exports[1880] = 'ER_OLD_TEMPORALS_UPGRADED';
	exports[1881] = 'ER_INNODB_FORCED_RECOVERY';
	exports[1882] = 'ER_AES_INVALID_IV';


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var Buffer = __webpack_require__(59).Buffer;
	var Crypto = __webpack_require__(18);
	var Auth   = exports;
	
	function sha1(msg) {
	  var hash = Crypto.createHash('sha1');
	  hash.update(msg, 'binary');
	  return hash.digest('binary');
	}
	Auth.sha1 = sha1;
	
	function xor(a, b) {
	  a = new Buffer(a, 'binary');
	  b = new Buffer(b, 'binary');
	  var result = new Buffer(a.length);
	  for (var i = 0; i < a.length; i++) {
	    result[i] = (a[i] ^ b[i]);
	  }
	  return result;
	};
	Auth.xor = xor;
	
	Auth.token = function(password, scramble) {
	  if (!password) {
	    return new Buffer(0);
	  }
	
	  // password must be in binary format, not utf8
	  var stage1 = sha1((new Buffer(password, "utf8")).toString("binary"));
	  var stage2 = sha1(stage1);
	  var stage3 = sha1(scramble.toString('binary') + stage2);
	  return xor(stage3, stage1);
	};
	
	// This is a port of sql/password.c:hash_password which needs to be used for
	// pre-4.1 passwords.
	Auth.hashPassword = function(password) {
	  var nr = [0x5030, 0x5735],
	      add = 7,
	      nr2 = [0x1234, 0x5671],
	      result = new Buffer(8);
	
	  if (typeof password == 'string'){
	    password = new Buffer(password);
	  }
	
	  for (var i = 0; i < password.length; i++) {
	    var c = password[i];
	    if (c == 32 || c == 9) {
	      // skip space in password
	      continue;
	    }
	
	    // nr^= (((nr & 63)+add)*c)+ (nr << 8);
	    // nr = xor(nr, add(mul(add(and(nr, 63), add), c), shl(nr, 8)))
	    nr = this.xor32(nr, this.add32(this.mul32(this.add32(this.and32(nr, [0,63]), [0,add]), [0,c]), this.shl32(nr, 8)));
	
	    // nr2+=(nr2 << 8) ^ nr;
	    // nr2 = add(nr2, xor(shl(nr2, 8), nr))
	    nr2 = this.add32(nr2, this.xor32(this.shl32(nr2, 8), nr));
	
	    // add+=tmp;
	    add += c;
	  }
	
	  this.int31Write(result, nr, 0);
	  this.int31Write(result, nr2, 4);
	
	  return result;
	};
	
	Auth.randomInit = function(seed1, seed2) {
	  return {
	    max_value: 0x3FFFFFFF,
	    max_value_dbl: 0x3FFFFFFF,
	    seed1: seed1 % 0x3FFFFFFF,
	    seed2: seed2 % 0x3FFFFFFF
	  };
	};
	
	Auth.myRnd = function(r){
	  r.seed1 = (r.seed1 * 3 + r.seed2) % r.max_value;
	  r.seed2 = (r.seed1 + r.seed2 + 33) % r.max_value;
	
	  return r.seed1 / r.max_value_dbl;
	};
	
	Auth.scramble323 = function(message, password) {
	  var to = new Buffer(8),
	      hashPass = this.hashPassword(password),
	      hashMessage = this.hashPassword(message.slice(0, 8)),
	      seed1 = this.int32Read(hashPass, 0) ^ this.int32Read(hashMessage, 0),
	      seed2 = this.int32Read(hashPass, 4) ^ this.int32Read(hashMessage, 4),
	      r = this.randomInit(seed1, seed2);
	
	  for (var i = 0; i < 8; i++){
	    to[i] = Math.floor(this.myRnd(r) * 31) + 64;
	  }
	  var extra = (Math.floor(this.myRnd(r) * 31));
	
	  for (var i = 0; i < 8; i++){
	    to[i] ^= extra;
	  }
	
	  return to;
	};
	
	Auth.fmt32 = function(x){
	  var a = x[0].toString(16),
	      b = x[1].toString(16);
	
	  if (a.length == 1) a = '000'+a;
	  if (a.length == 2) a = '00'+a;
	  if (a.length == 3) a = '0'+a;
	  if (b.length == 1) b = '000'+b;
	  if (b.length == 2) b = '00'+b;
	  if (b.length == 3) b = '0'+b;
	  return '' + a + '/' + b;
	};
	
	Auth.xor32 = function(a,b){
	  return [a[0] ^ b[0], a[1] ^ b[1]];
	};
	
	Auth.add32 = function(a,b){
	  var w1 = a[1] + b[1],
	      w2 = a[0] + b[0] + ((w1 & 0xFFFF0000) >> 16);
	
	  return [w2 & 0xFFFF, w1 & 0xFFFF];
	};
	
	Auth.mul32 = function(a,b){
	  // based on this example of multiplying 32b ints using 16b
	  // http://www.dsprelated.com/showmessage/89790/1.php
	  var w1 = a[1] * b[1],
	      w2 = (((a[1] * b[1]) >> 16) & 0xFFFF) + ((a[0] * b[1]) & 0xFFFF) + (a[1] * b[0] & 0xFFFF);
	
	  return [w2 & 0xFFFF, w1 & 0xFFFF];
	};
	
	Auth.and32 = function(a,b){
	  return [a[0] & b[0], a[1] & b[1]];
	};
	
	Auth.shl32 = function(a,b){
	  // assume b is 16 or less
	  var w1 = a[1] << b,
	      w2 = (a[0] << b) | ((w1 & 0xFFFF0000) >> 16);
	
	  return [w2 & 0xFFFF, w1 & 0xFFFF];
	};
	
	Auth.int31Write = function(buffer, number, offset) {
	  buffer[offset] = (number[0] >> 8) & 0x7F;
	  buffer[offset + 1] = (number[0]) & 0xFF;
	  buffer[offset + 2] = (number[1] >> 8) & 0xFF;
	  buffer[offset + 3] = (number[1]) & 0xFF;
	};
	
	Auth.int32Read = function(buffer, offset){
	  return (buffer[offset] << 24)
	       + (buffer[offset+1] << 16)
	       + (buffer[offset+2] << 8)
	       + (buffer[offset+3]);
	};


/***/ },
/* 59 */
/***/ function(module, exports) {

	module.exports = require("buffer");

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var Sequence        = __webpack_require__(32);
	var Util            = __webpack_require__(33);
	var Packets         = __webpack_require__(35);
	var Auth            = __webpack_require__(58);
	var ClientConstants = __webpack_require__(23);
	
	module.exports = Handshake;
	Util.inherits(Handshake, Sequence);
	function Handshake(options, callback) {
	  Sequence.call(this, options, callback);
	
	  options = options || {};
	
	  this._config                        = options.config;
	  this._handshakeInitializationPacket = null;
	}
	
	Handshake.prototype.determinePacket = function(firstByte) {
	  if (firstByte === 0xff) {
	    return Packets.ErrorPacket;
	  }
	
	  if (!this._handshakeInitializationPacket) {
	    return Packets.HandshakeInitializationPacket;
	  }
	
	  if (firstByte === 0xfe) {
	    return Packets.UseOldPasswordPacket;
	  }
	};
	
	Handshake.prototype['HandshakeInitializationPacket'] = function(packet) {
	  this._handshakeInitializationPacket = packet;
	
	  this._config.protocol41 = packet.protocol41;
	
	  var serverSSLSupport = packet.serverCapabilities1 & ClientConstants.CLIENT_SSL; 
	
	  if (this._config.ssl) {
	    if (!serverSSLSupport) {
	      var err = new Error('Server does not support secure connnection');
	
	      err.code = 'HANDSHAKE_NO_SSL_SUPPORT';
	      err.fatal = true;
	
	      this.end(err);
	      return;
	    }
	
	    this._config.clientFlags |= ClientConstants.CLIENT_SSL;
	    this.emit('packet', new Packets.SSLRequestPacket({
	      clientFlags   : this._config.clientFlags,
	      maxPacketSize : this._config.maxPacketSize,
	      charsetNumber : this._config.charsetNumber
	    }));
	    this.emit('start-tls');
	  } else {
	    this._sendCredentials();
	  }
	};
	
	Handshake.prototype._tlsUpgradeCompleteHandler = function() {
	  this._sendCredentials();
	};
	
	Handshake.prototype._sendCredentials = function(serverHello) {
	  var packet = this._handshakeInitializationPacket;
	  this.emit('packet', new Packets.ClientAuthenticationPacket({
	    clientFlags   : this._config.clientFlags,
	    maxPacketSize : this._config.maxPacketSize,
	    charsetNumber : this._config.charsetNumber,
	    user          : this._config.user,
	    scrambleBuff  : (packet.protocol41)
	                     ? Auth.token(this._config.password, packet.scrambleBuff())
	                     : Auth.scramble323(packet.scrambleBuff(), this._config.password),
	    database      : this._config.database,
	    protocol41    : packet.protocol41
	  }));
	};
	
	Handshake.prototype['UseOldPasswordPacket'] = function(packet) {
	  if (!this._config.insecureAuth) {
	    var err = new Error(
	      'MySQL server is requesting the old and insecure pre-4.1 auth mechanism.' +
	      'Upgrade the user password or use the {insecureAuth: true} option.'
	    );
	
	    err.code = 'HANDSHAKE_INSECURE_AUTH';
	    err.fatal = true;
	
	    this.end(err);
	    return;
	  }
	
	  this.emit('packet', new Packets.OldPasswordPacket({
	    scrambleBuff : Auth.scramble323(this._handshakeInitializationPacket.scrambleBuff(), this._config.password),
	  }));
	};
	
	Handshake.prototype['ErrorPacket'] = function(packet) {
	  var err = this._packetToError(packet, true);
	  err.fatal = true;
	  this.end(err);
	};


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var Sequence = __webpack_require__(32);
	var Util     = __webpack_require__(33);
	var Packets  = __webpack_require__(35);
	
	module.exports = Ping;
	Util.inherits(Ping, Sequence);
	
	function Ping(options, callback) {
	  if (!callback && typeof options === 'function') {
	    callback = options;
	    options = {};
	  }
	
	  Sequence.call(this, options, callback);
	}
	
	Ping.prototype.start = function() {
	  this.emit('packet', new Packets.ComPingPacket);
	};


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var Sequence     = __webpack_require__(32);
	var Util         = __webpack_require__(33);
	var Packets      = __webpack_require__(35);
	var ResultSet    = __webpack_require__(63);
	var ServerStatus = __webpack_require__(64);
	var fs           = __webpack_require__(65);
	var Readable     = __webpack_require__(66);
	
	module.exports = Query;
	Util.inherits(Query, Sequence);
	function Query(options, callback) {
	  Sequence.call(this, options, callback);
	
	  this.sql = options.sql;
	  this.values = options.values;
	  this.typeCast = (options.typeCast === undefined)
	    ? true
	    : options.typeCast;
	  this.nestTables = options.nestTables || false;
	
	  this._resultSet = null;
	  this._results   = [];
	  this._fields    = [];
	  this._index     = 0;
	  this._loadError = null;
	}
	
	Query.prototype.start = function() {
	  this.emit('packet', new Packets.ComQueryPacket(this.sql));
	};
	
	Query.prototype.determinePacket = function(firstByte, parser) {
	  if (firstByte === 0) {
	    // If we have a resultSet and got one eofPacket
	    if (this._resultSet && this._resultSet.eofPackets.length === 1) {
	      // Then this is a RowDataPacket with an empty string in the first column.
	      // See: https://github.com/felixge/node-mysql/issues/222
	    } else if (this._resultSet && this._resultSet.resultSetHeaderPacket
	           && this._resultSet.resultSetHeaderPacket.fieldCount !== null) {
	      return Packets.FieldPacket;
	    } else {
	      return;
	    }
	  }
	
	  if (firstByte === 255) {
	    return;
	  }
	
	  // EofPacket's are 5 bytes in mysql >= 4.1
	  // This is the only / best way to differentiate their firstByte from a 9
	  // byte length coded binary.
	  if (firstByte === 0xfe && parser.packetLength() < 9) {
	    return Packets.EofPacket;
	  }
	
	  if (!this._resultSet) {
	    return Packets.ResultSetHeaderPacket;
	  }
	
	  return (this._resultSet.eofPackets.length === 0)
	    ? Packets.FieldPacket
	    : Packets.RowDataPacket;
	};
	
	Query.prototype['OkPacket'] = function(packet) {
	  // try...finally for exception safety
	  try {
	    if (!this._callback) {
	      this.emit('result', packet, this._index);
	    } else {
	      this._results.push(packet);
	      this._fields.push(undefined);
	    }
	  } finally {
	    this._index++;
	    this._resultSet = null;
	    this._handleFinalResultPacket(packet);
	  }
	};
	
	Query.prototype['ErrorPacket'] = function(packet) {
	  var err = this._packetToError(packet);
	
	  var results = (this._results.length > 0)
	    ? this._results
	    : undefined;
	
	  var fields = (this._fields.length > 0)
	    ? this._fields
	    : undefined;
	
	  err.index = this._index;
	  this.end(err, results, fields);
	};
	
	Query.prototype['ResultSetHeaderPacket'] = function(packet) {
	  this._resultSet = new ResultSet(packet);
	
	  // used by LOAD DATA LOCAL INFILE queries
	  if (packet.fieldCount === null) {
	    this._sendLocalDataFile(packet.extra);
	  }
	};
	
	Query.prototype['FieldPacket'] = function(packet) {
	  this._resultSet.fieldPackets.push(packet);
	};
	
	Query.prototype['EofPacket'] = function(packet) {
	  this._resultSet.eofPackets.push(packet);
	
	  if (this._resultSet.eofPackets.length === 1 && !this._callback) {
	    this.emit('fields', this._resultSet.fieldPackets, this._index);
	  }
	
	  if (this._resultSet.eofPackets.length !== 2) {
	    return;
	  }
	
	  if (this._callback) {
	    this._results.push(this._resultSet.rows);
	    this._fields.push(this._resultSet.fieldPackets);
	  }
	
	  this._index++;
	  this._resultSet = null;
	  this._handleFinalResultPacket(packet);
	};
	
	Query.prototype._handleFinalResultPacket = function(packet) {
	  if (packet.serverStatus & ServerStatus.SERVER_MORE_RESULTS_EXISTS) {
	    return;
	  }
	
	  var results = (this._results.length > 1)
	    ? this._results
	    : this._results[0];
	
	  var fields = (this._fields.length > 1)
	    ? this._fields
	    : this._fields[0];
	
	  this.end(this._loadError, results, fields);
	};
	
	Query.prototype['RowDataPacket'] = function(packet, parser, connection) {
	  packet.parse(parser, this._resultSet.fieldPackets, this.typeCast, this.nestTables, connection);
	
	  if (this._callback) {
	    this._resultSet.rows.push(packet);
	  } else {
	    this.emit('result', packet, this._index);
	  }
	};
	
	Query.prototype._sendLocalDataFile = function(path) {
	  var self = this;
	  var localStream = fs.createReadStream(path, {
	    'flag': 'r',
	    'encoding': null,
	    'autoClose': true
	  });
	
	
	  this.on('pause', function () {
	    localStream.pause();
	  });
	
	  this.on('resume', function () {
	    localStream.resume();
	  });
	
	  localStream.on('data', function (data) {
	    self.emit('packet', new Packets.LocalDataFilePacket(data));
	  });
	
	  localStream.on('error', function (err) {
	    self._loadError = err;
	    localStream.emit('end');
	  });
	
	  localStream.on('end', function () {
	    self.emit('packet', new Packets.EmptyPacket());
	  });
	};
	
	Query.prototype.stream = function(options) {
	  var self = this,
	      stream;
	
	  options = options || {};
	  options.objectMode = true;
	  stream = new Readable(options);
	
	  stream._read = function() {
	    self._connection && self._connection.resume();
	  };
	
	  this.on('result',function(row,i) {
	    if (!stream.push(row)) self._connection.pause();
	    stream.emit('result',row,i);  // replicate old emitter
	  });
	
	  this.on('error',function(err) {
	    stream.emit('error',err);  // Pass on any errors
	  });
	
	  this.on('end', function() {
	    stream.emit('close');  // notify readers that query has completed
	    stream.push(null);  // pushing null, indicating EOF
	  });
	
	  this.on('fields',function(fields,i) {
	    stream.emit('fields',fields,i);  // replicate old emitter
	  });
	
	  return stream;
	};


/***/ },
/* 63 */
/***/ function(module, exports) {

	module.exports = ResultSet;
	function ResultSet(resultSetHeaderPacket) {
	  this.resultSetHeaderPacket = resultSetHeaderPacket;
	  this.fieldPackets          = [];
	  this.eofPackets            = [];
	  this.rows                  = [];
	}


/***/ },
/* 64 */
/***/ function(module, exports) {

	// Manually extracted from mysql-5.5.23/include/mysql_com.h
	
	/**
	  Is raised when a multi-statement transaction
	  has been started, either explicitly, by means
	  of BEGIN or COMMIT AND CHAIN, or
	  implicitly, by the first transactional
	  statement, when autocommit=off.
	*/
	exports.SERVER_STATUS_IN_TRANS          = 1;
	exports.SERVER_STATUS_AUTOCOMMIT        = 2;  /* Server in auto_commit mode */
	exports.SERVER_MORE_RESULTS_EXISTS      = 8;    /* Multi query - next query exists */
	exports.SERVER_QUERY_NO_GOOD_INDEX_USED = 16;
	exports.SERVER_QUERY_NO_INDEX_USED      = 32;
	/**
	  The server was able to fulfill the clients request and opened a
	  read-only non-scrollable cursor for a query. This flag comes
	  in reply to COM_STMT_EXECUTE and COM_STMT_FETCH commands.
	*/
	exports.SERVER_STATUS_CURSOR_EXISTS = 64;
	/**
	  This flag is sent when a read-only cursor is exhausted, in reply to
	  COM_STMT_FETCH command.
	*/
	exports.SERVER_STATUS_LAST_ROW_SENT        = 128;
	exports.SERVER_STATUS_DB_DROPPED           = 256; /* A database was dropped */
	exports.SERVER_STATUS_NO_BACKSLASH_ESCAPES = 512;
	/**
	  Sent to the client if after a prepared statement reprepare
	  we discovered that the new statement returns a different 
	  number of result set columns.
	*/
	exports.SERVER_STATUS_METADATA_CHANGED = 1024;
	exports.SERVER_QUERY_WAS_SLOW          = 2048;
	
	/**
	  To mark ResultSet containing output parameter values.
	*/
	exports.SERVER_PS_OUT_PARAMS = 4096;


/***/ },
/* 65 */
/***/ function(module, exports) {

	module.exports = require("fs");

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(67);
	exports.Stream = __webpack_require__(69);
	exports.Readable = exports;
	exports.Writable = __webpack_require__(73);
	exports.Duplex = __webpack_require__(72);
	exports.Transform = __webpack_require__(75);
	exports.PassThrough = __webpack_require__(76);


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Readable;
	
	/*<replacement>*/
	var isArray = __webpack_require__(68);
	/*</replacement>*/
	
	
	/*<replacement>*/
	var Buffer = __webpack_require__(59).Buffer;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	var EE = __webpack_require__(34).EventEmitter;
	
	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	var Stream = __webpack_require__(69);
	
	/*<replacement>*/
	var util = __webpack_require__(70);
	util.inherits = __webpack_require__(71);
	/*</replacement>*/
	
	var StringDecoder;
	
	
	/*<replacement>*/
	var debug = __webpack_require__(33);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/
	
	
	util.inherits(Readable, Stream);
	
	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(72);
	
	  options = options || {};
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(74).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	function Readable(options) {
	  var Duplex = __webpack_require__(72);
	
	  if (!(this instanceof Readable))
	    return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  Stream.call(this);
	}
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;
	
	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }
	
	  return readableAddChunk(this, state, chunk, encoding, false);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);
	
	      if (!addToFront)
	        state.reading = false;
	
	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);
	
	        if (state.needReadable)
	          emitReadable(stream);
	      }
	
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	
	  return needMoreData(state);
	}
	
	
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(74).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};
	
	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}
	
	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;
	
	  if (state.objectMode)
	    return n === 0 ? 0 : 1;
	
	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }
	
	  if (n <= 0)
	    return 0;
	
	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);
	
	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }
	
	  return n;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;
	
	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }
	
	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }
	
	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);
	
	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;
	
	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }
	
	  state.length -= n;
	
	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;
	
	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);
	
	  if (!util.isNull(ret))
	    this.emit('data', ret);
	
	  return ret;
	};
	
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	
	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}
	
	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}
	
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};
	
	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;
	
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }
	
	  function onend() {
	    debug('onend');
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }
	
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];
	
	
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	
	
	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;
	
	    if (!dest)
	      dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	
	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }
	
	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;
	
	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }
	
	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};
	
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}
	
	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}
	
	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};
	
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;
	
	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }
	
	    self.push(null);
	  });
	
	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;
	
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }
	
	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return self;
	};
	
	
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;
	
	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;
	
	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);
	
	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);
	
	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);
	
	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();
	
	        c += cpy;
	      }
	    }
	  }
	
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');
	
	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}


/***/ },
/* 68 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 69 */
/***/ function(module, exports) {

	module.exports = require("stream");

/***/ },
/* 70 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	
	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = Buffer.isBuffer;
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(33).inherits


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/
	
	
	/*<replacement>*/
	var util = __webpack_require__(70);
	util.inherits = __webpack_require__(71);
	/*</replacement>*/
	
	var Readable = __webpack_require__(67);
	var Writable = __webpack_require__(73);
	
	util.inherits(Duplex, Readable);
	
	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});
	
	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false)
	    this.readable = false;
	
	  if (options && options.writable === false)
	    this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.
	
	module.exports = Writable;
	
	/*<replacement>*/
	var Buffer = __webpack_require__(59).Buffer;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	
	/*<replacement>*/
	var util = __webpack_require__(70);
	util.inherits = __webpack_require__(71);
	/*</replacement>*/
	
	var Stream = __webpack_require__(69);
	
	util.inherits(Writable, Stream);
	
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}
	
	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(72);
	
	  options = options || {};
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.buffer = [];
	
	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;
	
	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}
	
	function Writable(options) {
	  var Duplex = __webpack_require__(72);
	
	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};
	
	
	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}
	
	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	
	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;
	
	  if (!util.isFunction(cb))
	    cb = function() {};
	
	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }
	
	  return ret;
	};
	
	Writable.prototype.cork = function() {
	  var state = this._writableState;
	
	  state.corked++;
	};
	
	Writable.prototype.uncork = function() {
	  var state = this._writableState;
	
	  if (state.corked) {
	    state.corked--;
	
	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;
	
	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	
	  return ret;
	}
	
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }
	
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);
	
	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }
	
	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	
	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);
	
	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });
	
	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }
	
	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }
	
	  state.bufferProcessing = false;
	}
	
	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	
	};
	
	Writable.prototype._writev = null;
	
	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);
	
	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }
	
	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};
	
	
	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}
	
	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var Buffer = __webpack_require__(59).Buffer;
	
	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }
	
	
	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}
	
	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }
	
	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};
	
	
	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;
	
	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;
	
	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }
	
	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);
	
	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
	
	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;
	
	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }
	
	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);
	
	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }
	
	  charStr += buffer.toString(this.encoding, 0, end);
	
	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }
	
	  // or just emit the charStr
	  return charStr;
	};
	
	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;
	
	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];
	
	    // See http://en.wikipedia.org/wiki/UTF-8#Description
	
	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }
	
	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }
	
	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};
	
	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);
	
	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }
	
	  return res;
	};
	
	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}
	
	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}
	
	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	
	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(72);
	
	/*<replacement>*/
	var util = __webpack_require__(70);
	util.inherits = __webpack_require__(71);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	
	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };
	
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}
	
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (!util.isNullOrUndefined(data))
	    stream.push(data);
	
	  if (cb)
	    cb(er);
	
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	
	
	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);
	
	  Duplex.call(this, options);
	
	  this._transformState = new TransformState(options, this);
	
	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}
	
	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};
	
	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;
	
	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	
	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;
	
	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');
	
	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');
	
	  return stream.push(null);
	}


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.
	
	module.exports = PassThrough;
	
	var Transform = __webpack_require__(75);
	
	/*<replacement>*/
	var util = __webpack_require__(70);
	util.inherits = __webpack_require__(71);
	/*</replacement>*/
	
	util.inherits(PassThrough, Transform);
	
	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);
	
	  Transform.call(this, options);
	}
	
	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var Sequence = __webpack_require__(32);
	var Util     = __webpack_require__(33);
	var Packets  = __webpack_require__(35);
	
	module.exports = Quit;
	Util.inherits(Quit, Sequence);
	function Quit(options, callback) {
	  if (!callback && typeof options === 'function') {
	    callback = options;
	    options = {};
	  }
	
	  Sequence.call(this, options, callback);
	}
	
	Quit.prototype.start = function() {
	  this.emit('packet', new Packets.ComQuitPacket);
	};


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var Sequence = __webpack_require__(32);
	var Util     = __webpack_require__(33);
	var Packets  = __webpack_require__(35);
	
	module.exports = Statistics;
	Util.inherits(Statistics, Sequence);
	function Statistics(options, callback) {
	  if (!callback && typeof options === 'function') {
	    callback = options;
	    options = {};
	  }
	
	  Sequence.call(this, options, callback);
	}
	
	Statistics.prototype.start = function() {
	  this.emit('packet', new Packets.ComStatisticsPacket);
	};
	
	Statistics.prototype['StatisticsPacket'] = function (packet) {
	  this.end(null, packet);
	};
	
	Statistics.prototype.determinePacket = function(firstByte, parser) {
	  if (firstByte === 0x55) {
	    return Packets.StatisticsPacket;
	  }
	};


/***/ },
/* 79 */
/***/ function(module, exports) {

	module.exports = require("timers");

/***/ },
/* 80 */
/***/ function(module, exports) {

	var BIT_16 = Math.pow(2, 16);
	var BIT_24 = Math.pow(2, 24);
	// The maximum precision JS Numbers can hold precisely
	// Don't panic: Good enough to represent byte values up to 8192 TB
	var IEEE_754_BINARY_64_PRECISION = Math.pow(2, 53);
	var MAX_PACKET_LENGTH            = Math.pow(2, 24) - 1;
	
	module.exports = PacketWriter;
	function PacketWriter() {
	  this._buffer = new Buffer(0);
	  this._offset = 0;
	}
	
	PacketWriter.prototype.toBuffer = function(parser) {
	  var packets  = Math.floor(this._buffer.length / MAX_PACKET_LENGTH) + 1;
	  var buffer   = this._buffer;
	  this._buffer = new Buffer(this._buffer.length + packets * 4);
	
	  for (var packet = 0; packet < packets; packet++) {
	    this._offset = packet * (MAX_PACKET_LENGTH + 4);
	
	    var isLast = (packet + 1 === packets);
	    var packetLength = (isLast)
	      ? buffer.length % MAX_PACKET_LENGTH
	      : MAX_PACKET_LENGTH;
	
	    var packetNumber = parser.incrementPacketNumber();
	
	    this.writeUnsignedNumber(3, packetLength);
	    this.writeUnsignedNumber(1, packetNumber);
	
	    var start = packet * MAX_PACKET_LENGTH;
	    var end   = start + packetLength;
	
	    this.writeBuffer(buffer.slice(start, end));
	  }
	
	  return this._buffer;
	};
	
	PacketWriter.prototype.writeUnsignedNumber = function(bytes, value) {
	  this._allocate(bytes);
	
	  for (var i = 0; i < bytes; i++) {
	    this._buffer[this._offset++] = (value >> (i * 8)) & 0xff;
	  }
	};
	
	PacketWriter.prototype.writeFiller = function(bytes) {
	  this._allocate(bytes);
	
	  for (var i = 0; i < bytes; i++) {
	    this._buffer[this._offset++] = 0x00;
	  }
	};
	
	PacketWriter.prototype.writeNullTerminatedString = function(value, encoding) {
	  // Typecast undefined into '' and numbers into strings
	  value = value || '';
	  value = value + '';
	
	  var bytes = Buffer.byteLength(value, encoding || 'utf-8') + 1;
	  this._allocate(bytes);
	
	  this._buffer.write(value, this._offset, encoding);
	  this._buffer[this._offset + bytes - 1] = 0x00;
	
	  this._offset += bytes;
	};
	
	PacketWriter.prototype.writeString = function(value) {
	  // Typecast undefined into '' and numbers into strings
	  value = value || '';
	  value = value + '';
	
	  var bytes = Buffer.byteLength(value, 'utf-8');
	  this._allocate(bytes);
	
	  this._buffer.write(value, this._offset, 'utf-8');
	
	  this._offset += bytes;
	};
	
	PacketWriter.prototype.writeBuffer = function(value) {
	  var bytes = value.length;
	
	  this._allocate(bytes);
	  value.copy(this._buffer, this._offset);
	  this._offset += bytes;
	};
	
	PacketWriter.prototype.writeLengthCodedNumber = function(value) {
	  if (value === null) {
	    this._allocate(1);
	    this._buffer[this._offset++] = 251;
	    return;
	  }
	
	  if (value <= 250) {
	    this._allocate(1);
	    this._buffer[this._offset++] = value;
	    return;
	  }
	
	  if (value > IEEE_754_BINARY_64_PRECISION) {
	    throw new Error(
	      'writeLengthCodedNumber: JS precision range exceeded, your ' +
	      'number is > 53 bit: "' + value + '"'
	    );
	  }
	
	  if (value <= BIT_16) {
	    this._allocate(3)
	    this._buffer[this._offset++] = 252;
	  } else if (value <= BIT_24) {
	    this._allocate(4)
	    this._buffer[this._offset++] = 253;
	  } else {
	    this._allocate(9);
	    this._buffer[this._offset++] = 254;
	  }
	
	  // 16 Bit
	  this._buffer[this._offset++] = value & 0xff;
	  this._buffer[this._offset++] = (value >> 8) & 0xff;
	
	  if (value <= BIT_16) return;
	
	  // 24 Bit
	  this._buffer[this._offset++] = (value >> 16) & 0xff;
	
	  if (value <= BIT_24) return;
	
	  this._buffer[this._offset++] = (value >> 24) & 0xff;
	
	  // Hack: Get the most significant 32 bit (JS bitwise operators are 32 bit)
	  value = value.toString(2);
	  value = value.substr(0, value.length - 32);
	  value = parseInt(value, 2);
	
	  this._buffer[this._offset++] = value & 0xff;
	  this._buffer[this._offset++] = (value >> 8) & 0xff;
	  this._buffer[this._offset++] = (value >> 16) & 0xff;
	
	  // Set last byte to 0, as we can only support 53 bits in JS (see above)
	  this._buffer[this._offset++] = 0;
	};
	
	PacketWriter.prototype.writeLengthCodedBuffer = function(value) {
	  var bytes = value.length;
	  this.writeLengthCodedNumber(bytes);
	  this.writeBuffer(value);
	};
	
	PacketWriter.prototype.writeNullTerminatedBuffer = function(value) {
	  this.writeBuffer(value);
	  this.writeFiller(1); // 0x00 terminator
	};
	
	PacketWriter.prototype.writeLengthCodedString = function(value) {
	  if (value === null) {
	    this.writeLengthCodedNumber(null);
	    return;
	  }
	
	  value = (value === undefined)
	    ? ''
	    : String(value);
	
	  var bytes = Buffer.byteLength(value, 'utf-8');
	  this.writeLengthCodedNumber(bytes);
	
	  if (!bytes) {
	    return;
	  }
	
	  this._allocate(bytes);
	  this._buffer.write(value, this._offset, 'utf-8');
	  this._offset += bytes;
	};
	
	PacketWriter.prototype._allocate = function(bytes) {
	  if (!this._buffer) {
	    this._buffer = new Buffer(bytes);
	    return;
	  }
	
	  var bytesRemaining = this._buffer.length - this._offset;
	  if (bytesRemaining >= bytes) {
	    return;
	  }
	
	  var oldBuffer = this._buffer;
	
	  this._buffer = new Buffer(oldBuffer.length + bytes);
	  oldBuffer.copy(this._buffer);
	};


/***/ },
/* 81 */
/***/ function(module, exports) {

	var SqlString = exports;
	
	SqlString.escapeId = function (val, forbidQualified) {
	  if (Array.isArray(val)) {
	    return val.map(function(v) {
	      return SqlString.escapeId(v, forbidQualified);
	    }).join(', ');
	  }
	
	  if (forbidQualified) {
	    return '`' + val.replace(/`/g, '``') + '`';
	  }
	  return '`' + val.replace(/`/g, '``').replace(/\./g, '`.`') + '`';
	};
	
	SqlString.escape = function(val, stringifyObjects, timeZone) {
	  if (val === undefined || val === null) {
	    return 'NULL';
	  }
	
	  switch (typeof val) {
	    case 'boolean': return (val) ? 'true' : 'false';
	    case 'number': return val+'';
	  }
	
	  if (val instanceof Date) {
	    val = SqlString.dateToString(val, timeZone || 'local');
	  }
	
	  if (Buffer.isBuffer(val)) {
	    return SqlString.bufferToString(val);
	  }
	
	  if (Array.isArray(val)) {
	    return SqlString.arrayToList(val, timeZone);
	  }
	
	  if (typeof val === 'object') {
	    if (stringifyObjects) {
	      val = val.toString();
	    } else {
	      return SqlString.objectToValues(val, timeZone);
	    }
	  }
	
	  val = val.replace(/[\0\n\r\b\t\\\'\"\x1a]/g, function(s) {
	    switch(s) {
	      case "\0": return "\\0";
	      case "\n": return "\\n";
	      case "\r": return "\\r";
	      case "\b": return "\\b";
	      case "\t": return "\\t";
	      case "\x1a": return "\\Z";
	      default: return "\\"+s;
	    }
	  });
	  return "'"+val+"'";
	};
	
	SqlString.arrayToList = function(array, timeZone) {
	  return array.map(function(v) {
	    if (Array.isArray(v)) return '(' + SqlString.arrayToList(v, timeZone) + ')';
	    return SqlString.escape(v, true, timeZone);
	  }).join(', ');
	};
	
	SqlString.format = function(sql, values, stringifyObjects, timeZone) {
	  values = values == null ? [] : [].concat(values);
	
	  var index = 0;
	  return sql.replace(/\?\??/g, function(match) {
	    if (index === values.length) {
	      return match;
	    }
	
	    var value = values[index++];
	
	    return match === '??'
	      ? SqlString.escapeId(value)
	      : SqlString.escape(value, stringifyObjects, timeZone);
	  });
	};
	
	SqlString.dateToString = function dateToString(date, timeZone) {
	  var dt = new Date(date);
	
	  var year;
	  var month;
	  var day;
	  var hour;
	  var minute;
	  var second;
	  var millisecond;
	
	  if (timeZone === 'local') {
	    year        = dt.getFullYear();
	    month       = dt.getMonth() + 1;
	    day         = dt.getDate();
	    hour        = dt.getHours();
	    minute      = dt.getMinutes();
	    second      = dt.getSeconds();
	    millisecond = dt.getMilliseconds();
	  } else {
	    var tz = convertTimezone(timeZone);
	    if (tz !== false) {
	      dt.setTime(dt.getTime() + (tz * 60000));
	    }
	
	    year       = dt.getUTCFullYear();
	    month       = dt.getUTCMonth() + 1;
	    day         = dt.getUTCDate();
	    hour        = dt.getUTCHours();
	    minute      = dt.getUTCMinutes();
	    second      = dt.getUTCSeconds();
	    millisecond = dt.getUTCMilliseconds();
	  }
	
	  // YYYY-MM-DD HH:mm:ss.mmm
	  return zeroPad(year, 4) + '-' + zeroPad(month, 2) + '-' + zeroPad(day, 2) + ' ' +
	    zeroPad(hour, 2) + ':' + zeroPad(minute, 2) + ':' + zeroPad(second, 2) + '.' +
	    zeroPad(millisecond, 3);
	};
	
	SqlString.bufferToString = function bufferToString(buffer) {
	  return "X'" + buffer.toString('hex') + "'";
	};
	
	SqlString.objectToValues = function(object, timeZone) {
	  var values = [];
	  for (var key in object) {
	    var value = object[key];
	    if(typeof value === 'function') {
	      continue;
	    }
	
	    values.push(this.escapeId(key) + ' = ' + SqlString.escape(value, true, timeZone));
	  }
	
	  return values.join(', ');
	};
	
	function zeroPad(number, length) {
	  number = number.toString();
	  while (number.length < length) {
	    number = '0' + number;
	  }
	
	  return number;
	}
	
	function convertTimezone(tz) {
	  if (tz == "Z") return 0;
	
	  var m = tz.match(/([\+\-\s])(\d\d):?(\d\d)?/);
	  if (m) {
	    return (m[1] == '-' ? -1 : 1) * (parseInt(m[2], 10) + ((m[3] ? parseInt(m[3], 10) : 0) / 60)) * 60;
	  }
	  return false;
	}


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var mysql          = __webpack_require__(16);
	var Connection     = __webpack_require__(17);
	var EventEmitter   = __webpack_require__(34).EventEmitter;
	var Util           = __webpack_require__(33);
	var PoolConnection = __webpack_require__(83);
	
	module.exports = Pool;
	
	Util.inherits(Pool, EventEmitter);
	function Pool(options) {
	  EventEmitter.call(this);
	  this.config = options.config;
	  this.config.connectionConfig.pool = this;
	
	  this._acquiringConnections = [];
	  this._allConnections       = [];
	  this._freeConnections      = [];
	  this._connectionQueue      = [];
	  this._closed               = false;
	}
	
	Pool.prototype.getConnection = function (cb) {
	
	  if (this._closed) {
	    return process.nextTick(function(){
	      return cb(new Error('Pool is closed.'));
	    });
	  }
	
	  var connection;
	  var pool = this;
	
	  if (this._freeConnections.length > 0) {
	    connection = this._freeConnections.shift();
	
	    return this.acquireConnection(connection, cb);
	  }
	
	  if (this.config.connectionLimit === 0 || this._allConnections.length < this.config.connectionLimit) {
	    connection = new PoolConnection(this, { config: this.config.newConnectionConfig() });
	
	    this._acquiringConnections.push(connection);
	    this._allConnections.push(connection);
	
	    return connection.connect({timeout: this.config.acquireTimeout}, function onConnect(err) {
	      spliceConnection(pool._acquiringConnections, connection);
	
	      if (pool._closed) {
	        err = new Error('Pool is closed.');
	      }
	
	      if (err) {
	        pool._purgeConnection(connection);
	        cb(err);
	        return;
	      }
	
	      pool.emit('connection', connection);
	      cb(null, connection);
	    });
	  }
	
	  if (!this.config.waitForConnections) {
	    return process.nextTick(function(){
	      return cb(new Error('No connections available.'));
	    });
	  }
	
	  this._enqueueCallback(cb);
	};
	
	Pool.prototype.acquireConnection = function acquireConnection(connection, cb) {
	  if (connection._pool !== this) {
	    throw new Error('Connection acquired from wrong pool.');
	  }
	
	  var changeUser = this._needsChangeUser(connection);
	  var pool       = this;
	
	  this._acquiringConnections.push(connection);
	
	  function onOperationComplete(err) {
	    spliceConnection(pool._acquiringConnections, connection);
	
	    if (pool._closed) {
	      err = new Error('Pool is closed.');
	    }
	
	    if (err) {
	      pool._connectionQueue.unshift(cb);
	      pool._purgeConnection(connection);
	      return;
	    }
	
	    if (changeUser) {
	      pool.emit('connection', connection);
	    }
	
	    cb(null, connection);
	  }
	
	  if (changeUser) {
	    // restore user back to pool configuration
	    connection.config = this.config.newConnectionConfig();
	    connection.changeUser({timeout: this.config.acquireTimeout}, onOperationComplete);
	  } else {
	    // ping connection
	    connection.ping({timeout: this.config.acquireTimeout}, onOperationComplete);
	  }
	};
	
	Pool.prototype.releaseConnection = function releaseConnection(connection) {
	  var cb;
	  var pool = this;
	
	  if (this._acquiringConnections.indexOf(connection) !== -1) {
	    // connection is being acquired
	    return;
	  }
	
	  if (connection._pool) {
	    if (connection._pool !== this) {
	      throw new Error('Connection released to wrong pool');
	    }
	
	    if (this._freeConnections.indexOf(connection) !== -1) {
	      // connection already in free connection pool
	      // this won't catch all double-release cases
	      throw new Error('Connection already released');
	    } else {
	      // add connection to end of free queue
	      this._freeConnections.push(connection);
	    }
	  }
	
	  while (this._closed && this._connectionQueue.length) {
	    // empty the connection queue
	    cb = this._connectionQueue.shift();
	
	    process.nextTick(cb.bind(null, new Error('Pool is closed.')));
	  }
	
	  if (this._connectionQueue.length) {
	    cb = this._connectionQueue.shift();
	
	    this.getConnection(cb);
	  }
	};
	
	Pool.prototype.end = function (cb) {
	  this._closed = true;
	
	  if (typeof cb != "function") {
	    cb = function (err) {
	      if (err) throw err;
	    };
	  }
	
	  var calledBack   = false;
	  var waitingClose = this._allConnections.length;
	
	  function onEnd(err) {
	    if (calledBack) {
	      return;
	    }
	
	    if (err || --waitingClose === 0) {
	      calledBack = true;
	      return cb(err);
	    }
	  }
	
	  if (waitingClose === 0) {
	    return process.nextTick(cb);
	  }
	
	  while (this._allConnections.length !== 0) {
	    this._purgeConnection(this._allConnections[0], onEnd);
	  }
	};
	
	Pool.prototype.query = function (sql, values, cb) {
	  var query = Connection.createQuery(sql, values, cb);
	
	  if (!(typeof sql === 'object' && 'typeCast' in sql)) {
	    query.typeCast = this.config.connectionConfig.typeCast;
	  }
	
	  if (this.config.connectionConfig.trace) {
	    // Long stack trace support
	    query._callSite = new Error;
	  }
	
	  this.getConnection(function (err, conn) {
	    if (err) {
	      query.on('error', function () {});
	      query.end(err);
	      return;
	    }
	
	    // Release connection based off event
	    query.once('end', function() {
	      conn.release();
	    });
	
	    conn.query(query);
	  });
	
	  return query;
	};
	
	Pool.prototype._enqueueCallback = function _enqueueCallback(callback) {
	
	  if (this.config.queueLimit && this._connectionQueue.length >= this.config.queueLimit) {
	    process.nextTick(function () {
	      var err = new Error('Queue limit reached.');
	      err.code = 'POOL_ENQUEUELIMIT';
	      callback(err);
	    });
	    return;
	  }
	
	  // Bind to domain, as dequeue will likely occur in a different domain
	  var cb = process.domain
	    ? process.domain.bind(callback)
	    : callback;
	
	  this._connectionQueue.push(cb);
	  this.emit('enqueue');
	};
	
	Pool.prototype._needsChangeUser = function _needsChangeUser(connection) {
	  var connConfig = connection.config;
	  var poolConfig = this.config.connectionConfig;
	
	  // check if changeUser values are different
	  return connConfig.user !== poolConfig.user
	    || connConfig.database !== poolConfig.database
	    || connConfig.password !== poolConfig.password
	    || connConfig.charsetNumber !== poolConfig.charsetNumber;
	}
	
	Pool.prototype._purgeConnection = function _purgeConnection(connection, callback) {
	  var cb = callback || function () {};
	
	  if (connection.state === 'disconnected') {
	    connection.destroy();
	  }
	
	  this._removeConnection(connection);
	
	  if (connection.state !== 'disconnected' && !connection._protocol._quitSequence) {
	    connection._realEnd(cb);
	    return;
	  }
	
	  process.nextTick(cb);
	};
	
	Pool.prototype._removeConnection = function(connection) {
	  connection._pool = null;
	
	  // Remove connection from all connections
	  spliceConnection(this._allConnections, connection);
	
	  // Remove connection from free connections
	  spliceConnection(this._freeConnections, connection);
	
	  this.releaseConnection(connection);
	};
	
	Pool.prototype.escape = function(value) {
	  return mysql.escape(value, this.config.connectionConfig.stringifyObjects, this.config.connectionConfig.timezone);
	};
	
	Pool.prototype.escapeId = function escapeId(value) {
	  return mysql.escapeId(value, false);
	};
	
	function spliceConnection(array, connection) {
	  var index;
	  if ((index = array.indexOf(connection)) !== -1) {
	    // Remove connection from all connections
	    array.splice(index, 1);
	  }
	}


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(33).inherits;
	var Connection = __webpack_require__(17)
	
	module.exports = PoolConnection;
	inherits(PoolConnection, Connection);
	
	function PoolConnection(pool, options) {
	  Connection.call(this, options);
	  this._pool  = pool;
	
	  // When a fatal error occurs the connection's protocol ends, which will cause
	  // the connection to end as well, thus we only need to watch for the end event
	  // and we will be notified of disconnects.
	  this.on('end', this._removeFromPool);
	  this.on('error', function (err) {
	    if (err.fatal) {
	      this._removeFromPool();
	    }
	  });
	}
	
	PoolConnection.prototype.release = function release() {
	  var pool = this._pool;
	  var connection = this;
	
	  if (!pool || pool._closed) {
	    return;
	  }
	
	  return pool.releaseConnection(this);
	};
	
	// TODO: Remove this when we are removing PoolConnection#end
	PoolConnection.prototype._realEnd = Connection.prototype.end;
	
	PoolConnection.prototype.end = function () {
	  console.warn( 'Calling conn.end() to release a pooled connection is '
	              + 'deprecated. In next version calling conn.end() will be '
	              + 'restored to default conn.end() behavior. Use '
	              + 'conn.release() instead.'
	              );
	  this.release();
	};
	
	PoolConnection.prototype.destroy = function () {
	  this._removeFromPool(this);
	  return Connection.prototype.destroy.apply(this, arguments);
	};
	
	PoolConnection.prototype._removeFromPool = function _removeFromPool() {
	  if (!this._pool || this._pool._closed) {
	    return;
	  }
	
	  var pool = this._pool;
	  this._pool = null;
	
	  pool._purgeConnection(this);
	};


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var Pool          = __webpack_require__(82);
	var PoolConfig    = __webpack_require__(85);
	var PoolNamespace = __webpack_require__(86);
	var PoolSelector  = __webpack_require__(87);
	var Util          = __webpack_require__(33);
	var EventEmitter  = __webpack_require__(34).EventEmitter;
	
	module.exports = PoolCluster;
	
	/**
	 * PoolCluster
	 */
	function PoolCluster(config) {
	  EventEmitter.call(this);
	
	  config = config || {};
	  this._canRetry = typeof config.canRetry === 'undefined' ? true : config.canRetry;
	  this._defaultSelector = config.defaultSelector || 'RR';
	  this._removeNodeErrorCount = config.removeNodeErrorCount || 5;
	  this._restoreNodeTimeout = config.restoreNodeTimeout || 0;
	
	  this._closed = false;
	  this._findCaches = Object.create(null);
	  this._lastId = 0;
	  this._namespaces = Object.create(null);
	  this._nodes = Object.create(null);
	}
	
	Util.inherits(PoolCluster, EventEmitter);
	
	PoolCluster.prototype.add = function add(id, config) {
	  if (this._closed) {
	    throw new Error('PoolCluster is closed.');
	  }
	
	  var nodeId = typeof id === 'object'
	    ? 'CLUSTER::' + (++this._lastId)
	    : String(id);
	
	  if (this._nodes[nodeId] !== undefined) {
	    throw new Error('Node ID "' + nodeId + '" is already defined in PoolCluster.');
	  }
	
	  var poolConfig = typeof id !== 'object'
	    ? new PoolConfig(config)
	    : new PoolConfig(id);
	
	  this._nodes[nodeId] = {
	    id            : nodeId,
	    errorCount    : 0,
	    pool          : new Pool({config: poolConfig}),
	    _offlineUntil : 0
	  };
	
	  this._clearFindCaches();
	};
	
	PoolCluster.prototype.end = function end(callback) {
	  var cb = callback !== undefined
	    ? callback
	    : _cb;
	
	  if (typeof cb !== 'function') {
	    throw TypeError('callback argument must be a function')
	  }
	
	  if (this._closed) {
	    return process.nextTick(cb);
	  }
	
	  this._closed = true;
	
	  var calledBack   = false;
	  var nodeIds      = Object.keys(this._nodes);
	  var waitingClose = nodeIds.length;
	
	  function onEnd(err) {
	    if (calledBack) {
	      return;
	    }
	
	    if (err || --waitingClose === 0) {
	      calledBack = true;
	      return cb(err);
	    }
	  }
	
	  if (waitingClose === 0) {
	    return process.nextTick(cb);
	  }
	
	  for (var i = 0; i < nodeIds.length; i++) {
	    var nodeId = nodeIds[i];
	    var node = this._nodes[nodeId];
	
	    node.pool.end(onEnd);
	  }
	};
	
	PoolCluster.prototype.of = function(pattern, selector) {
	  pattern = pattern || '*';
	
	  selector = selector || this._defaultSelector;
	  selector = selector.toUpperCase();
	  if (typeof PoolSelector[selector] === 'undefined') {
	    selector = this._defaultSelector;
	  }
	
	  var key = pattern + selector;
	
	  if (typeof this._namespaces[key] === 'undefined') {
	    this._namespaces[key] = new PoolNamespace(this, pattern, selector);
	  }
	
	  return this._namespaces[key];
	};
	
	PoolCluster.prototype.remove = function remove(pattern) {
	  var foundNodeIds = this._findNodeIds(pattern, true);
	
	  for (var i = 0; i < foundNodeIds.length; i++) {
	    var node = this._getNode(foundNodeIds[i]);
	
	    if (node) {
	      this._removeNode(node);
	    }
	  }
	};
	
	PoolCluster.prototype.getConnection = function(pattern, selector, cb) {
	  var namespace;
	  if (typeof pattern === 'function') {
	    cb = pattern;
	    namespace = this.of();
	  } else {
	    if (typeof selector === 'function') {
	      cb = selector;
	      selector = this._defaultSelector;
	    }
	
	    namespace = this.of(pattern, selector);
	  }
	
	  namespace.getConnection(cb);
	};
	
	PoolCluster.prototype._clearFindCaches = function _clearFindCaches() {
	  this._findCaches = Object.create(null);
	};
	
	PoolCluster.prototype._decreaseErrorCount = function _decreaseErrorCount(node) {
	  var errorCount = node.errorCount;
	
	  if (errorCount > this._removeNodeErrorCount) {
	    errorCount = this._removeNodeErrorCount;
	  }
	
	  if (errorCount < 1) {
	    errorCount = 1;
	  }
	
	  node.errorCount = errorCount - 1;
	
	  if (node._offlineUntil) {
	    node._offlineUntil = 0;
	    this.emit('online', node.id);
	  }
	};
	
	PoolCluster.prototype._findNodeIds = function _findNodeIds(pattern, includeOffline) {
	  var currentTime  = 0;
	  var foundNodeIds = this._findCaches[pattern];
	
	  if (foundNodeIds === undefined) {
	    var nodeIds  = Object.keys(this._nodes);
	    var wildcard = pattern.substr(-1) === '*';
	    var keyword  = wildcard
	      ? pattern.substr(0, pattern.length - 1)
	      : pattern;
	
	    if (wildcard) {
	      foundNodeIds = keyword.length !== 0
	        ? nodeIds.filter(function (id) { return id.substr(0, keyword.length) === keyword; })
	        : nodeIds;
	    } else {
	      var index = nodeIds.indexOf(keyword);
	      foundNodeIds = nodeIds.slice(index, index + 1);
	    }
	
	    this._findCaches[pattern] = foundNodeIds;
	  }
	
	  if (includeOffline) {
	    return foundNodeIds;
	  }
	
	  return foundNodeIds.filter(function (nodeId) {
	    var node = this._getNode(nodeId);
	
	    if (!node._offlineUntil) {
	      return true;
	    }
	
	    if (!currentTime) {
	      currentTime = getMonotonicMilliseconds();
	    }
	
	    return node._offlineUntil <= currentTime;
	  }, this);
	};
	
	PoolCluster.prototype._getNode = function _getNode(id) {
	  return this._nodes[id] || null;
	};
	
	PoolCluster.prototype._increaseErrorCount = function _increaseErrorCount(node) {
	  var errorCount = ++node.errorCount;
	
	  if (this._removeNodeErrorCount > errorCount) {
	    return;
	  }
	
	  if (this._restoreNodeTimeout > 0) {
	    node._offlineUntil = getMonotonicMilliseconds() + this._restoreNodeTimeout;
	    this.emit('offline', node.id);
	    return;
	  }
	
	  this._removeNode(node);
	  this.emit('remove', node.id);
	};
	
	PoolCluster.prototype._getConnection = function(node, cb) {
	  var self = this;
	
	  node.pool.getConnection(function (err, connection) {
	    if (err) {
	      self._increaseErrorCount(node);
	      cb(err);
	      return;
	    } else {
	      self._decreaseErrorCount(node);
	    }
	
	    connection._clusterId = node.id;
	
	    cb(null, connection);
	  });
	};
	
	PoolCluster.prototype._removeNode = function _removeNode(node) {
	  delete this._nodes[node.id];
	
	  this._clearFindCaches();
	
	  node.pool.end(_noop);
	};
	
	function getMonotonicMilliseconds() {
	  var ms;
	
	  if (typeof process.hrtime === 'function') {
	    ms = process.hrtime();
	    ms = ms[0] * 1e3 + ms[1] * 1e-6;
	  } else {
	    ms = process.uptime() * 1000;
	  }
	
	  return Math.floor(ms);
	}
	
	function _cb(err) {
	  if (err) {
	    throw err;
	  }
	}
	
	function _noop() {}


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	
	var ConnectionConfig = __webpack_require__(21);
	
	module.exports = PoolConfig;
	function PoolConfig(options) {
	  if (typeof options === 'string') {
	    options = ConnectionConfig.parseUrl(options);
	  }
	
	  this.acquireTimeout     = (options.acquireTimeout === undefined)
	    ? 10 * 1000
	    : Number(options.acquireTimeout);
	  this.connectionConfig   = new ConnectionConfig(options);
	  this.waitForConnections = (options.waitForConnections === undefined)
	    ? true
	    : Boolean(options.waitForConnections);
	  this.connectionLimit    = (options.connectionLimit === undefined)
	    ? 10
	    : Number(options.connectionLimit);
	  this.queueLimit         = (options.queueLimit === undefined)
	    ? 0
	    : Number(options.queueLimit);
	}
	
	PoolConfig.prototype.newConnectionConfig = function newConnectionConfig() {
	  var connectionConfig = new ConnectionConfig(this.connectionConfig);
	
	  connectionConfig.clientFlags   = this.connectionConfig.clientFlags;
	  connectionConfig.maxPacketSize = this.connectionConfig.maxPacketSize;
	
	  return connectionConfig;
	};


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	var PoolSelector = __webpack_require__(87);
	
	module.exports = PoolNamespace;
	
	/**
	 * PoolNamespace
	 */
	function PoolNamespace(cluster, pattern, selector) {
	  this._cluster = cluster;
	  this._pattern = pattern;
	  this._selector = new PoolSelector[selector]();
	}
	
	PoolNamespace.prototype.getConnection = function(cb) {
	  var clusterNode = this._getClusterNode();
	  var cluster     = this._cluster;
	  var namespace   = this;
	
	  if (clusterNode === null) {
	    var err = null;
	
	    if (this._cluster._findNodeIds(this._pattern, true).length !== 0) {
	      err = new Error('Pool does not have online node.');
	      err.code = 'POOL_NONEONLINE';
	    } else {
	      err = new Error('Pool does not exist.');
	      err.code = 'POOL_NOEXIST';
	    }
	
	    return cb(err);
	  }
	
	  cluster._getConnection(clusterNode, function(err, connection) {
	    var retry = err && cluster._canRetry
	      && cluster._findNodeIds(namespace._pattern).length !== 0;
	
	    if (retry) {
	      return namespace.getConnection(cb);
	    }
	
	    if (err) {
	      return cb(err);
	    }
	
	    cb(null, connection);
	  });
	};
	
	PoolNamespace.prototype._getClusterNode = function _getClusterNode() {
	  var foundNodeIds = this._cluster._findNodeIds(this._pattern);
	  var nodeId;
	
	  switch (foundNodeIds.length) {
	    case 0:
	      nodeId = null;
	      break;
	    case 1:
	      nodeId = foundNodeIds[0];
	      break;
	    default:
	      nodeId = this._selector(foundNodeIds);
	      break;
	  }
	
	  return nodeId !== null
	    ? this._cluster._getNode(nodeId)
	    : null;
	};


/***/ },
/* 87 */
/***/ function(module, exports) {

	
	/**
	 * PoolSelector
	 */
	var PoolSelector = module.exports = {};
	
	PoolSelector.RR = function PoolSelectorRoundRobin() {
	  var index = 0;
	
	  return function(clusterIds) {
	    if (index >= clusterIds.length) {
	      index = 0;
	    }
	
	    var clusterId = clusterIds[index++];
	
	    return clusterId;
	  };
	};
	
	PoolSelector.RANDOM = function PoolSelectorRandom() {
	  return function(clusterIds) {
	    return clusterIds[Math.floor(Math.random() * clusterIds.length)];
	  };
	};
	
	PoolSelector.ORDER = function PoolSelectorOrder() {
	  return function(clusterIds) {
	    return clusterIds[0];
	  };
	};


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMGE2OTI0MDNjOGNkNzFhOWQ0ZmUiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NlcnZlci9hcHAuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiYmFiZWwtcG9seWZpbGxcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJleHByZXNzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwicGF0aFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInNlcnZlLWZhdmljb25cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJtb3JnYW5cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjb29raWUtcGFyc2VyXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiYm9keS1wYXJzZXJcIiIsIndlYnBhY2s6Ly8vLi9zcmMvc2VydmVyL3JvdXRlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2VydmVyL3JvdXRlcy91c2Vycy5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJkZWJ1Z1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcImh0dHBcIiIsIndlYnBhY2s6Ly8vLi9+L2NvL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vdGh1bmtpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiYXNzZXJ0XCIiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NlcnZlci9saWJzL215c3FsLmpzIiwid2VicGFjazovLy8uL34vbXlzcWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9teXNxbC9saWIvQ29ubmVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjcnlwdG9cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJuZXRcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ0bHNcIiIsIndlYnBhY2s6Ly8vLi9+L215c3FsL2xpYi9Db25uZWN0aW9uQ29uZmlnLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcInVybFwiIiwid2VicGFjazovLy8uL34vbXlzcWwvbGliL3Byb3RvY29sL2NvbnN0YW50cy9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9teXNxbC9saWIvcHJvdG9jb2wvY29uc3RhbnRzL2NoYXJzZXRzLmpzIiwid2VicGFjazovLy8uL34vbXlzcWwvbGliL3Byb3RvY29sL2NvbnN0YW50cy9zc2xfcHJvZmlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9teXNxbC9saWIvcHJvdG9jb2wvUHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9teXNxbC9saWIvcHJvdG9jb2wvUGFyc2VyLmpzIiwid2VicGFjazovLy8uL34vbXlzcWwvbGliL3Byb3RvY29sL1BhY2tldEhlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L215c3FsL34vYmlnbnVtYmVyLmpzL2JpZ251bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9+L215c3FsL2xpYi9wcm90b2NvbC9zZXF1ZW5jZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9teXNxbC9saWIvcHJvdG9jb2wvc2VxdWVuY2VzL0NoYW5nZVVzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9teXNxbC9saWIvcHJvdG9jb2wvc2VxdWVuY2VzL1NlcXVlbmNlLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcInV0aWxcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJldmVudHNcIiIsIndlYnBhY2s6Ly8vLi9+L215c3FsL2xpYi9wcm90b2NvbC9wYWNrZXRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbXlzcWwvbGliL3Byb3RvY29sL3BhY2tldHMvQ2xpZW50QXV0aGVudGljYXRpb25QYWNrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9teXNxbC9saWIvcHJvdG9jb2wvcGFja2V0cy9Db21DaGFuZ2VVc2VyUGFja2V0LmpzIiwid2VicGFjazovLy8uL34vbXlzcWwvbGliL3Byb3RvY29sL3BhY2tldHMvQ29tUGluZ1BhY2tldC5qcyIsIndlYnBhY2s6Ly8vLi9+L215c3FsL2xpYi9wcm90b2NvbC9wYWNrZXRzL0NvbVF1ZXJ5UGFja2V0LmpzIiwid2VicGFjazovLy8uL34vbXlzcWwvbGliL3Byb3RvY29sL3BhY2tldHMvQ29tUXVpdFBhY2tldC5qcyIsIndlYnBhY2s6Ly8vLi9+L215c3FsL2xpYi9wcm90b2NvbC9wYWNrZXRzL0NvbVN0YXRpc3RpY3NQYWNrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9teXNxbC9saWIvcHJvdG9jb2wvcGFja2V0cy9FbXB0eVBhY2tldC5qcyIsIndlYnBhY2s6Ly8vLi9+L215c3FsL2xpYi9wcm90b2NvbC9wYWNrZXRzL0VvZlBhY2tldC5qcyIsIndlYnBhY2s6Ly8vLi9+L215c3FsL2xpYi9wcm90b2NvbC9wYWNrZXRzL0Vycm9yUGFja2V0LmpzIiwid2VicGFjazovLy8uL34vbXlzcWwvbGliL3Byb3RvY29sL3BhY2tldHMvRmllbGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9teXNxbC9saWIvcHJvdG9jb2wvY29uc3RhbnRzL3R5cGVzLmpzIiwid2VicGFjazovLy8uL34vbXlzcWwvbGliL3Byb3RvY29sL3BhY2tldHMvRmllbGRQYWNrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9teXNxbC9saWIvcHJvdG9jb2wvcGFja2V0cy9IYW5kc2hha2VJbml0aWFsaXphdGlvblBhY2tldC5qcyIsIndlYnBhY2s6Ly8vLi9+L215c3FsL2xpYi9wcm90b2NvbC9wYWNrZXRzL0xvY2FsRGF0YUZpbGVQYWNrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9teXNxbC9saWIvcHJvdG9jb2wvcGFja2V0cy9Pa1BhY2tldC5qcyIsIndlYnBhY2s6Ly8vLi9+L215c3FsL2xpYi9wcm90b2NvbC9wYWNrZXRzL09sZFBhc3N3b3JkUGFja2V0LmpzIiwid2VicGFjazovLy8uL34vbXlzcWwvbGliL3Byb3RvY29sL3BhY2tldHMvUmVzdWx0U2V0SGVhZGVyUGFja2V0LmpzIiwid2VicGFjazovLy8uL34vbXlzcWwvbGliL3Byb3RvY29sL3BhY2tldHMvUm93RGF0YVBhY2tldC5qcyIsIndlYnBhY2s6Ly8vLi9+L215c3FsL2xpYi9wcm90b2NvbC9wYWNrZXRzL1NTTFJlcXVlc3RQYWNrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9teXNxbC9saWIvcHJvdG9jb2wvcGFja2V0cy9TdGF0aXN0aWNzUGFja2V0LmpzIiwid2VicGFjazovLy8uL34vbXlzcWwvbGliL3Byb3RvY29sL3BhY2tldHMvVXNlT2xkUGFzc3dvcmRQYWNrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9teXNxbC9saWIvcHJvdG9jb2wvY29uc3RhbnRzL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L215c3FsL2xpYi9wcm90b2NvbC9BdXRoLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImJ1ZmZlclwiIiwid2VicGFjazovLy8uL34vbXlzcWwvbGliL3Byb3RvY29sL3NlcXVlbmNlcy9IYW5kc2hha2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9teXNxbC9saWIvcHJvdG9jb2wvc2VxdWVuY2VzL1BpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9teXNxbC9saWIvcHJvdG9jb2wvc2VxdWVuY2VzL1F1ZXJ5LmpzIiwid2VicGFjazovLy8uL34vbXlzcWwvbGliL3Byb3RvY29sL1Jlc3VsdFNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L215c3FsL2xpYi9wcm90b2NvbC9jb25zdGFudHMvc2VydmVyX3N0YXR1cy5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJmc1wiIiwid2VicGFjazovLy8uL34vbXlzcWwvfi9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9teXNxbC9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L215c3FsL34vcmVhZGFibGUtc3RyZWFtL34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJzdHJlYW1cIiIsIndlYnBhY2s6Ly8vLi9+L215c3FsL34vcmVhZGFibGUtc3RyZWFtL34vY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uL34vbXlzcWwvfi9yZWFkYWJsZS1zdHJlYW0vfi9pbmhlcml0cy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly8vLi9+L215c3FsL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIndlYnBhY2s6Ly8vLi9+L215c3FsL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwid2VicGFjazovLy8uL34vbXlzcWwvfi9yZWFkYWJsZS1zdHJlYW0vfi9zdHJpbmdfZGVjb2Rlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L215c3FsL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9+L215c3FsL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovLy8uL34vbXlzcWwvbGliL3Byb3RvY29sL3NlcXVlbmNlcy9RdWl0LmpzIiwid2VicGFjazovLy8uL34vbXlzcWwvbGliL3Byb3RvY29sL3NlcXVlbmNlcy9TdGF0aXN0aWNzLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcInRpbWVyc1wiIiwid2VicGFjazovLy8uL34vbXlzcWwvbGliL3Byb3RvY29sL1BhY2tldFdyaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L215c3FsL2xpYi9wcm90b2NvbC9TcWxTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9teXNxbC9saWIvUG9vbC5qcyIsIndlYnBhY2s6Ly8vLi9+L215c3FsL2xpYi9Qb29sQ29ubmVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L215c3FsL2xpYi9Qb29sQ2x1c3Rlci5qcyIsIndlYnBhY2s6Ly8vLi9+L215c3FsL2xpYi9Qb29sQ29uZmlnLmpzIiwid2VicGFjazovLy8uL34vbXlzcWwvbGliL1Bvb2xOYW1lc3BhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9teXNxbC9saWIvUG9vbFNlbGVjdG9yLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7QUN0Q0Esb0JBQU8sQ0FBQyxDQUFnQixDQUFDLENBQUM7O0FBRTFCLEtBQUksT0FBTyxHQUFHLG1CQUFPLENBQUMsQ0FBUyxDQUFDLENBQUM7QUFDakMsS0FBSSxJQUFJLEdBQUcsbUJBQU8sQ0FBQyxDQUFNLENBQUMsQ0FBQztBQUMzQixLQUFJLE9BQU8sR0FBRyxtQkFBTyxDQUFDLENBQWUsQ0FBQyxDQUFDO0FBQ3ZDLEtBQUksTUFBTSxHQUFHLG1CQUFPLENBQUMsQ0FBUSxDQUFDLENBQUM7QUFDL0IsS0FBSSxZQUFZLEdBQUcsbUJBQU8sQ0FBQyxDQUFlLENBQUMsQ0FBQztBQUM1QyxLQUFJLFVBQVUsR0FBRyxtQkFBTyxDQUFDLENBQWEsQ0FBQyxDQUFDOztBQUV4QyxLQUFJLE1BQU0sR0FBRyxtQkFBTyxDQUFDLENBQWdCLENBQUMsQ0FBQztBQUN2QyxLQUFJLEtBQUssR0FBRyxtQkFBTyxDQUFDLENBQWdCLENBQUMsQ0FBQzs7QUFFdEMsS0FBSSxHQUFHLEdBQUcsT0FBTyxFQUFFLENBQUM7QUFDcEIsSUFBRyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUscUJBQXFCLENBQUMsQ0FBQztBQUN4QyxJQUFHLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxNQUFNLENBQUM7O0FBRTlCLElBQUcsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDdkIsSUFBRyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztBQUMzQixJQUFHLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ3BELElBQUcsQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQztBQUN4QixJQUFHLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQzs7QUFFekMsSUFBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDckIsSUFBRyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDOzs7QUFHeEIsSUFBRyxDQUFDLEdBQUcsQ0FBQyxVQUFTLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQy9CLE9BQUksR0FBRyxHQUFHLElBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ2pDLE1BQUcsQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDO0FBQ2pCLE9BQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztFQUNYLENBQUM7Ozs7OztBQU1GLEtBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxhQUFhLEVBQUU7QUFDcEMsTUFBRyxDQUFDLEdBQUcsQ0FBQyxVQUFTLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRTtBQUNwQyxRQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLElBQUksR0FBRyxDQUFDLENBQUM7QUFDOUIsUUFBRyxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUU7QUFDbEIsY0FBTyxFQUFFLEdBQUcsQ0FBQyxPQUFPO0FBQ3BCLFlBQUssRUFBRSxHQUFHO01BQ1gsQ0FBQyxDQUFDO0lBQ0osQ0FBQyxDQUFDO0VBQ0o7Ozs7QUFJRCxJQUFHLENBQUMsR0FBRyxDQUFDLFVBQVMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQ3BDLE1BQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sSUFBSSxHQUFHLENBQUMsQ0FBQztBQUM5QixNQUFHLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRTtBQUNsQixZQUFPLEVBQUUsR0FBRyxDQUFDLE9BQU87QUFDcEIsVUFBSyxFQUFFLEVBQUU7SUFDVixDQUFDLENBQUM7RUFDSixDQUFDLENBQUM7O0FBRUgsS0FBSSxLQUFLLEdBQUcsbUJBQU8sQ0FBQyxFQUFPLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ2pELEtBQUksSUFBSSxHQUFHLG1CQUFPLENBQUMsRUFBTSxDQUFDLENBQUM7QUFDM0IsS0FBSSxJQUFJLEdBQUcsYUFBYSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJLE1BQU0sQ0FBQyxDQUFDO0FBQ3JELElBQUcsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3RCLEtBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDcEMsT0FBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNwQixPQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztBQUM1QixPQUFNLENBQUMsRUFBRSxDQUFDLFdBQVcsRUFBRSxXQUFXLENBQUMsQ0FBQzs7QUFFcEMsVUFBUyxhQUFhLENBQUMsR0FBRyxFQUFFO0FBQzFCLE9BQUksSUFBSSxHQUFHLFFBQVEsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7O0FBRTdCLE9BQUksS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFOztBQUVmLFlBQU8sR0FBRyxDQUFDO0lBQ1o7O0FBRUQsT0FBSSxJQUFJLElBQUksQ0FBQyxFQUFFOztBQUViLFlBQU8sSUFBSSxDQUFDO0lBQ2I7O0FBRUQsVUFBTyxLQUFLLENBQUM7RUFDZDtBQUNELFVBQVMsT0FBTyxDQUFDLEtBQUssRUFBRTtBQUN0QixPQUFJLEtBQUssQ0FBQyxPQUFPLEtBQUssUUFBUSxFQUFFO0FBQzlCLFdBQU0sS0FBSyxDQUFDO0lBQ2I7O0FBRUQsT0FBSSxJQUFJLEdBQUcsT0FBTyxJQUFJLEtBQUssUUFBUSxHQUMvQixPQUFPLEdBQUcsSUFBSSxHQUNkLE9BQU8sR0FBRyxJQUFJOzs7QUFHbEIsV0FBUSxLQUFLLENBQUMsSUFBSTtBQUNoQixVQUFLLFFBQVE7QUFDWCxjQUFPLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRywrQkFBK0IsQ0FBQyxDQUFDO0FBQ3RELGNBQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDaEIsYUFBTTtBQUNSLFVBQUssWUFBWTtBQUNmLGNBQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLG9CQUFvQixDQUFDLENBQUM7QUFDM0MsY0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNoQixhQUFNO0FBQ1I7QUFDRSxhQUFNLEtBQUssQ0FBQztBQUFBLElBQ2Y7RUFDRjtBQUNELFVBQVMsV0FBVyxHQUFHO0FBQ3JCLE9BQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUM1QixPQUFJLElBQUksR0FBRyxPQUFPLElBQUksS0FBSyxRQUFRLEdBQy9CLE9BQU8sR0FBRyxJQUFJLEdBQ2QsT0FBTyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7QUFDeEIsUUFBSyxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsQ0FBQzs7Ozs7OztBQzVHaEMsNEM7Ozs7OztBQ0FBLHFDOzs7Ozs7QUNBQSxrQzs7Ozs7O0FDQUEsMkM7Ozs7OztBQ0FBLG9DOzs7Ozs7QUNBQSwyQzs7Ozs7O0FDQUEseUM7Ozs7Ozs7O0FDQUEsS0FBSSxPQUFPLEdBQUcsbUJBQU8sQ0FBQyxDQUFTLENBQUMsQ0FBQztBQUNqQyxLQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFOzs7QUFHN0IsT0FBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsVUFBUyxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRTs7QUFFeEMsTUFBSSxFQUFFLEdBQUcsbUJBQU8sQ0FBQyxFQUFJLENBQUMsQ0FBQztBQUN2QixNQUFJLFFBQVEsR0FBRyxtQkFBTyxDQUFFLEVBQVUsQ0FBQzs7QUFFbkMsV0FBUyxLQUFLLENBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRTtBQUMvQixhQUFVLENBQUMsWUFBVztBQUNyQixZQUFRLENBQUMsSUFBSSxFQUFFLGdCQUFjLEtBQUssYUFBVSxJQUFJLElBQUksRUFBRSxDQUFDLENBQUM7SUFDeEQsRUFBRSxJQUFJLENBQUMsQ0FBQztHQUNUO0FBQ0QsTUFBSSxLQUFLLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDOztBQUU1QixJQUFFLHlCQUFDOzs7OztxQkFDRixPQUFPOztjQUFpQixLQUFLLENBQUMsQ0FBQyxDQUFDOzs7OzttQkFBeEIsR0FBRyxtQkFBQyxJQUFJOztxQkFDaEIsT0FBTzs7Y0FBaUIsS0FBSyxDQUFDLENBQUMsQ0FBQzs7Ozs7bUJBQXhCLEdBQUcsbUJBQUMsSUFBSTs7cUJBQ2hCLE9BQU87O2NBQWlCLEtBQUssQ0FBQyxDQUFDLENBQUM7Ozs7O21CQUF4QixHQUFHLG1CQUFDLElBQUk7O3FCQUNoQixPQUFPOztjQUFpQixLQUFLLENBQUMsQ0FBQyxDQUFDOzs7OzttQkFBeEIsR0FBRyxtQkFBQyxJQUFJOztxQkFDaEIsT0FBTzs7Y0FBaUIsS0FBSyxDQUFDLENBQUMsQ0FBQzs7Ozs7bUJBQXhCLEdBQUcsbUJBQUMsSUFBSTs7Ozs7Ozs7R0FDaEIsRUFBQzs7QUFFRixLQUFHLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDO0VBQzFDLENBQUMsQ0FBQzs7QUFFSCxPQUFNLENBQUMsT0FBTyxHQUFHLE1BQU0sQzs7Ozs7Ozs7QUMzQnZCLEtBQUksT0FBTyxHQUFHLG1CQUFPLENBQUMsQ0FBUyxDQUFDLENBQUM7QUFDakMsS0FBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDOztBQUU5QixLQUFJLEVBQUUsR0FBRyxtQkFBTyxDQUFDLEVBQUksQ0FBQztBQUN0QixLQUFJLFFBQVEsR0FBRyxtQkFBTyxDQUFDLEVBQVUsQ0FBQztBQUNsQyxLQUFJLEVBQUUsR0FBRyxtQkFBTyxDQUFDLEVBQWUsQ0FBQzs7O0FBR2pDLE9BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLFVBQVMsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUU7QUFDeEMsTUFBSSxLQUFLLEdBQUcsUUFBUSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDOztBQUV2QyxJQUFFLHlCQUFDO09BQ0UsTUFBTTs7Ozs7O2NBQVMsS0FBSyxDQUFDLHFCQUFxQixDQUFDOzs7QUFBM0MsYUFBTTs7QUFDVixVQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQzs7Ozs7Ozs7R0FDbkIsRUFBQztFQUNGLENBQUMsQ0FBQzs7QUFFSCxPQUFNLENBQUMsT0FBTyxHQUFHLE1BQU0sQzs7Ozs7O0FDakJ2QixtQzs7Ozs7O0FDQUEsa0M7Ozs7Ozs7QUNDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxrQkFBa0I7QUFDN0IsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFNBQVM7QUFDcEIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsaUJBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCLGlCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWCxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakIsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzT0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFNBQVM7QUFDcEIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQWtCLGlCQUFpQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2hEQSxvQzs7Ozs7Ozs7QUNBQSxLQUFJLEtBQUssR0FBUSxtQkFBTyxDQUFDLEVBQU8sQ0FBQyxDQUFDO0FBQ2xDLEtBQUksVUFBVSxHQUFHLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQztBQUN0QyxPQUFJLEVBQU8sV0FBVztBQUN0QixPQUFJLEVBQU8sTUFBTTtBQUNqQixXQUFRLEVBQUcsVUFBVTtBQUNyQixXQUFRLEVBQUcsaUJBQWlCO0VBQzdCLENBQUMsQ0FBQzs7QUFFSCxPQUFNLENBQUMsT0FBTyxHQUFHLFVBQVUsQzs7Ozs7O0FDUjNCOztBQUVBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBeUIscUNBQXFDO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsK0JBQStCO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsWUFBVyxRQUFRO0FBQ25CLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixZQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsTUFBTTtBQUNqQixZQUFXLFFBQVE7QUFDbkIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVDQUFzQyxzQ0FBc0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsYUEsb0M7Ozs7OztBQ0FBLGlDOzs7Ozs7QUNBQSxpQzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3hNQSxpQzs7Ozs7O0FDQUE7QUFDQSxzQ0FBcUM7QUFDckMsc0NBQXFDO0FBQ3JDLHNDQUFxQztBQUNyQyxzQ0FBcUM7QUFDckMsdUNBQXNDO0FBQ3RDLHVDQUFzQztBQUN0Qyx1Q0FBc0M7QUFDdEMsd0NBQXVDO0FBQ3ZDLHdDQUF1QztBQUN2Qyx3Q0FBdUM7QUFDdkMseUNBQXdDO0FBQ3hDLHlDQUF3QztBQUN4Qyx5Q0FBd0M7QUFDeEMseUNBQXdDO0FBQ3hDLDBDQUF5QztBQUN6QywwQ0FBeUM7O0FBRXpDLHlDQUF3QztBQUN4QywwQ0FBeUM7QUFDekMsMENBQXlDOztBQUV6QyxxQ0FBb0M7O0FBRXBDO0FBQ0E7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3JRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQStCLG9DQUFvQztBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDaGNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUE4RCxXQUFXO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQTZDO0FBQzdDLHdGQUF1RjtBQUN2RjtBQUNBO0FBQ0Esc0ZBQXFGO0FBQ3JGLHNGQUFxRjtBQUNyRixtQkFBa0I7QUFDbEI7QUFDQTtBQUNBLDhGQUE2RjtBQUM3RjtBQUNBLDZCQUE0QixJQUFJO0FBQ2hDLHdGQUF1RjtBQUN2Rix3RkFBdUY7QUFDdkYsd0JBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsNkZBQTRGO0FBQzVGO0FBQ0EsNEJBQTJCLElBQUk7QUFDL0IsZ0dBQStGO0FBQy9GO0FBQ0EsK0JBQThCLElBQUk7QUFDbEMsMEZBQXlGO0FBQ3pGLDBGQUF5RjtBQUN6Rix3QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXVGO0FBQ3ZGO0FBQ0EsdUJBQXNCLElBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNKQTs7QUFFQSxFQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjs7O0FBR2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsd0JBQXdCO0FBQ3RDLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0VBQStELEVBQUU7QUFDakU7QUFDQTtBQUNBOztBQUVBLHVEQUFzRCxFQUFFO0FBQ3hELHFEQUFvRCxFQUFFO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwrRkFBOEYsRUFBRTtBQUNoRztBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXdCLDBCQUEwQjs7QUFFbEQ7QUFDQSxvQ0FBbUMsOEJBQThCO0FBQ2pFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1RkFBc0YsRUFBRTtBQUN4Rjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBOztBQUVBLDRCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QixPQUFPO0FBQ3JDLCtCQUE4QixPQUFPO0FBQ3JDLCtCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQSwrQkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0EsK0JBQThCLGVBQWU7QUFDN0MsK0JBQThCLGVBQWU7QUFDN0MsK0JBQThCLE9BQU87QUFDckMsK0JBQThCLE9BQU87QUFDckMsK0JBQThCLE9BQU87QUFDckMseUNBQXdDO0FBQ3hDLHlDQUF3QztBQUN4Qyx5Q0FBd0M7QUFDeEMseUNBQXdDO0FBQ3hDLHlDQUF3QztBQUN4Qyx5Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2Qix5Q0FBeUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDLHdEQUF3RDtBQUN6RixrQ0FBaUMsbURBQW1EOztBQUVwRixnQ0FBK0IsT0FBTztBQUN0QywwREFBeUQsRUFBRTtBQUMzRCx3REFBdUQsRUFBRTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBOEIsT0FBTztBQUNyQyx5REFBd0QsRUFBRTtBQUMxRCx1REFBc0QsRUFBRTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBK0I7QUFDL0I7QUFDQSwwREFBeUQsRUFBRTtBQUMzRCx3REFBdUQsRUFBRTtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQSxpREFBZ0QsRUFBRTtBQUNsRCxpREFBZ0QsRUFBRTtBQUNsRCwrQ0FBOEMsRUFBRTtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXVCLGVBQWU7QUFDdEMsaUVBQWdFLEVBQUU7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixlQUFlO0FBQ3RDLGlFQUFnRSxFQUFFO0FBQ2xFLCtDQUE4QyxPQUFPO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNEIsT0FBTztBQUNuQyx1REFBc0QsRUFBRTtBQUN4RCxxREFBb0QsRUFBRTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBOEIsT0FBTztBQUNyQyx5REFBd0QsRUFBRTtBQUMxRCx1REFBc0QsRUFBRTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUI7QUFDdkIsaURBQWdELEVBQUU7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7QUFDQSxzQ0FBcUMsb0NBQW9DOzs7QUFHekU7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0Esc0NBQXFDLG9DQUFvQzs7O0FBR3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsT0FBTztBQUN4QjtBQUNBLHNEQUFxRCxHQUFHO0FBQ3hELG9EQUFtRCxHQUFHO0FBQ3RELDJDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCLDZDQUE2QztBQUMxRSw4QkFBNkI7QUFDN0Isa0RBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxnQ0FBK0IsT0FBTzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBcUI7O0FBRXJCO0FBQ0E7O0FBRUEsZ0NBQStCLE9BQU87O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIsWUFBWTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBLG1DQUFrQyxZQUFZOztBQUU5QztBQUNBLDJDQUEwQyxTQUFTOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOzs7QUFHVDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsY0FBYztBQUNqQzs7QUFFQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQSxxQ0FBb0MscUJBQXFCO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFvQyxVQUFVOztBQUU5QztBQUNBLHVDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFvQyxLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQix1Q0FBc0MsUUFBUTs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXVCLE1BQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIsdUJBQXVCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNEIseUJBQXlCO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsMEJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7O0FBRXJCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUEyQyxTQUFTO0FBQ3BEOztBQUVBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUEyQixTQUFTO0FBQ3BDOztBQUVBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUF3RCxLQUFLO0FBQzdELHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsS0FBSztBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFtQixtQkFBbUI7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQixTQUFTOztBQUU1QjtBQUNBLDRCQUEyQixTQUFTOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0RBQXVELEVBQUU7QUFDekQscURBQW9ELEVBQUUsVUFBVSxFQUFFO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTJDLFNBQVM7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esd0NBQXVDLGlCQUFpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCOztBQUVBO0FBQ0EseUNBQXdDLFNBQVM7O0FBRWpEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0NBQStCLEVBQUU7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQSx3REFBdUQsU0FBUztBQUNoRTtBQUNBLDZDQUE0QyxTQUFTOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXdDLGVBQWU7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBbUMsYUFBYTtBQUNoRDs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNEIsS0FBSztBQUNqQztBQUNBLGNBQWE7O0FBRWI7QUFDQTs7QUFFQSxpQ0FBZ0MsT0FBTzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlDQUFnQyxLQUFLO0FBQ3JDOztBQUVBO0FBQ0Esb0JBQW1CLE9BQU87O0FBRTFCO0FBQ0EsaUNBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsWUFBWTs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF1QixLQUFLO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXdCLEdBQUc7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNFQUFxRSxFQUFFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF1QixhQUFhOztBQUVwQztBQUNBLGdDQUErQixTQUFTO0FBQ3hDOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsT0FBTztBQUN4QixrQkFBaUIsT0FBTztBQUN4QjtBQUNBLG1EQUFrRCxHQUFHO0FBQ3JELHFEQUFvRCxHQUFHO0FBQ3ZELG9EQUFtRCxHQUFHO0FBQ3RELGtEQUFpRCxHQUFHO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUE4QyxFQUFFO0FBQ2hELDZDQUE0QyxFQUFFO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIsRUFBRTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5Qjs7QUFFekIsK0RBQThELElBQUksT0FBTyxJQUFJO0FBQzdFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBeUMsS0FBSzs7QUFFOUM7QUFDQTs7QUFFQSwyQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7O0FBRUEsMENBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsT0FBTztBQUN4QixrQkFBaUIsT0FBTztBQUN4QjtBQUNBLGlEQUFnRCxHQUFHO0FBQ25ELG1EQUFrRCxHQUFHO0FBQ3JELHVEQUFzRCxHQUFHO0FBQ3pELHFEQUFvRCxHQUFHO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixPQUFPO0FBQ3hCLGtCQUFpQixPQUFPO0FBQ3hCO0FBQ0EsNkRBQTRELEdBQUc7QUFDL0QsMkRBQTBELEdBQUc7QUFDN0QsNERBQTJELEdBQUc7QUFDOUQsMERBQXlELEdBQUc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsT0FBTztBQUN4QixrQkFBaUIsT0FBTztBQUN4QjtBQUNBLHVEQUFzRCxHQUFHO0FBQ3pELHFEQUFvRCxHQUFHO0FBQ3ZELHNEQUFxRCxHQUFHO0FBQ3hELG9EQUFtRCxHQUFHO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsT0FBTztBQUN4QixrQkFBaUIsT0FBTztBQUN4QjtBQUNBLHdEQUF1RCxHQUFHO0FBQzFELHNEQUFxRCxHQUFHO0FBQ3hELHVEQUFzRCxHQUFHO0FBQ3pELHFEQUFvRCxHQUFHO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4REFBNkQsV0FBVztBQUN4RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQix3QkFBd0I7QUFDekM7QUFDQSwyREFBMEQsR0FBRztBQUM3RCx5REFBd0QsR0FBRztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW1CLEVBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBLDZDQUE0QyxFQUFFO0FBQzlDLDJDQUEwQyxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLEVBQUU7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsT0FBTztBQUN4QixrQkFBaUIsT0FBTztBQUN4QjtBQUNBLHNEQUFxRCxHQUFHO0FBQ3hELG9EQUFtRCxHQUFHO0FBQ3RELDBEQUF5RCxHQUFHO0FBQzVELHdEQUF1RCxHQUFHO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQSw4Q0FBNkMsRUFBRTtBQUMvQyw0Q0FBMkMsRUFBRTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsMEJBQXlCO0FBQ3pCLGdDQUErQjtBQUMvQixnQ0FBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLG9CQUFtQixLQUFLO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSw0QkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscUJBQW9CLE9BQU87O0FBRTNCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFlLFNBQVM7QUFDeEIscUNBQW9DLFFBQVE7QUFDNUM7O0FBRUEsb0JBQW1CLGdCQUFnQjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUEyQixLQUFLO0FBQ2hDOztBQUVBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSx5Q0FBd0MsS0FBSztBQUM3QztBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQTZCLGtCQUFrQixFQUFFOztBQUVqRDtBQUNBLE1BQUs7QUFDTDtBQUNBLDZCQUE0Qiw0QkFBNEIsRUFBRTs7QUFFMUQ7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUM7Ozs7Ozs7QUMxbkZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBNkIsdUNBQXVDOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNwSEEsa0M7Ozs7OztBQ0FBLG9DOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2xDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDL0JBO0FBQ0E7QUFDQSw0QkFBMkI7QUFDM0IsNEJBQTJCO0FBQzNCLDRCQUEyQjtBQUMzQiw0QkFBMkI7QUFDM0IsNEJBQTJCO0FBQzNCLDRCQUEyQjtBQUMzQiw0QkFBMkI7QUFDM0IsNEJBQTJCO0FBQzNCLDRCQUEyQjtBQUMzQiw0QkFBMkI7QUFDM0IsNEJBQTJCO0FBQzNCLDRCQUEyQjtBQUMzQiw0QkFBMkI7QUFDM0IsNEJBQTJCO0FBQzNCLDRCQUEyQjtBQUMzQiw0QkFBMkI7QUFDM0IsNEJBQTJCO0FBQzNCLDRCQUEyQjtBQUMzQiw0QkFBMkI7QUFDM0IsNEJBQTJCO0FBQzNCLDRCQUEyQjtBQUMzQiw0QkFBMkI7QUFDM0IsNEJBQTJCO0FBQzNCLDRCQUEyQjtBQUMzQiw0QkFBMkI7QUFDM0IsNEJBQTJCO0FBQzNCLDRCQUEyQjs7Ozs7OztBQzVCM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM1RkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNuR0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBLHVEQUFzRCxzQ0FBc0M7QUFDNUYsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZIQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3o3REE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBLGtCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNwS0Esb0M7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLG1CQUFtQjtBQUNoRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN2R0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7OztBQUdIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWdDO0FBQ2hDLElBQUc7O0FBRUg7QUFDQSw4QkFBNkI7QUFDN0IsSUFBRzs7QUFFSDtBQUNBLDBCQUF5QjtBQUN6Qix1QkFBc0I7QUFDdEIsSUFBRzs7QUFFSDtBQUNBLG9DQUFtQztBQUNuQyxJQUFHOztBQUVIO0FBQ0E7Ozs7Ozs7QUMxTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNOQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDO0FBQzVDLDZDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdENBLGdDOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0M7QUFDbEM7QUFDQSxTQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBc0MsZ0JBQWdCO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsaUNBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0N0JBO0FBQ0E7QUFDQTs7Ozs7OztBQ0ZBLG9DOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQzFHQTs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBOzs7Ozs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQix5QkFBeUI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLG9CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM1ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzVOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDN0NBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMzQkEsb0M7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUFzQixrQkFBa0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDcE1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRDQUEyQyw0Q0FBNEM7O0FBRXZGO0FBQ0E7O0FBRUEsZ0NBQStCLG9DQUFvQztBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsb0NBQW9DO0FBQy9ELElBQUc7QUFDSDtBQUNBLHNCQUFxQixvQ0FBb0M7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM3UkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFpQixvQkFBb0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWlCLHlCQUF5QjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBd0MsaURBQWlELEVBQUU7QUFDM0Y7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ3BSQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUMvQkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImFwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgMGE2OTI0MDNjOGNkNzFhOWQ0ZmVcbiAqKi8iLCJyZXF1aXJlKFwiYmFiZWwtcG9seWZpbGxcIik7XG5cbnZhciBleHByZXNzID0gcmVxdWlyZSgnZXhwcmVzcycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgZmF2aWNvbiA9IHJlcXVpcmUoJ3NlcnZlLWZhdmljb24nKTtcbnZhciBsb2dnZXIgPSByZXF1aXJlKCdtb3JnYW4nKTtcbnZhciBjb29raWVQYXJzZXIgPSByZXF1aXJlKCdjb29raWUtcGFyc2VyJyk7XG52YXIgYm9keVBhcnNlciA9IHJlcXVpcmUoJ2JvZHktcGFyc2VyJyk7XG5cbnZhciByb3V0ZXMgPSByZXF1aXJlKCcuL3JvdXRlcy9pbmRleCcpO1xudmFyIHVzZXJzID0gcmVxdWlyZSgnLi9yb3V0ZXMvdXNlcnMnKTtcblxudmFyIGFwcCA9IGV4cHJlc3MoKTtcbmFwcC5zZXQoJ3ZpZXdzJywgJy4vZGlzdC9zZXJ2ZXIvdmlld3MnKTtcbmFwcC5zZXQoJ3ZpZXcgZW5naW5lJywgJ2phZGUnKTtcbi8vYXBwLnVzZShmYXZpY29uKHBhdGguam9pbihfX2Rpcm5hbWUsICdwdWJsaWMnLCAnZmF2aWNvbi5pY28nKSkpO1xuYXBwLnVzZShsb2dnZXIoJ2RldicpKTtcbmFwcC51c2UoYm9keVBhcnNlci5qc29uKCkpO1xuYXBwLnVzZShib2R5UGFyc2VyLnVybGVuY29kZWQoeyBleHRlbmRlZDogZmFsc2UgfSkpO1xuYXBwLnVzZShjb29raWVQYXJzZXIoKSk7XG5hcHAudXNlKGV4cHJlc3Muc3RhdGljKCcuL2Rpc3QvcHVibGljJykpO1xuXG5hcHAudXNlKCcvJywgcm91dGVzKTtcbmFwcC51c2UoJy91c2VycycsIHVzZXJzKTtcblxuLy8gY2F0Y2ggNDA0IGFuZCBmb3J3YXJkIHRvIGVycm9yIGhhbmRsZXJcbmFwcC51c2UoZnVuY3Rpb24ocmVxLCByZXMsIG5leHQpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcignTm90IEZvdW5kJyk7XG4gIGVyci5zdGF0dXMgPSA0MDQ7XG4gIG5leHQoZXJyKTtcbn0pO1xuXG4vLyBlcnJvciBoYW5kbGVyc1xuXG4vLyBkZXZlbG9wbWVudCBlcnJvciBoYW5kbGVyXG4vLyB3aWxsIHByaW50IHN0YWNrdHJhY2VcbmlmIChhcHAuZ2V0KCdlbnYnKSA9PT0gJ2RldmVsb3BtZW50Jykge1xuICBhcHAudXNlKGZ1bmN0aW9uKGVyciwgcmVxLCByZXMsIG5leHQpIHtcbiAgICByZXMuc3RhdHVzKGVyci5zdGF0dXMgfHwgNTAwKTtcbiAgICByZXMucmVuZGVyKCdlcnJvcicsIHtcbiAgICAgIG1lc3NhZ2U6IGVyci5tZXNzYWdlLFxuICAgICAgZXJyb3I6IGVyclxuICAgIH0pO1xuICB9KTtcbn1cblxuLy8gcHJvZHVjdGlvbiBlcnJvciBoYW5kbGVyXG4vLyBubyBzdGFja3RyYWNlcyBsZWFrZWQgdG8gdXNlclxuYXBwLnVzZShmdW5jdGlvbihlcnIsIHJlcSwgcmVzLCBuZXh0KSB7XG4gIHJlcy5zdGF0dXMoZXJyLnN0YXR1cyB8fCA1MDApO1xuICByZXMucmVuZGVyKCdlcnJvcicsIHtcbiAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcbiAgICBlcnJvcjoge31cbiAgfSk7XG59KTtcblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZ2VuZXJhdG9yOnNlcnZlcicpO1xudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgcG9ydCA9IG5vcm1hbGl6ZVBvcnQocHJvY2Vzcy5lbnYuUE9SVCB8fCAnMzAwMCcpO1xuYXBwLnNldCgncG9ydCcsIHBvcnQpO1xudmFyIHNlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKGFwcCk7XG5zZXJ2ZXIubGlzdGVuKHBvcnQpO1xuc2VydmVyLm9uKCdlcnJvcicsIG9uRXJyb3IpO1xuc2VydmVyLm9uKCdsaXN0ZW5pbmcnLCBvbkxpc3RlbmluZyk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBvcnQodmFsKSB7XG4gIHZhciBwb3J0ID0gcGFyc2VJbnQodmFsLCAxMCk7XG5cbiAgaWYgKGlzTmFOKHBvcnQpKSB7XG4gICAgLy8gbmFtZWQgcGlwZVxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBpZiAocG9ydCA+PSAwKSB7XG4gICAgLy8gcG9ydCBudW1iZXJcbiAgICByZXR1cm4gcG9ydDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgaWYgKGVycm9yLnN5c2NhbGwgIT09ICdsaXN0ZW4nKSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICB2YXIgYmluZCA9IHR5cGVvZiBwb3J0ID09PSAnc3RyaW5nJ1xuICAgID8gJ1BpcGUgJyArIHBvcnRcbiAgICA6ICdQb3J0ICcgKyBwb3J0O1xuXG4gIC8vIGhhbmRsZSBzcGVjaWZpYyBsaXN0ZW4gZXJyb3JzIHdpdGggZnJpZW5kbHkgbWVzc2FnZXNcbiAgc3dpdGNoIChlcnJvci5jb2RlKSB7XG4gICAgY2FzZSAnRUFDQ0VTJzpcbiAgICAgIGNvbnNvbGUuZXJyb3IoYmluZCArICcgcmVxdWlyZXMgZWxldmF0ZWQgcHJpdmlsZWdlcycpO1xuICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnRUFERFJJTlVTRSc6XG4gICAgICBjb25zb2xlLmVycm9yKGJpbmQgKyAnIGlzIGFscmVhZHkgaW4gdXNlJyk7XG4gICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIG9uTGlzdGVuaW5nKCkge1xuICB2YXIgYWRkciA9IHNlcnZlci5hZGRyZXNzKCk7XG4gIHZhciBiaW5kID0gdHlwZW9mIGFkZHIgPT09ICdzdHJpbmcnXG4gICAgPyAncGlwZSAnICsgYWRkclxuICAgIDogJ3BvcnQgJyArIGFkZHIucG9ydDtcbiAgZGVidWcoJ0xpc3RlbmluZyBvbiAnICsgYmluZCk7XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9zZXJ2ZXIvYXBwLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcG9seWZpbGxcIik7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcImJhYmVsLXBvbHlmaWxsXCJcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJleHByZXNzXCIpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJleHByZXNzXCJcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJwYXRoXCJcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzZXJ2ZS1mYXZpY29uXCIpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJzZXJ2ZS1mYXZpY29uXCJcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJtb3JnYW5cIik7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcIm1vcmdhblwiXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29va2llLXBhcnNlclwiKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIGV4dGVybmFsIFwiY29va2llLXBhcnNlclwiXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYm9keS1wYXJzZXJcIik7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcImJvZHktcGFyc2VyXCJcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZXhwcmVzcyA9IHJlcXVpcmUoJ2V4cHJlc3MnKTtcbnZhciByb3V0ZXIgPSBleHByZXNzLlJvdXRlcigpO1xuXG4vKiBHRVQgaG9tZSBwYWdlLiAqL1xucm91dGVyLmdldCgnLycsIGZ1bmN0aW9uKHJlcSwgcmVzLCBuZXh0KSB7XG5cdFxuXHR2YXIgY28gPSByZXF1aXJlKCdjbycpO1xuXHR2YXIgdGh1bmtpZnkgPSByZXF1aXJlIChcInRodW5raWZ5XCIpXG5cdFxuXHRmdW5jdGlvbiBzbGVlcChwYXJhbSwgY2FsbGJhY2spIHtcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgYEkgd29rZSB1cCAoJHtwYXJhbX0pIGF0IGAgKyBuZXcgRGF0ZSgpKTtcblx0XHR9LCAxMDAwKTtcblx0fVxuXHR2YXIgc2xlZXAgPSB0aHVua2lmeShzbGVlcCk7XG5cdFxuXHRjbyhmdW5jdGlvbiAqKCkge1xuXHRcdGNvbnNvbGUubG9nKFwiMTpcIiwgeWllbGQgc2xlZXAoMSkpO1xuXHRcdGNvbnNvbGUubG9nKFwiMjpcIiwgeWllbGQgc2xlZXAoMikpO1xuXHRcdGNvbnNvbGUubG9nKFwiMzpcIiwgeWllbGQgc2xlZXAoMykpO1xuXHRcdGNvbnNvbGUubG9nKFwiNDpcIiwgeWllbGQgc2xlZXAoNCkpO1xuXHRcdGNvbnNvbGUubG9nKFwiNTpcIiwgeWllbGQgc2xlZXAoNSkpO1xuXHR9KVxuXG5cdHJlcy5yZW5kZXIoJ2luZGV4JywgeyB0aXRsZTogJ0V4cHJlc3MnIH0pO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm91dGVyO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvc2VydmVyL3JvdXRlcy9pbmRleC5qc1xuICoqLyIsInZhciBleHByZXNzID0gcmVxdWlyZSgnZXhwcmVzcycpO1xudmFyIHJvdXRlciA9IGV4cHJlc3MuUm91dGVyKCk7XG5cbnZhciBjbyA9IHJlcXVpcmUoXCJjb1wiKVxudmFyIHRodW5raWZ5ID0gcmVxdWlyZShcInRodW5raWZ5XCIpXG52YXIgZGIgPSByZXF1aXJlKFwiLi4vbGlicy9teXNxbFwiKVxuXG4vKiBHRVQgdXNlcnMgbGlzdGluZy4gKi9cbnJvdXRlci5nZXQoJy8nLCBmdW5jdGlvbihyZXEsIHJlcywgbmV4dCkge1xuXHR2YXIgcXVlcnkgPSB0aHVua2lmeShkYi5xdWVyeS5iaW5kKGRiKSlcblx0XG5cdGNvKGZ1bmN0aW9uICooKSB7XG5cdFx0dmFyIHJlc3VsdCA9IHlpZWxkIHF1ZXJ5KFwic2VsZWN0ICogZnJvbSB1c2Vyc1wiKVxuXHRcdHJlcy5qc29uKHJlc3VsdFswXSlcblx0fSlcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvdXRlcjtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3NlcnZlci9yb3V0ZXMvdXNlcnMuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIGV4dGVybmFsIFwiZGVidWdcIlxuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwXCIpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJodHRwXCJcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKipcbiAqIHNsaWNlKCkgcmVmZXJlbmNlLlxuICovXG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLyoqXG4gKiBFeHBvc2UgYGNvYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvWydkZWZhdWx0J10gPSBjby5jbyA9IGNvO1xuXG4vKipcbiAqIFdyYXAgdGhlIGdpdmVuIGdlbmVyYXRvciBgZm5gIGludG8gYVxuICogZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIFRoaXMgaXMgYSBzZXBhcmF0ZSBmdW5jdGlvbiBzbyB0aGF0XG4gKiBldmVyeSBgY28oKWAgY2FsbCBkb2Vzbid0IGNyZWF0ZSBhIG5ldyxcbiAqIHVubmVjZXNzYXJ5IGNsb3N1cmUuXG4gKlxuICogQHBhcmFtIHtHZW5lcmF0b3JGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5jby53cmFwID0gZnVuY3Rpb24gKGZuKSB7XG4gIGNyZWF0ZVByb21pc2UuX19nZW5lcmF0b3JGdW5jdGlvbl9fID0gZm47XG4gIHJldHVybiBjcmVhdGVQcm9taXNlO1xuICBmdW5jdGlvbiBjcmVhdGVQcm9taXNlKCkge1xuICAgIHJldHVybiBjby5jYWxsKHRoaXMsIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBvciBhIGdlbmVyYXRvclxuICogYW5kIHJldHVybiBhIHByb21pc2UuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNvKGdlbikge1xuICB2YXIgY3R4ID0gdGhpcztcbiAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcblxuICAvLyB3ZSB3cmFwIGV2ZXJ5dGhpbmcgaW4gYSBwcm9taXNlIHRvIGF2b2lkIHByb21pc2UgY2hhaW5pbmcsXG4gIC8vIHdoaWNoIGxlYWRzIHRvIG1lbW9yeSBsZWFrIGVycm9ycy5cbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90ai9jby9pc3N1ZXMvMTgwXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAodHlwZW9mIGdlbiA9PT0gJ2Z1bmN0aW9uJykgZ2VuID0gZ2VuLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgaWYgKCFnZW4gfHwgdHlwZW9mIGdlbi5uZXh0ICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gcmVzb2x2ZShnZW4pO1xuXG4gICAgb25GdWxmaWxsZWQoKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHJlc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBvbkZ1bGZpbGxlZChyZXMpIHtcbiAgICAgIHZhciByZXQ7XG4gICAgICB0cnkge1xuICAgICAgICByZXQgPSBnZW4ubmV4dChyZXMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGUpO1xuICAgICAgfVxuICAgICAgbmV4dChyZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBvblJlamVjdGVkKGVycikge1xuICAgICAgdmFyIHJldDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldCA9IGdlbi50aHJvdyhlcnIpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGUpO1xuICAgICAgfVxuICAgICAgbmV4dChyZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV4dCB2YWx1ZSBpbiB0aGUgZ2VuZXJhdG9yLFxuICAgICAqIHJldHVybiBhIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmV0XG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIG5leHQocmV0KSB7XG4gICAgICBpZiAocmV0LmRvbmUpIHJldHVybiByZXNvbHZlKHJldC52YWx1ZSk7XG4gICAgICB2YXIgdmFsdWUgPSB0b1Byb21pc2UuY2FsbChjdHgsIHJldC52YWx1ZSk7XG4gICAgICBpZiAodmFsdWUgJiYgaXNQcm9taXNlKHZhbHVlKSkgcmV0dXJuIHZhbHVlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgICAgcmV0dXJuIG9uUmVqZWN0ZWQobmV3IFR5cGVFcnJvcignWW91IG1heSBvbmx5IHlpZWxkIGEgZnVuY3Rpb24sIHByb21pc2UsIGdlbmVyYXRvciwgYXJyYXksIG9yIG9iamVjdCwgJ1xuICAgICAgICArICdidXQgdGhlIGZvbGxvd2luZyBvYmplY3Qgd2FzIHBhc3NlZDogXCInICsgU3RyaW5nKHJldC52YWx1ZSkgKyAnXCInKSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgYHlpZWxkYGVkIHZhbHVlIGludG8gYSBwcm9taXNlLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9ialxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHRvUHJvbWlzZShvYmopIHtcbiAgaWYgKCFvYmopIHJldHVybiBvYmo7XG4gIGlmIChpc1Byb21pc2Uob2JqKSkgcmV0dXJuIG9iajtcbiAgaWYgKGlzR2VuZXJhdG9yRnVuY3Rpb24ob2JqKSB8fCBpc0dlbmVyYXRvcihvYmopKSByZXR1cm4gY28uY2FsbCh0aGlzLCBvYmopO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygb2JqKSByZXR1cm4gdGh1bmtUb1Byb21pc2UuY2FsbCh0aGlzLCBvYmopO1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSByZXR1cm4gYXJyYXlUb1Byb21pc2UuY2FsbCh0aGlzLCBvYmopO1xuICBpZiAoaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iamVjdFRvUHJvbWlzZS5jYWxsKHRoaXMsIG9iaik7XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogQ29udmVydCBhIHRodW5rIHRvIGEgcHJvbWlzZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHRodW5rVG9Qcm9taXNlKGZuKSB7XG4gIHZhciBjdHggPSB0aGlzO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZuLmNhbGwoY3R4LCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikgcmVzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgcmVzb2x2ZShyZXMpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIFwieWllbGRhYmxlc1wiIHRvIGEgcHJvbWlzZS5cbiAqIFVzZXMgYFByb21pc2UuYWxsKClgIGludGVybmFsbHkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gb2JqXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gYXJyYXlUb1Byb21pc2Uob2JqKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChvYmoubWFwKHRvUHJvbWlzZSwgdGhpcykpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gb2JqZWN0IG9mIFwieWllbGRhYmxlc1wiIHRvIGEgcHJvbWlzZS5cbiAqIFVzZXMgYFByb21pc2UuYWxsKClgIGludGVybmFsbHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG9iamVjdFRvUHJvbWlzZShvYmope1xuICB2YXIgcmVzdWx0cyA9IG5ldyBvYmouY29uc3RydWN0b3IoKTtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgdmFyIHByb21pc2UgPSB0b1Byb21pc2UuY2FsbCh0aGlzLCBvYmpba2V5XSk7XG4gICAgaWYgKHByb21pc2UgJiYgaXNQcm9taXNlKHByb21pc2UpKSBkZWZlcihwcm9taXNlLCBrZXkpO1xuICAgIGVsc2UgcmVzdWx0c1trZXldID0gb2JqW2tleV07XG4gIH1cbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZGVmZXIocHJvbWlzZSwga2V5KSB7XG4gICAgLy8gcHJlZGVmaW5lIHRoZSBrZXkgaW4gdGhlIHJlc3VsdFxuICAgIHJlc3VsdHNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICBwcm9taXNlcy5wdXNoKHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICByZXN1bHRzW2tleV0gPSByZXM7XG4gICAgfSkpO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBwcm9taXNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7XG4gIHJldHVybiAnZnVuY3Rpb24nID09IHR5cGVvZiBvYmoudGhlbjtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIGdlbmVyYXRvci5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0dlbmVyYXRvcihvYmopIHtcbiAgcmV0dXJuICdmdW5jdGlvbicgPT0gdHlwZW9mIG9iai5uZXh0ICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIG9iai50aHJvdztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihvYmopIHtcbiAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICBpZiAoIWNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG4gIGlmICgnR2VuZXJhdG9yRnVuY3Rpb24nID09PSBjb25zdHJ1Y3Rvci5uYW1lIHx8ICdHZW5lcmF0b3JGdW5jdGlvbicgPT09IGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGlzR2VuZXJhdG9yKGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIE9iamVjdCA9PSB2YWwuY29uc3RydWN0b3I7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jby9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbi8qKlxuICogRXhwb3NlIGB0aHVua2lmeSgpYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRodW5raWZ5O1xuXG4vKipcbiAqIFdyYXAgYSByZWd1bGFyIGNhbGxiYWNrIGBmbmAgYXMgYSB0aHVuay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHRodW5raWZ5KGZuKXtcbiAgYXNzZXJ0KCdmdW5jdGlvbicgPT0gdHlwZW9mIGZuLCAnZnVuY3Rpb24gcmVxdWlyZWQnKTtcblxuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICB2YXIgY3R4ID0gdGhpcztcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihkb25lKXtcbiAgICAgIHZhciBjYWxsZWQ7XG5cbiAgICAgIGFyZ3MucHVzaChmdW5jdGlvbigpe1xuICAgICAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGRvbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmbi5hcHBseShjdHgsIGFyZ3MpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGRvbmUoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90aHVua2lmeS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcImFzc2VydFwiXG4gKiogbW9kdWxlIGlkID0gMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBteXNxbCAgICAgID0gcmVxdWlyZSgnbXlzcWwnKTtcbnZhciBjb25uZWN0aW9uID0gbXlzcWwuY3JlYXRlQ29ubmVjdGlvbih7XG4gIGhvc3QgICAgIDogJ2xvY2FsaG9zdCcsXG4gIHVzZXIgICAgIDogJ3Jvb3QnLFxuICBwYXNzd29yZCA6ICd5dXRhMDUwMicsXG4gIGRhdGFiYXNlIDogJ2V4cHJlc3M0LXNhbXBsZSdcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbm5lY3Rpb25cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3NlcnZlci9saWJzL215c3FsLmpzXG4gKiovIiwidmFyIENsYXNzZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBDb25uZWN0aW9uIGluc3RhbmNlLlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICogQHB1YmxpY1xuICovXG5leHBvcnRzLmNyZWF0ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uKGNvbmZpZykge1xuICB2YXIgQ29ubmVjdGlvbiAgICAgICA9IGxvYWRDbGFzcygnQ29ubmVjdGlvbicpO1xuICB2YXIgQ29ubmVjdGlvbkNvbmZpZyA9IGxvYWRDbGFzcygnQ29ubmVjdGlvbkNvbmZpZycpO1xuXG4gIHJldHVybiBuZXcgQ29ubmVjdGlvbih7Y29uZmlnOiBuZXcgQ29ubmVjdGlvbkNvbmZpZyhjb25maWcpfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBQb29sIGluc3RhbmNlLlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICogQHB1YmxpY1xuICovXG5leHBvcnRzLmNyZWF0ZVBvb2wgPSBmdW5jdGlvbiBjcmVhdGVQb29sKGNvbmZpZykge1xuICB2YXIgUG9vbCAgICAgICA9IGxvYWRDbGFzcygnUG9vbCcpO1xuICB2YXIgUG9vbENvbmZpZyA9IGxvYWRDbGFzcygnUG9vbENvbmZpZycpO1xuXG4gIHJldHVybiBuZXcgUG9vbCh7Y29uZmlnOiBuZXcgUG9vbENvbmZpZyhjb25maWcpfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBQb29sQ2x1c3RlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0cy5jcmVhdGVQb29sQ2x1c3RlciA9IGZ1bmN0aW9uIGNyZWF0ZVBvb2xDbHVzdGVyKGNvbmZpZykge1xuICB2YXIgUG9vbENsdXN0ZXIgPSBsb2FkQ2xhc3MoJ1Bvb2xDbHVzdGVyJyk7XG5cbiAgcmV0dXJuIG5ldyBQb29sQ2x1c3Rlcihjb25maWcpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgUXVlcnkgaW5zdGFuY2UuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydHMuY3JlYXRlUXVlcnkgPSBmdW5jdGlvbiBjcmVhdGVRdWVyeShzcWwsIHZhbHVlcywgY2FsbGJhY2spIHtcbiAgdmFyIENvbm5lY3Rpb24gPSBsb2FkQ2xhc3MoJ0Nvbm5lY3Rpb24nKTtcblxuICByZXR1cm4gQ29ubmVjdGlvbi5jcmVhdGVRdWVyeShzcWwsIHZhbHVlcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBFc2NhcGUgYSB2YWx1ZSBmb3IgU1FMLlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBbc3RyaW5naWZ5T2JqZWN0cz1mYWxzZV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdGltZVpvbmU9bG9jYWxdXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydHMuZXNjYXBlID0gZnVuY3Rpb24gZXNjYXBlKHZhbHVlLCBzdHJpbmdpZnlPYmplY3RzLCB0aW1lWm9uZSkge1xuICB2YXIgU3FsU3RyaW5nID0gbG9hZENsYXNzKCdTcWxTdHJpbmcnKTtcblxuICByZXR1cm4gU3FsU3RyaW5nLmVzY2FwZSh2YWx1ZSwgc3RyaW5naWZ5T2JqZWN0cywgdGltZVpvbmUpO1xufTtcblxuLyoqXG4gKiBFc2NhcGUgYW4gaWRlbnRpZmllciBmb3IgU1FMLlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBbZm9yYmlkUXVhbGlmaWVkXVxuICogQHB1YmxpY1xuICovXG5leHBvcnRzLmVzY2FwZUlkID0gZnVuY3Rpb24gZXNjYXBlSWQodmFsdWUsIGZvcmJpZFF1YWxpZmllZCkge1xuICB2YXIgU3FsU3RyaW5nID0gbG9hZENsYXNzKCdTcWxTdHJpbmcnKTtcblxuICByZXR1cm4gU3FsU3RyaW5nLmVzY2FwZUlkKHZhbHVlLCBmb3JiaWRRdWFsaWZpZWQpO1xufTtcblxuLyoqXG4gKiBGb3JtYXQgU1FMIGFuZCByZXBsYWNlbWVudCB2YWx1ZXMgaW50byBhIFNRTCBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3FsXG4gKiBAcGFyYW0ge2FycmF5fSBbdmFsdWVzXVxuICogQHBhcmFtIHtib29sZWFufSBbc3RyaW5naWZ5T2JqZWN0cz1mYWxzZV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdGltZVpvbmU9bG9jYWxdXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24gZm9ybWF0KHNxbCwgdmFsdWVzLCBzdHJpbmdpZnlPYmplY3RzLCB0aW1lWm9uZSkge1xuICB2YXIgU3FsU3RyaW5nID0gbG9hZENsYXNzKCdTcWxTdHJpbmcnKTtcblxuICByZXR1cm4gU3FsU3RyaW5nLmZvcm1hdChzcWwsIHZhbHVlcywgc3RyaW5naWZ5T2JqZWN0cywgdGltZVpvbmUpO1xufTtcblxuLyoqXG4gKiBUaGUgdHlwZSBjb25zdGFudHMuXG4gKiBAcHVibGljXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnVHlwZXMnLCB7XG4gIGdldDogbG9hZENsYXNzLmJpbmQobnVsbCwgJ1R5cGVzJylcbn0pO1xuXG4vKipcbiAqIExvYWQgdGhlIGdpdmVuIGNsYXNzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZENsYXNzKGNsYXNzTmFtZSkge1xuICB2YXIgQ2xhc3MgPSBDbGFzc2VzW2NsYXNzTmFtZV07XG5cbiAgaWYgKENsYXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gQ2xhc3M7XG4gIH1cblxuICAvLyBUaGlzIHVzZXMgYSBzd2l0Y2ggZm9yIHN0YXRpYyByZXF1aXJlIGFuYWx5c2lzXG4gIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgY2FzZSAnQ29ubmVjdGlvbic6XG4gICAgICBDbGFzcyA9IHJlcXVpcmUoJy4vbGliL0Nvbm5lY3Rpb24nKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0Nvbm5lY3Rpb25Db25maWcnOlxuICAgICAgQ2xhc3MgPSByZXF1aXJlKCcuL2xpYi9Db25uZWN0aW9uQ29uZmlnJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdQb29sJzpcbiAgICAgIENsYXNzID0gcmVxdWlyZSgnLi9saWIvUG9vbCcpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUG9vbENsdXN0ZXInOlxuICAgICAgQ2xhc3MgPSByZXF1aXJlKCcuL2xpYi9Qb29sQ2x1c3RlcicpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUG9vbENvbmZpZyc6XG4gICAgICBDbGFzcyA9IHJlcXVpcmUoJy4vbGliL1Bvb2xDb25maWcnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1NxbFN0cmluZyc6XG4gICAgICBDbGFzcyA9IHJlcXVpcmUoJy4vbGliL3Byb3RvY29sL1NxbFN0cmluZycpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnVHlwZXMnOlxuICAgICAgQ2xhc3MgPSByZXF1aXJlKCcuL2xpYi9wcm90b2NvbC9jb25zdGFudHMvdHlwZXMnKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGNsYXNzIFxcJycgKyBjbGFzc05hbWUgKyAnXFwnJyk7XG4gIH1cblxuICAvLyBTdG9yZSB0byBwcmV2ZW50IGludm9raW5nIHJlcXVpcmUoKVxuICBDbGFzc2VzW2NsYXNzTmFtZV0gPSBDbGFzcztcblxuICByZXR1cm4gQ2xhc3M7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgQ3J5cHRvICAgICAgICAgICA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIE5ldCAgICAgICAgICAgICAgPSByZXF1aXJlKCduZXQnKTtcbnZhciB0bHMgICAgICAgICAgICAgID0gcmVxdWlyZSgndGxzJyk7XG52YXIgQ29ubmVjdGlvbkNvbmZpZyA9IHJlcXVpcmUoJy4vQ29ubmVjdGlvbkNvbmZpZycpO1xudmFyIFByb3RvY29sICAgICAgICAgPSByZXF1aXJlKCcuL3Byb3RvY29sL1Byb3RvY29sJyk7XG52YXIgU3FsU3RyaW5nICAgICAgICA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvU3FsU3RyaW5nJyk7XG52YXIgUXVlcnkgICAgICAgICAgICA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvc2VxdWVuY2VzL1F1ZXJ5Jyk7XG52YXIgRXZlbnRFbWl0dGVyICAgICA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBVdGlsICAgICAgICAgICAgID0gcmVxdWlyZSgndXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb247XG5VdGlsLmluaGVyaXRzKENvbm5lY3Rpb24sIEV2ZW50RW1pdHRlcik7XG5mdW5jdGlvbiBDb25uZWN0aW9uKG9wdGlvbnMpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5jb25maWcgPSBvcHRpb25zLmNvbmZpZztcblxuICB0aGlzLl9zb2NrZXQgICAgICAgID0gb3B0aW9ucy5zb2NrZXQ7XG4gIHRoaXMuX3Byb3RvY29sICAgICAgPSBuZXcgUHJvdG9jb2woe2NvbmZpZzogdGhpcy5jb25maWcsIGNvbm5lY3Rpb246IHRoaXN9KTtcbiAgdGhpcy5fY29ubmVjdENhbGxlZCA9IGZhbHNlO1xuICB0aGlzLnN0YXRlICAgICAgICAgID0gXCJkaXNjb25uZWN0ZWRcIjtcbiAgdGhpcy50aHJlYWRJZCAgICAgICA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGJpbmRUb0N1cnJlbnREb21haW4oY2FsbGJhY2spIHtcbiAgaWYgKCFjYWxsYmFjaykgcmV0dXJuO1xuXG4gIHZhciBkb21haW4gPSBwcm9jZXNzLmRvbWFpbjtcblxuICByZXR1cm4gZG9tYWluXG4gICAgPyBkb21haW4uYmluZChjYWxsYmFjaylcbiAgICA6IGNhbGxiYWNrO1xufVxuXG5Db25uZWN0aW9uLmNyZWF0ZVF1ZXJ5ID0gZnVuY3Rpb24gY3JlYXRlUXVlcnkoc3FsLCB2YWx1ZXMsIGNhbGxiYWNrKSB7XG4gIGlmIChzcWwgaW5zdGFuY2VvZiBRdWVyeSkge1xuICAgIHJldHVybiBzcWw7XG4gIH1cblxuICB2YXIgY2IgICAgICA9IGJpbmRUb0N1cnJlbnREb21haW4oY2FsbGJhY2spO1xuICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gIGlmICh0eXBlb2Ygc3FsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBiaW5kVG9DdXJyZW50RG9tYWluKHNxbCk7XG4gICAgcmV0dXJuIG5ldyBRdWVyeShvcHRpb25zLCBjYik7XG4gIH1cblxuICBpZiAodHlwZW9mIHNxbCA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIHNxbCkge1xuICAgICAgb3B0aW9uc1twcm9wXSA9IHNxbFtwcm9wXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBiaW5kVG9DdXJyZW50RG9tYWluKHZhbHVlcyk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBRdWVyeShvcHRpb25zLCBjYik7XG4gIH1cblxuICBvcHRpb25zLnNxbCAgICA9IHNxbDtcbiAgb3B0aW9ucy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGJpbmRUb0N1cnJlbnREb21haW4odmFsdWVzKTtcbiAgICBvcHRpb25zLnZhbHVlcyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChjYiA9PT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24gd2hlbiBwcm92aWRlZCcpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBRdWVyeShvcHRpb25zLCBjYik7XG59O1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gY29ubmVjdChvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAoIWNhbGxiYWNrICYmIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGlmICghdGhpcy5fY29ubmVjdENhbGxlZCkge1xuICAgIHRoaXMuX2Nvbm5lY3RDYWxsZWQgPSB0cnVlO1xuXG4gICAgLy8gQ29ubmVjdCBlaXRoZXIgdmlhIGEgVU5JWCBkb21haW4gc29ja2V0IG9yIGEgVENQIHNvY2tldC5cbiAgICB0aGlzLl9zb2NrZXQgPSAodGhpcy5jb25maWcuc29ja2V0UGF0aClcbiAgICAgID8gTmV0LmNyZWF0ZUNvbm5lY3Rpb24odGhpcy5jb25maWcuc29ja2V0UGF0aClcbiAgICAgIDogTmV0LmNyZWF0ZUNvbm5lY3Rpb24odGhpcy5jb25maWcucG9ydCwgdGhpcy5jb25maWcuaG9zdCk7XG5cbiAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXM7XG4gICAgdGhpcy5fcHJvdG9jb2wub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgY29ubmVjdGlvbi5fc29ja2V0LndyaXRlKGRhdGEpO1xuICAgIH0pO1xuICAgIHRoaXMuX3NvY2tldC5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGNvbm5lY3Rpb24uX3Byb3RvY29sLndyaXRlKGRhdGEpO1xuICAgIH0pO1xuICAgIHRoaXMuX3Byb3RvY29sLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICBjb25uZWN0aW9uLl9zb2NrZXQuZW5kKClcbiAgICB9KTtcbiAgICB0aGlzLl9zb2NrZXQub24oJ2VuZCcsIGZ1bmN0aW9uKGVycikge1xuICAgICAgY29ubmVjdGlvbi5fcHJvdG9jb2wuZW5kKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9zb2NrZXQub24oJ2Vycm9yJywgdGhpcy5faGFuZGxlTmV0d29ya0Vycm9yLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3NvY2tldC5vbignY29ubmVjdCcsIHRoaXMuX2hhbmRsZVByb3RvY29sQ29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9wcm90b2NvbC5vbignaGFuZHNoYWtlJywgdGhpcy5faGFuZGxlUHJvdG9jb2xIYW5kc2hha2UuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcHJvdG9jb2wub24oJ3VuaGFuZGxlZEVycm9yJywgdGhpcy5faGFuZGxlUHJvdG9jb2xFcnJvci5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9wcm90b2NvbC5vbignZHJhaW4nLCB0aGlzLl9oYW5kbGVQcm90b2NvbERyYWluLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3Byb3RvY29sLm9uKCdlbmQnLCB0aGlzLl9oYW5kbGVQcm90b2NvbEVuZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9wcm90b2NvbC5vbignZW5xdWV1ZScsIHRoaXMuX2hhbmRsZVByb3RvY29sRW5xdWV1ZS5iaW5kKHRoaXMpKTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5jb25uZWN0VGltZW91dCkge1xuICAgICAgdmFyIGhhbmRsZUNvbm5lY3RUaW1lb3V0ID0gdGhpcy5faGFuZGxlQ29ubmVjdFRpbWVvdXQuYmluZCh0aGlzKTtcblxuICAgICAgdGhpcy5fc29ja2V0LnNldFRpbWVvdXQodGhpcy5jb25maWcuY29ubmVjdFRpbWVvdXQsIGhhbmRsZUNvbm5lY3RUaW1lb3V0KTtcbiAgICAgIHRoaXMuX3NvY2tldC5vbmNlKCdjb25uZWN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0VGltZW91dCgwLCBoYW5kbGVDb25uZWN0VGltZW91dCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9wcm90b2NvbC5oYW5kc2hha2Uob3B0aW9ucywgYmluZFRvQ3VycmVudERvbWFpbihjYWxsYmFjaykpO1xufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuY2hhbmdlVXNlciA9IGZ1bmN0aW9uIGNoYW5nZVVzZXIob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB0aGlzLl9pbXBseUNvbm5lY3QoKTtcblxuICB2YXIgY2hhcnNldE51bWJlciA9IChvcHRpb25zLmNoYXJzZXQpXG4gICAgPyBDb25uZWN0aW9uQ29uZmlnLmdldENoYXJzZXROdW1iZXIob3B0aW9ucy5jaGFyc2V0KVxuICAgIDogdGhpcy5jb25maWcuY2hhcnNldE51bWJlcjtcblxuICByZXR1cm4gdGhpcy5fcHJvdG9jb2wuY2hhbmdlVXNlcih7XG4gICAgdXNlciAgICAgICAgICA6IG9wdGlvbnMudXNlciB8fCB0aGlzLmNvbmZpZy51c2VyLFxuICAgIHBhc3N3b3JkICAgICAgOiBvcHRpb25zLnBhc3N3b3JkIHx8IHRoaXMuY29uZmlnLnBhc3N3b3JkLFxuICAgIGRhdGFiYXNlICAgICAgOiBvcHRpb25zLmRhdGFiYXNlIHx8IHRoaXMuY29uZmlnLmRhdGFiYXNlLFxuICAgIHRpbWVvdXQgICAgICAgOiBvcHRpb25zLnRpbWVvdXQsXG4gICAgY2hhcnNldE51bWJlciA6IGNoYXJzZXROdW1iZXIsXG4gICAgY3VycmVudENvbmZpZyA6IHRoaXMuY29uZmlnXG4gIH0sIGJpbmRUb0N1cnJlbnREb21haW4oY2FsbGJhY2spKTtcbn07XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmJlZ2luVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiBiZWdpblRyYW5zYWN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuc3FsID0gJ1NUQVJUIFRSQU5TQUNUSU9OJztcbiAgb3B0aW9ucy52YWx1ZXMgPSBudWxsO1xuICBcbiAgcmV0dXJuIHRoaXMucXVlcnkob3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gY29tbWl0KG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuc3FsID0gJ0NPTU1JVCc7XG4gIG9wdGlvbnMudmFsdWVzID0gbnVsbDtcbiAgXG4gIHJldHVybiB0aGlzLnF1ZXJ5KG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnJvbGxiYWNrID0gZnVuY3Rpb24gcm9sbGJhY2sob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5zcWwgPSAnUk9MTEJBQ0snO1xuICBvcHRpb25zLnZhbHVlcyA9IG51bGw7XG4gIFxuICByZXR1cm4gdGhpcy5xdWVyeShvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KHNxbCwgdmFsdWVzLCBjYikge1xuICB2YXIgcXVlcnkgPSBDb25uZWN0aW9uLmNyZWF0ZVF1ZXJ5KHNxbCwgdmFsdWVzLCBjYik7XG4gIHF1ZXJ5Ll9jb25uZWN0aW9uID0gdGhpcztcblxuICBpZiAoISh0eXBlb2Ygc3FsID09ICdvYmplY3QnICYmICd0eXBlQ2FzdCcgaW4gc3FsKSkge1xuICAgIHF1ZXJ5LnR5cGVDYXN0ID0gdGhpcy5jb25maWcudHlwZUNhc3Q7XG4gIH1cblxuICBpZiAocXVlcnkuc3FsKSB7XG4gICAgcXVlcnkuc3FsID0gdGhpcy5mb3JtYXQocXVlcnkuc3FsLCBxdWVyeS52YWx1ZXMpO1xuICB9XG5cbiAgdGhpcy5faW1wbHlDb25uZWN0KCk7XG5cbiAgcmV0dXJuIHRoaXMuX3Byb3RvY29sLl9lbnF1ZXVlKHF1ZXJ5KTtcbn07XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiBwaW5nKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdGhpcy5faW1wbHlDb25uZWN0KCk7XG4gIHRoaXMuX3Byb3RvY29sLnBpbmcob3B0aW9ucywgYmluZFRvQ3VycmVudERvbWFpbihjYWxsYmFjaykpO1xufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuc3RhdGlzdGljcyA9IGZ1bmN0aW9uIHN0YXRpc3RpY3Mob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB0aGlzLl9pbXBseUNvbm5lY3QoKTtcbiAgdGhpcy5fcHJvdG9jb2wuc3RhdHMob3B0aW9ucywgYmluZFRvQ3VycmVudERvbWFpbihjYWxsYmFjaykpO1xufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gZW5kKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBjYiAgID0gY2FsbGJhY2s7XG4gIHZhciBvcHRzID0gb3B0aW9ucztcblxuICBpZiAoIWNhbGxiYWNrICYmIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgICA9IG9wdGlvbnM7XG4gICAgb3B0cyA9IG51bGw7XG4gIH1cblxuICAvLyBjcmVhdGUgY3VzdG9tIG9wdGlvbnMgcmVmZXJlbmNlXG4gIG9wdHMgPSBPYmplY3QuY3JlYXRlKG9wdHMgfHwgbnVsbClcblxuICBpZiAob3B0cy50aW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBkZWZhdWx0IHRpbWVvdXQgb2YgMzAgc2Vjb25kc1xuICAgIG9wdHMudGltZW91dCA9IDMwMDAwO1xuICB9XG5cbiAgdGhpcy5faW1wbHlDb25uZWN0KCk7XG4gIHRoaXMuX3Byb3RvY29sLnF1aXQob3B0cywgYmluZFRvQ3VycmVudERvbWFpbihjYikpO1xufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnN0YXRlID0gXCJkaXNjb25uZWN0ZWRcIjtcbiAgdGhpcy5faW1wbHlDb25uZWN0KCk7XG4gIHRoaXMuX3NvY2tldC5kZXN0cm95KCk7XG4gIHRoaXMuX3Byb3RvY29sLmRlc3Ryb3koKTtcbn07XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3NvY2tldC5wYXVzZSgpO1xuICB0aGlzLl9wcm90b2NvbC5wYXVzZSgpO1xufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3NvY2tldC5yZXN1bWUoKTtcbiAgdGhpcy5fcHJvdG9jb2wucmVzdW1lKCk7XG59O1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5lc2NhcGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gU3FsU3RyaW5nLmVzY2FwZSh2YWx1ZSwgZmFsc2UsIHRoaXMuY29uZmlnLnRpbWV6b25lKTtcbn07XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmVzY2FwZUlkID0gZnVuY3Rpb24gZXNjYXBlSWQodmFsdWUpIHtcbiAgcmV0dXJuIFNxbFN0cmluZy5lc2NhcGVJZCh2YWx1ZSwgZmFsc2UpO1xufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oc3FsLCB2YWx1ZXMpIHtcbiAgaWYgKHR5cGVvZiB0aGlzLmNvbmZpZy5xdWVyeUZvcm1hdCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcucXVlcnlGb3JtYXQuY2FsbCh0aGlzLCBzcWwsIHZhbHVlcywgdGhpcy5jb25maWcudGltZXpvbmUpO1xuICB9XG4gIHJldHVybiBTcWxTdHJpbmcuZm9ybWF0KHNxbCwgdmFsdWVzLCB0aGlzLmNvbmZpZy5zdHJpbmdpZnlPYmplY3RzLCB0aGlzLmNvbmZpZy50aW1lem9uZSk7XG59O1xuXG5pZiAodGxzLlRMU1NvY2tldCkge1xuICAvLyAwLjExKyBlbnZpcm9ubWVudFxuICBDb25uZWN0aW9uLnByb3RvdHlwZS5fc3RhcnRUTFMgPSBmdW5jdGlvbiBfc3RhcnRUTFMob25TZWN1cmUpIHtcbiAgICB2YXIgc2VjdXJlQ29udGV4dCA9IHRscy5jcmVhdGVTZWN1cmVDb250ZXh0KHtcbiAgICAgIGNhICAgICAgICAgOiB0aGlzLmNvbmZpZy5zc2wuY2EsXG4gICAgICBjZXJ0ICAgICAgIDogdGhpcy5jb25maWcuc3NsLmNlcnQsXG4gICAgICBjaXBoZXJzICAgIDogdGhpcy5jb25maWcuc3NsLmNpcGhlcnMsXG4gICAgICBrZXkgICAgICAgIDogdGhpcy5jb25maWcuc3NsLmtleSxcbiAgICAgIHBhc3NwaHJhc2UgOiB0aGlzLmNvbmZpZy5zc2wucGFzc3BocmFzZVxuICAgIH0pO1xuXG4gICAgLy8gXCJ1bnBpcGVcIlxuICAgIHRoaXMuX3NvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKTtcbiAgICB0aGlzLl9wcm90b2NvbC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKTtcblxuICAgIC8vIHNvY2tldCA8LT4gZW5jcnlwdGVkXG4gICAgdmFyIHJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMuY29uZmlnLnNzbC5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gICAgdmFyIHNlY3VyZVNvY2tldCAgICAgICA9IG5ldyB0bHMuVExTU29ja2V0KHRoaXMuX3NvY2tldCwge1xuICAgICAgcmVqZWN0VW5hdXRob3JpemVkIDogcmVqZWN0VW5hdXRob3JpemVkLFxuICAgICAgcmVxdWVzdENlcnQgICAgICAgIDogdHJ1ZSxcbiAgICAgIHNlY3VyZUNvbnRleHQgICAgICA6IHNlY3VyZUNvbnRleHQsXG4gICAgICBpc1NlcnZlciAgICAgICAgICAgOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgLy8gY2xlYXJ0ZXh0IDwtPiBwcm90b2NvbFxuICAgIHNlY3VyZVNvY2tldC5waXBlKHRoaXMuX3Byb3RvY29sKTtcbiAgICB0aGlzLl9wcm90b2NvbC5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHNlY3VyZVNvY2tldC53cml0ZShkYXRhKTtcbiAgICB9KTtcblxuICAgIHNlY3VyZVNvY2tldC5vbignc2VjdXJlJywgZnVuY3Rpb24oKSB7XG4gICAgICBvblNlY3VyZShyZWplY3RVbmF1dGhvcml6ZWQgPyB0aGlzLnNzbC52ZXJpZnlFcnJvcigpIDogbnVsbCk7XG4gICAgfSk7XG5cbiAgICAvLyBzdGFydCBUTFMgY29tbXVuaWNhdGlvbnNcbiAgICBzZWN1cmVTb2NrZXQuX3N0YXJ0KCk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBwcmUtMC4xMSBlbnZpcm9ubWVudFxuICBDb25uZWN0aW9uLnByb3RvdHlwZS5fc3RhcnRUTFMgPSBmdW5jdGlvbiBfc3RhcnRUTFMob25TZWN1cmUpIHtcbiAgICAvLyBiZWZvcmUgVExTOlxuICAgIC8vICBfc29ja2V0IDwtPiBfcHJvdG9jb2xcbiAgICAvLyBhZnRlcjpcbiAgICAvLyAgX3NvY2tldCA8LT4gc2VjdXJlUGFpci5lbmNyeXB0ZWQgPC0+IHNlY3VyZVBhaXIuY2xlYXJ0ZXh0IDwtPiBfcHJvdG9jb2xcblxuICAgIHZhciBjcmVkZW50aWFscyA9IENyeXB0by5jcmVhdGVDcmVkZW50aWFscyh7XG4gICAgICBjYSAgICAgICAgIDogdGhpcy5jb25maWcuc3NsLmNhLFxuICAgICAgY2VydCAgICAgICA6IHRoaXMuY29uZmlnLnNzbC5jZXJ0LFxuICAgICAgY2lwaGVycyAgICA6IHRoaXMuY29uZmlnLnNzbC5jaXBoZXJzLFxuICAgICAga2V5ICAgICAgICA6IHRoaXMuY29uZmlnLnNzbC5rZXksXG4gICAgICBwYXNzcGhyYXNlIDogdGhpcy5jb25maWcuc3NsLnBhc3NwaHJhc2VcbiAgICB9KTtcblxuICAgIHZhciByZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLmNvbmZpZy5zc2wucmVqZWN0VW5hdXRob3JpemVkO1xuICAgIHZhciBzZWN1cmVQYWlyICAgICAgICAgPSB0bHMuY3JlYXRlU2VjdXJlUGFpcihjcmVkZW50aWFscywgZmFsc2UsIHRydWUsIHJlamVjdFVuYXV0aG9yaXplZCk7XG5cbiAgICAvLyBcInVucGlwZVwiXG4gICAgdGhpcy5fc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpO1xuICAgIHRoaXMuX3Byb3RvY29sLnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpO1xuXG4gICAgLy8gc29ja2V0IDwtPiBlbmNyeXB0ZWRcbiAgICBzZWN1cmVQYWlyLmVuY3J5cHRlZC5waXBlKHRoaXMuX3NvY2tldCk7XG4gICAgdGhpcy5fc29ja2V0Lm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgc2VjdXJlUGFpci5lbmNyeXB0ZWQud3JpdGUoZGF0YSk7XG4gICAgfSk7XG5cbiAgICAvLyBjbGVhcnRleHQgPC0+IHByb3RvY29sXG4gICAgc2VjdXJlUGFpci5jbGVhcnRleHQucGlwZSh0aGlzLl9wcm90b2NvbCk7XG4gICAgdGhpcy5fcHJvdG9jb2wub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICBzZWN1cmVQYWlyLmNsZWFydGV4dC53cml0ZShkYXRhKTtcbiAgICB9KTtcblxuICAgIHNlY3VyZVBhaXIub24oJ3NlY3VyZScsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFyZWplY3RVbmF1dGhvcml6ZWQpIHtcbiAgICAgICAgb25TZWN1cmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmVyaWZ5RXJyb3IgPSB0aGlzLnNzbC52ZXJpZnlFcnJvcigpO1xuICAgICAgdmFyIGVyciA9IHZlcmlmeUVycm9yO1xuXG4gICAgICAvLyBub2RlLmpzIDAuNiBzdXBwb3J0XG4gICAgICBpZiAodHlwZW9mIGVyciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXJyID0gbmV3IEVycm9yKHZlcmlmeUVycm9yKTtcbiAgICAgICAgZXJyLmNvZGUgPSB2ZXJpZnlFcnJvcjtcbiAgICAgIH1cblxuICAgICAgb25TZWN1cmUoZXJyKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuX2hhbmRsZUNvbm5lY3RUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9zb2NrZXQpIHtcbiAgICB0aGlzLl9zb2NrZXQuc2V0VGltZW91dCgwKTtcbiAgICB0aGlzLl9zb2NrZXQuZGVzdHJveSgpO1xuICB9XG5cbiAgdmFyIGVyciA9IG5ldyBFcnJvcignY29ubmVjdCBFVElNRURPVVQnKTtcbiAgZXJyLmVycm9ybm8gPSAnRVRJTUVET1VUJztcbiAgZXJyLmNvZGUgPSAnRVRJTUVET1VUJztcbiAgZXJyLnN5c2NhbGwgPSAnY29ubmVjdCc7XG5cbiAgdGhpcy5faGFuZGxlTmV0d29ya0Vycm9yKGVycik7XG59O1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5faGFuZGxlTmV0d29ya0Vycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gIHRoaXMuX3Byb3RvY29sLmhhbmRsZU5ldHdvcmtFcnJvcihlcnIpO1xufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuX2hhbmRsZVByb3RvY29sRXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgdGhpcy5zdGF0ZSA9IFwicHJvdG9jb2xfZXJyb3JcIjtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG59O1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5faGFuZGxlUHJvdG9jb2xEcmFpbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2RyYWluJyk7XG59O1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5faGFuZGxlUHJvdG9jb2xDb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc3RhdGUgPSBcImNvbm5lY3RlZFwiO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKTtcbn07XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9oYW5kbGVQcm90b2NvbEhhbmRzaGFrZSA9IGZ1bmN0aW9uIF9oYW5kbGVQcm90b2NvbEhhbmRzaGFrZShwYWNrZXQpIHtcbiAgdGhpcy5zdGF0ZSAgICA9IFwiYXV0aGVudGljYXRlZFwiO1xuICB0aGlzLnRocmVhZElkID0gcGFja2V0LnRocmVhZElkO1xufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuX2hhbmRsZVByb3RvY29sRW5kID0gZnVuY3Rpb24oZXJyKSB7XG4gIHRoaXMuc3RhdGUgPSBcImRpc2Nvbm5lY3RlZFwiO1xuICB0aGlzLmVtaXQoJ2VuZCcsIGVycik7XG59O1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5faGFuZGxlUHJvdG9jb2xFbnF1ZXVlID0gZnVuY3Rpb24gX2hhbmRsZVByb3RvY29sRW5xdWV1ZShzZXF1ZW5jZSkge1xuICB0aGlzLmVtaXQoJ2VucXVldWUnLCBzZXF1ZW5jZSk7XG59O1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5faW1wbHlDb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fY29ubmVjdENhbGxlZCkge1xuICAgIHRoaXMuY29ubmVjdCgpO1xuICB9XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbXlzcWwvbGliL0Nvbm5lY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJjcnlwdG9cIlxuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXRcIik7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcIm5ldFwiXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRsc1wiKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIGV4dGVybmFsIFwidGxzXCJcbiAqKiBtb2R1bGUgaWQgPSAyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHVybFBhcnNlICAgICAgICA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlO1xudmFyIENsaWVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvY29uc3RhbnRzL2NsaWVudCcpO1xudmFyIENoYXJzZXRzICAgICAgICA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvY29uc3RhbnRzL2NoYXJzZXRzJyk7XG52YXIgU1NMUHJvZmlsZXMgICAgID0gbnVsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uQ29uZmlnO1xuZnVuY3Rpb24gQ29ubmVjdGlvbkNvbmZpZyhvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0gQ29ubmVjdGlvbkNvbmZpZy5wYXJzZVVybChvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuaG9zdCAgICAgICAgICAgICAgID0gb3B0aW9ucy5ob3N0IHx8ICdsb2NhbGhvc3QnO1xuICB0aGlzLnBvcnQgICAgICAgICAgICAgICA9IG9wdGlvbnMucG9ydCB8fCAzMzA2O1xuICB0aGlzLmxvY2FsQWRkcmVzcyAgICAgICA9IG9wdGlvbnMubG9jYWxBZGRyZXNzO1xuICB0aGlzLnNvY2tldFBhdGggICAgICAgICA9IG9wdGlvbnMuc29ja2V0UGF0aDtcbiAgdGhpcy51c2VyICAgICAgICAgICAgICAgPSBvcHRpb25zLnVzZXIgfHwgdW5kZWZpbmVkO1xuICB0aGlzLnBhc3N3b3JkICAgICAgICAgICA9IG9wdGlvbnMucGFzc3dvcmQgfHwgdW5kZWZpbmVkO1xuICB0aGlzLmRhdGFiYXNlICAgICAgICAgICA9IG9wdGlvbnMuZGF0YWJhc2U7XG4gIHRoaXMuY29ubmVjdFRpbWVvdXQgICAgID0gKG9wdGlvbnMuY29ubmVjdFRpbWVvdXQgPT09IHVuZGVmaW5lZClcbiAgICA/ICgxMCAqIDEwMDApXG4gICAgOiBvcHRpb25zLmNvbm5lY3RUaW1lb3V0O1xuICB0aGlzLmluc2VjdXJlQXV0aCAgICAgICA9IG9wdGlvbnMuaW5zZWN1cmVBdXRoIHx8IGZhbHNlO1xuICB0aGlzLnN1cHBvcnRCaWdOdW1iZXJzICA9IG9wdGlvbnMuc3VwcG9ydEJpZ051bWJlcnMgfHwgZmFsc2U7XG4gIHRoaXMuYmlnTnVtYmVyU3RyaW5ncyAgID0gb3B0aW9ucy5iaWdOdW1iZXJTdHJpbmdzIHx8IGZhbHNlO1xuICB0aGlzLmRhdGVTdHJpbmdzICAgICAgICA9IG9wdGlvbnMuZGF0ZVN0cmluZ3MgfHwgZmFsc2U7XG4gIHRoaXMuZGVidWcgICAgICAgICAgICAgID0gb3B0aW9ucy5kZWJ1ZztcbiAgdGhpcy50cmFjZSAgICAgICAgICAgICAgPSBvcHRpb25zLnRyYWNlICE9PSBmYWxzZTtcbiAgdGhpcy5zdHJpbmdpZnlPYmplY3RzICAgPSBvcHRpb25zLnN0cmluZ2lmeU9iamVjdHMgfHwgZmFsc2U7XG4gIHRoaXMudGltZXpvbmUgICAgICAgICAgID0gb3B0aW9ucy50aW1lem9uZSB8fCAnbG9jYWwnO1xuICB0aGlzLmZsYWdzICAgICAgICAgICAgICA9IG9wdGlvbnMuZmxhZ3MgfHwgJyc7XG4gIHRoaXMucXVlcnlGb3JtYXQgICAgICAgID0gb3B0aW9ucy5xdWVyeUZvcm1hdDtcbiAgdGhpcy5wb29sICAgICAgICAgICAgICAgPSBvcHRpb25zLnBvb2wgfHwgdW5kZWZpbmVkO1xuICB0aGlzLnNzbCAgICAgICAgICAgICAgICA9ICh0eXBlb2Ygb3B0aW9ucy5zc2wgPT09ICdzdHJpbmcnKVxuICAgID8gQ29ubmVjdGlvbkNvbmZpZy5nZXRTU0xQcm9maWxlKG9wdGlvbnMuc3NsKVxuICAgIDogKG9wdGlvbnMuc3NsIHx8IGZhbHNlKTtcbiAgdGhpcy5tdWx0aXBsZVN0YXRlbWVudHMgPSBvcHRpb25zLm11bHRpcGxlU3RhdGVtZW50cyB8fCBmYWxzZTsgXG4gIHRoaXMudHlwZUNhc3QgICAgICAgICAgID0gKG9wdGlvbnMudHlwZUNhc3QgPT09IHVuZGVmaW5lZClcbiAgICA/IHRydWVcbiAgICA6IG9wdGlvbnMudHlwZUNhc3Q7XG5cbiAgaWYgKHRoaXMudGltZXpvbmVbMF0gPT0gXCIgXCIpIHtcbiAgICAvLyBcIitcIiBpcyBhIHVybCBlbmNvZGVkIGNoYXIgZm9yIHNwYWNlIHNvIGl0XG4gICAgLy8gZ2V0cyB0cmFuc2xhdGVkIHRvIHNwYWNlIHdoZW4gZ2l2aW5nIGFcbiAgICAvLyBjb25uZWN0aW9uIHN0cmluZy4uXG4gICAgdGhpcy50aW1lem9uZSA9IFwiK1wiICsgdGhpcy50aW1lem9uZS5zdWJzdHIoMSk7XG4gIH1cblxuICBpZiAodGhpcy5zc2wpIHtcbiAgICAvLyBEZWZhdWx0IHJlamVjdFVuYXV0aG9yaXplZCB0byB0cnVlXG4gICAgdGhpcy5zc2wucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5zc2wucmVqZWN0VW5hdXRob3JpemVkICE9PSBmYWxzZTtcbiAgfVxuXG4gIHRoaXMubWF4UGFja2V0U2l6ZSA9IDA7XG4gIHRoaXMuY2hhcnNldE51bWJlciA9IChvcHRpb25zLmNoYXJzZXQpXG4gICAgPyBDb25uZWN0aW9uQ29uZmlnLmdldENoYXJzZXROdW1iZXIob3B0aW9ucy5jaGFyc2V0KVxuICAgIDogb3B0aW9ucy5jaGFyc2V0TnVtYmVyfHxDaGFyc2V0cy5VVEY4X0dFTkVSQUxfQ0k7XG5cbiAgLy8gU2V0IHRoZSBjbGllbnQgZmxhZ3NcbiAgdmFyIGRlZmF1bHRGbGFncyA9IENvbm5lY3Rpb25Db25maWcuZ2V0RGVmYXVsdEZsYWdzKG9wdGlvbnMpO1xuICB0aGlzLmNsaWVudEZsYWdzID0gQ29ubmVjdGlvbkNvbmZpZy5tZXJnZUZsYWdzKGRlZmF1bHRGbGFncywgb3B0aW9ucy5mbGFncylcbn1cblxuQ29ubmVjdGlvbkNvbmZpZy5tZXJnZUZsYWdzID0gZnVuY3Rpb24gbWVyZ2VGbGFncyhkZWZhdWx0RmxhZ3MsIHVzZXJGbGFncykge1xuICB2YXIgYWxsRmxhZ3MgPSBDb25uZWN0aW9uQ29uZmlnLnBhcnNlRmxhZ0xpc3QoZGVmYXVsdEZsYWdzKTtcbiAgdmFyIG5ld0ZsYWdzID0gQ29ubmVjdGlvbkNvbmZpZy5wYXJzZUZsYWdMaXN0KHVzZXJGbGFncyk7XG5cbiAgLy8gTWVyZ2UgdGhlIG5ldyBmbGFnc1xuICBmb3IgKHZhciBmbGFnIGluIG5ld0ZsYWdzKSB7XG4gICAgaWYgKGFsbEZsYWdzW2ZsYWddICE9PSBmYWxzZSkge1xuICAgICAgYWxsRmxhZ3NbZmxhZ10gPSBuZXdGbGFnc1tmbGFnXTtcbiAgICB9XG4gIH1cblxuICAvLyBCdWlsZCBmbGFnc1xuICB2YXIgZmxhZ3MgPSAweDA7XG4gIGZvciAodmFyIGZsYWcgaW4gYWxsRmxhZ3MpIHtcbiAgICBpZiAoYWxsRmxhZ3NbZmxhZ10pIHtcbiAgICAgIC8vIFRPRE86IFRocm93IGhlcmUgb24gc29tZSBmdXR1cmUgcmVsZWFzZVxuICAgICAgZmxhZ3MgfD0gQ2xpZW50Q29uc3RhbnRzWydDTElFTlRfJyArIGZsYWddIHx8IDB4MDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmxhZ3M7XG59O1xuXG5Db25uZWN0aW9uQ29uZmlnLmdldENoYXJzZXROdW1iZXIgPSBmdW5jdGlvbiBnZXRDaGFyc2V0TnVtYmVyKGNoYXJzZXQpIHtcbiAgdmFyIG51bSA9IENoYXJzZXRzW2NoYXJzZXQudG9VcHBlckNhc2UoKV07XG5cbiAgaWYgKG51bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBjaGFyc2V0IFxcJycgKyBjaGFyc2V0ICsgJ1xcJycpO1xuICB9XG5cbiAgcmV0dXJuIG51bTtcbn07XG5cbkNvbm5lY3Rpb25Db25maWcuZ2V0RGVmYXVsdEZsYWdzID0gZnVuY3Rpb24gZ2V0RGVmYXVsdEZsYWdzKG9wdGlvbnMpIHtcbiAgdmFyIGRlZmF1bHRGbGFncyA9IFtcbiAgICAnLUNPTVBSRVNTJywgICAgICAgICAgLy8gQ29tcHJlc3Npb24gcHJvdG9jb2wgKk5PVCogc3VwcG9ydGVkXG4gICAgJy1DT05ORUNUX0FUVFJTJywgICAgIC8vIERvZXMgKk5PVCogc2VuZCBjb25uZWN0aW9uIGF0dHJpYnV0ZXMgaW4gUHJvdG9jb2w6OkhhbmRzaGFrZVJlc3BvbnNlNDFcbiAgICAnK0NPTk5FQ1RfV0lUSF9EQicsICAgLy8gT25lIGNhbiBzcGVjaWZ5IGRiIG9uIGNvbm5lY3QgaW4gSGFuZHNoYWtlIFJlc3BvbnNlIFBhY2tldFxuICAgICcrRk9VTkRfUk9XUycsICAgICAgICAvLyBTZW5kIGZvdW5kIHJvd3MgaW5zdGVhZCBvZiBhZmZlY3RlZCByb3dzXG4gICAgJytJR05PUkVfU0lHUElQRScsICAgIC8vIERvbid0IGlzc3VlIFNJR1BJUEUgaWYgbmV0d29yayBmYWlsdXJlc1xuICAgICcrSUdOT1JFX1NQQUNFJywgICAgICAvLyBMZXQgdGhlIHBhcnNlciBpZ25vcmUgc3BhY2VzIGJlZm9yZSAnKCdcbiAgICAnK0xPQ0FMX0ZJTEVTJywgICAgICAgLy8gQ2FuIHVzZSBMT0FEIERBVEEgTE9DQUxcbiAgICAnK0xPTkdfRkxBRycsICAgICAgICAgLy8gTG9uZ2VyIGZsYWdzIGluIFByb3RvY29sOjpDb2x1bW5EZWZpbml0aW9uMzIwXG4gICAgJytMT05HX1BBU1NXT1JEJywgICAgIC8vIFVzZSB0aGUgaW1wcm92ZWQgdmVyc2lvbiBvZiBPbGQgUGFzc3dvcmQgQXV0aGVudGljYXRpb25cbiAgICAnK01VTFRJX1JFU1VMVFMnLCAgICAgLy8gQ2FuIGhhbmRsZSBtdWx0aXBsZSByZXN1bHRzZXRzIGZvciBDT01fUVVFUllcbiAgICAnK09EQkMnLCAgICAgICAgICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBvZiBPREJDIGJlaGF2aW91clxuICAgICctUExVR0lOX0FVVEgnLCAgICAgICAvLyBEb2VzICpOT1QqIHN1cHBvcnQgYXV0aCBwbHVnaW5zXG4gICAgJytQUk9UT0NPTF80MScsICAgICAgIC8vIFVzZXMgdGhlIDQuMSBwcm90b2NvbFxuICAgICcrUFNfTVVMVElfUkVTVUxUUycsICAvLyBDYW4gaGFuZGxlIG11bHRpcGxlIHJlc3VsdHNldHMgZm9yIENPTV9TVE1UX0VYRUNVVEVcbiAgICAnK1JFU0VSVkVEJywgICAgICAgICAgLy8gVW51c2VkXG4gICAgJytTRUNVUkVfQ09OTkVDVElPTicsIC8vIFN1cHBvcnRzIEF1dGhlbnRpY2F0aW9uOjpOYXRpdmU0MVxuICAgICcrVFJBTlNBQ1RJT05TJyAgICAgICAvLyBFeHBlY3RzIHN0YXR1cyBmbGFnc1xuICBdO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMubXVsdGlwbGVTdGF0ZW1lbnRzKSB7XG4gICAgLy8gTWF5IHNlbmQgbXVsdGlwbGUgc3RhdGVtZW50cyBwZXIgQ09NX1FVRVJZIGFuZCBDT01fU1RNVF9QUkVQQVJFXG4gICAgZGVmYXVsdEZsYWdzLnB1c2goJytNVUxUSV9TVEFURU1FTlRTJyk7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdEZsYWdzO1xufTtcblxuQ29ubmVjdGlvbkNvbmZpZy5nZXRTU0xQcm9maWxlID0gZnVuY3Rpb24gZ2V0U1NMUHJvZmlsZShuYW1lKSB7XG4gIGlmICghU1NMUHJvZmlsZXMpIHtcbiAgICBTU0xQcm9maWxlcyA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvY29uc3RhbnRzL3NzbF9wcm9maWxlcycpO1xuICB9XG5cbiAgdmFyIHNzbCA9IFNTTFByb2ZpbGVzW25hbWVdO1xuXG4gIGlmIChzc2wgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gU1NMIHByb2ZpbGUgXFwnJyArIG5hbWUgKyAnXFwnJyk7XG4gIH1cblxuICByZXR1cm4gc3NsO1xufTtcblxuQ29ubmVjdGlvbkNvbmZpZy5wYXJzZUZsYWdMaXN0ID0gZnVuY3Rpb24gcGFyc2VGbGFnTGlzdChmbGFnTGlzdCkge1xuICB2YXIgYWxsRmxhZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGlmICghZmxhZ0xpc3QpIHtcbiAgICByZXR1cm4gYWxsRmxhZ3M7XG4gIH1cblxuICB2YXIgZmxhZ3MgPSAhQXJyYXkuaXNBcnJheShmbGFnTGlzdClcbiAgICA/IFN0cmluZyhmbGFnTGlzdCB8fCAnJykudG9VcHBlckNhc2UoKS5zcGxpdCgvXFxzKiwrXFxzKi8pXG4gICAgOiBmbGFnTGlzdDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZsYWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGZsYWcgICA9IGZsYWdzW2ldO1xuICAgIHZhciBvZmZzZXQgPSAxO1xuICAgIHZhciBzdGF0ZSAgPSBmbGFnWzBdO1xuXG4gICAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFRPRE86IHRocm93IGhlcmUgb24gc29tZSBmdXR1cmUgcmVsZWFzZVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlICE9PSAnLScgJiYgc3RhdGUgIT09ICcrJykge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIHN0YXRlICA9ICcrJztcbiAgICB9XG5cbiAgICBhbGxGbGFnc1tmbGFnLnN1YnN0cihvZmZzZXQpXSA9IHN0YXRlID09PSAnKyc7XG4gIH1cblxuICByZXR1cm4gYWxsRmxhZ3M7XG59O1xuXG5Db25uZWN0aW9uQ29uZmlnLnBhcnNlVXJsID0gZnVuY3Rpb24odXJsKSB7XG4gIHVybCA9IHVybFBhcnNlKHVybCwgdHJ1ZSk7XG5cbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgaG9zdCAgICAgOiB1cmwuaG9zdG5hbWUsXG4gICAgcG9ydCAgICAgOiB1cmwucG9ydCxcbiAgICBkYXRhYmFzZSA6IHVybC5wYXRobmFtZS5zdWJzdHIoMSksXG4gIH07XG5cbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgdmFyIGF1dGggPSB1cmwuYXV0aC5zcGxpdCgnOicpO1xuICAgIG9wdGlvbnMudXNlciAgICAgPSBhdXRoWzBdO1xuICAgIG9wdGlvbnMucGFzc3dvcmQgPSBhdXRoWzFdO1xuICB9XG5cbiAgaWYgKHVybC5xdWVyeSkge1xuICAgIGZvciAodmFyIGtleSBpbiB1cmwucXVlcnkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHVybC5xdWVyeVtrZXldO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUcnkgdG8gcGFyc2UgdGhpcyBhcyBhIEpTT04gZXhwcmVzc2lvbiBmaXJzdFxuICAgICAgICBvcHRpb25zW2tleV0gPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBPdGhlcndpc2UgYXNzdW1lIGl0IGlzIGEgcGxhaW4gc3RyaW5nXG4gICAgICAgIG9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvcHRpb25zO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL2xpYi9Db25uZWN0aW9uQ29uZmlnLmpzXG4gKiogbW9kdWxlIGlkID0gMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInVybFwiKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIGV4dGVybmFsIFwidXJsXCJcbiAqKiBtb2R1bGUgaWQgPSAyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gTWFudWFsbHkgZXh0cmFjdGVkIGZyb20gbXlzcWwtNS41LjIzL2luY2x1ZGUvbXlzcWxfY29tLmhcbmV4cG9ydHMuQ0xJRU5UX0xPTkdfUEFTU1dPUkQgICAgID0gMTsgLyogbmV3IG1vcmUgc2VjdXJlIHBhc3N3b3JkcyAqL1xuZXhwb3J0cy5DTElFTlRfRk9VTkRfUk9XUyAgICAgICAgPSAyOyAvKiBGb3VuZCBpbnN0ZWFkIG9mIGFmZmVjdGVkIHJvd3MgKi9cbmV4cG9ydHMuQ0xJRU5UX0xPTkdfRkxBRyAgICAgICAgID0gNDsgLyogR2V0IGFsbCBjb2x1bW4gZmxhZ3MgKi9cbmV4cG9ydHMuQ0xJRU5UX0NPTk5FQ1RfV0lUSF9EQiAgID0gODsgLyogT25lIGNhbiBzcGVjaWZ5IGRiIG9uIGNvbm5lY3QgKi9cbmV4cG9ydHMuQ0xJRU5UX05PX1NDSEVNQSAgICAgICAgID0gMTY7IC8qIERvbid0IGFsbG93IGRhdGFiYXNlLnRhYmxlLmNvbHVtbiAqL1xuZXhwb3J0cy5DTElFTlRfQ09NUFJFU1MgICAgICAgICAgPSAzMjsgLyogQ2FuIHVzZSBjb21wcmVzc2lvbiBwcm90b2NvbCAqL1xuZXhwb3J0cy5DTElFTlRfT0RCQyAgICAgICAgICAgICAgPSA2NDsgLyogT2RiYyBjbGllbnQgKi9cbmV4cG9ydHMuQ0xJRU5UX0xPQ0FMX0ZJTEVTICAgICAgID0gMTI4OyAvKiBDYW4gdXNlIExPQUQgREFUQSBMT0NBTCAqL1xuZXhwb3J0cy5DTElFTlRfSUdOT1JFX1NQQUNFICAgICAgPSAyNTY7IC8qIElnbm9yZSBzcGFjZXMgYmVmb3JlICcoJyAqL1xuZXhwb3J0cy5DTElFTlRfUFJPVE9DT0xfNDEgICAgICAgPSA1MTI7IC8qIE5ldyA0LjEgcHJvdG9jb2wgKi9cbmV4cG9ydHMuQ0xJRU5UX0lOVEVSQUNUSVZFICAgICAgID0gMTAyNDsgLyogVGhpcyBpcyBhbiBpbnRlcmFjdGl2ZSBjbGllbnQgKi9cbmV4cG9ydHMuQ0xJRU5UX1NTTCAgICAgICAgICAgICAgID0gMjA0ODsgLyogU3dpdGNoIHRvIFNTTCBhZnRlciBoYW5kc2hha2UgKi9cbmV4cG9ydHMuQ0xJRU5UX0lHTk9SRV9TSUdQSVBFICAgID0gNDA5NjsgICAgLyogSUdOT1JFIHNpZ3BpcGVzICovXG5leHBvcnRzLkNMSUVOVF9UUkFOU0FDVElPTlMgICAgICA9IDgxOTI7IC8qIENsaWVudCBrbm93cyBhYm91dCB0cmFuc2FjdGlvbnMgKi9cbmV4cG9ydHMuQ0xJRU5UX1JFU0VSVkVEICAgICAgICAgID0gMTYzODQ7ICAgLyogT2xkIGZsYWcgZm9yIDQuMSBwcm90b2NvbCAgKi9cbmV4cG9ydHMuQ0xJRU5UX1NFQ1VSRV9DT05ORUNUSU9OID0gMzI3Njg7ICAvKiBOZXcgNC4xIGF1dGhlbnRpY2F0aW9uICovXG5cbmV4cG9ydHMuQ0xJRU5UX01VTFRJX1NUQVRFTUVOVFMgPSA2NTUzNjsgLyogRW5hYmxlL2Rpc2FibGUgbXVsdGktc3RtdCBzdXBwb3J0ICovXG5leHBvcnRzLkNMSUVOVF9NVUxUSV9SRVNVTFRTICAgID0gMTMxMDcyOyAvKiBFbmFibGUvZGlzYWJsZSBtdWx0aS1yZXN1bHRzICovXG5leHBvcnRzLkNMSUVOVF9QU19NVUxUSV9SRVNVTFRTID0gMjYyMTQ0OyAvKiBNdWx0aS1yZXN1bHRzIGluIFBTLXByb3RvY29sICovXG5cbmV4cG9ydHMuQ0xJRU5UX1BMVUdJTl9BVVRIID0gNTI0Mjg4OyAvKiBDbGllbnQgc3VwcG9ydHMgcGx1Z2luIGF1dGhlbnRpY2F0aW9uICovXG5cbmV4cG9ydHMuQ0xJRU5UX1NTTF9WRVJJRllfU0VSVkVSX0NFUlQgPSAxMDczNzQxODI0O1xuZXhwb3J0cy5DTElFTlRfUkVNRU1CRVJfT1BUSU9OUyAgICAgICA9IDIxNDc0ODM2NDg7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9saWIvcHJvdG9jb2wvY29uc3RhbnRzL2NsaWVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLkJJRzVfQ0hJTkVTRV9DSSAgICAgICAgICAgICAgPSAxO1xuZXhwb3J0cy5MQVRJTjJfQ1pFQ0hfQ1MgICAgICAgICAgICAgID0gMjtcbmV4cG9ydHMuREVDOF9TV0VESVNIX0NJICAgICAgICAgICAgICA9IDM7XG5leHBvcnRzLkNQODUwX0dFTkVSQUxfQ0kgICAgICAgICAgICAgPSA0O1xuZXhwb3J0cy5MQVRJTjFfR0VSTUFOMV9DSSAgICAgICAgICAgID0gNTtcbmV4cG9ydHMuSFA4X0VOR0xJU0hfQ0kgICAgICAgICAgICAgICA9IDY7XG5leHBvcnRzLktPSThSX0dFTkVSQUxfQ0kgICAgICAgICAgICAgPSA3O1xuZXhwb3J0cy5MQVRJTjFfU1dFRElTSF9DSSAgICAgICAgICAgID0gODtcbmV4cG9ydHMuTEFUSU4yX0dFTkVSQUxfQ0kgICAgICAgICAgICA9IDk7XG5leHBvcnRzLlNXRTdfU1dFRElTSF9DSSAgICAgICAgICAgICAgPSAxMDtcbmV4cG9ydHMuQVNDSUlfR0VORVJBTF9DSSAgICAgICAgICAgICA9IDExO1xuZXhwb3J0cy5VSklTX0pBUEFORVNFX0NJICAgICAgICAgICAgID0gMTI7XG5leHBvcnRzLlNKSVNfSkFQQU5FU0VfQ0kgICAgICAgICAgICAgPSAxMztcbmV4cG9ydHMuQ1AxMjUxX0JVTEdBUklBTl9DSSAgICAgICAgICA9IDE0O1xuZXhwb3J0cy5MQVRJTjFfREFOSVNIX0NJICAgICAgICAgICAgID0gMTU7XG5leHBvcnRzLkhFQlJFV19HRU5FUkFMX0NJICAgICAgICAgICAgPSAxNjtcbmV4cG9ydHMuVElTNjIwX1RIQUlfQ0kgICAgICAgICAgICAgICA9IDE4O1xuZXhwb3J0cy5FVUNLUl9LT1JFQU5fQ0kgICAgICAgICAgICAgID0gMTk7XG5leHBvcnRzLkxBVElON19FU1RPTklBTl9DUyAgICAgICAgICAgPSAyMDtcbmV4cG9ydHMuTEFUSU4yX0hVTkdBUklBTl9DSSAgICAgICAgICA9IDIxO1xuZXhwb3J0cy5LT0k4VV9HRU5FUkFMX0NJICAgICAgICAgICAgID0gMjI7XG5leHBvcnRzLkNQMTI1MV9VS1JBSU5JQU5fQ0kgICAgICAgICAgPSAyMztcbmV4cG9ydHMuR0IyMzEyX0NISU5FU0VfQ0kgICAgICAgICAgICA9IDI0O1xuZXhwb3J0cy5HUkVFS19HRU5FUkFMX0NJICAgICAgICAgICAgID0gMjU7XG5leHBvcnRzLkNQMTI1MF9HRU5FUkFMX0NJICAgICAgICAgICAgPSAyNjtcbmV4cG9ydHMuTEFUSU4yX0NST0FUSUFOX0NJICAgICAgICAgICA9IDI3O1xuZXhwb3J0cy5HQktfQ0hJTkVTRV9DSSAgICAgICAgICAgICAgID0gMjg7XG5leHBvcnRzLkNQMTI1N19MSVRIVUFOSUFOX0NJICAgICAgICAgPSAyOTtcbmV4cG9ydHMuTEFUSU41X1RVUktJU0hfQ0kgICAgICAgICAgICA9IDMwO1xuZXhwb3J0cy5MQVRJTjFfR0VSTUFOMl9DSSAgICAgICAgICAgID0gMzE7XG5leHBvcnRzLkFSTVNDSUk4X0dFTkVSQUxfQ0kgICAgICAgICAgPSAzMjtcbmV4cG9ydHMuVVRGOF9HRU5FUkFMX0NJICAgICAgICAgICAgICA9IDMzO1xuZXhwb3J0cy5DUDEyNTBfQ1pFQ0hfQ1MgICAgICAgICAgICAgID0gMzQ7XG5leHBvcnRzLlVDUzJfR0VORVJBTF9DSSAgICAgICAgICAgICAgPSAzNTtcbmV4cG9ydHMuQ1A4NjZfR0VORVJBTF9DSSAgICAgICAgICAgICA9IDM2O1xuZXhwb3J0cy5LRVlCQ1MyX0dFTkVSQUxfQ0kgICAgICAgICAgID0gMzc7XG5leHBvcnRzLk1BQ0NFX0dFTkVSQUxfQ0kgICAgICAgICAgICAgPSAzODtcbmV4cG9ydHMuTUFDUk9NQU5fR0VORVJBTF9DSSAgICAgICAgICA9IDM5O1xuZXhwb3J0cy5DUDg1Ml9HRU5FUkFMX0NJICAgICAgICAgICAgID0gNDA7XG5leHBvcnRzLkxBVElON19HRU5FUkFMX0NJICAgICAgICAgICAgPSA0MTtcbmV4cG9ydHMuTEFUSU43X0dFTkVSQUxfQ1MgICAgICAgICAgICA9IDQyO1xuZXhwb3J0cy5NQUNDRV9CSU4gICAgICAgICAgICAgICAgICAgID0gNDM7XG5leHBvcnRzLkNQMTI1MF9DUk9BVElBTl9DSSAgICAgICAgICAgPSA0NDtcbmV4cG9ydHMuVVRGOE1CNF9HRU5FUkFMX0NJICAgICAgICAgICA9IDQ1O1xuZXhwb3J0cy5VVEY4TUI0X0JJTiAgICAgICAgICAgICAgICAgID0gNDY7XG5leHBvcnRzLkxBVElOMV9CSU4gICAgICAgICAgICAgICAgICAgPSA0NztcbmV4cG9ydHMuTEFUSU4xX0dFTkVSQUxfQ0kgICAgICAgICAgICA9IDQ4O1xuZXhwb3J0cy5MQVRJTjFfR0VORVJBTF9DUyAgICAgICAgICAgID0gNDk7XG5leHBvcnRzLkNQMTI1MV9CSU4gICAgICAgICAgICAgICAgICAgPSA1MDtcbmV4cG9ydHMuQ1AxMjUxX0dFTkVSQUxfQ0kgICAgICAgICAgICA9IDUxO1xuZXhwb3J0cy5DUDEyNTFfR0VORVJBTF9DUyAgICAgICAgICAgID0gNTI7XG5leHBvcnRzLk1BQ1JPTUFOX0JJTiAgICAgICAgICAgICAgICAgPSA1MztcbmV4cG9ydHMuVVRGMTZfR0VORVJBTF9DSSAgICAgICAgICAgICA9IDU0O1xuZXhwb3J0cy5VVEYxNl9CSU4gICAgICAgICAgICAgICAgICAgID0gNTU7XG5leHBvcnRzLlVURjE2TEVfR0VORVJBTF9DSSAgICAgICAgICAgPSA1NjtcbmV4cG9ydHMuQ1AxMjU2X0dFTkVSQUxfQ0kgICAgICAgICAgICA9IDU3O1xuZXhwb3J0cy5DUDEyNTdfQklOICAgICAgICAgICAgICAgICAgID0gNTg7XG5leHBvcnRzLkNQMTI1N19HRU5FUkFMX0NJICAgICAgICAgICAgPSA1OTtcbmV4cG9ydHMuVVRGMzJfR0VORVJBTF9DSSAgICAgICAgICAgICA9IDYwO1xuZXhwb3J0cy5VVEYzMl9CSU4gICAgICAgICAgICAgICAgICAgID0gNjE7XG5leHBvcnRzLlVURjE2TEVfQklOICAgICAgICAgICAgICAgICAgPSA2MjtcbmV4cG9ydHMuQklOQVJZICAgICAgICAgICAgICAgICAgICAgICA9IDYzO1xuZXhwb3J0cy5BUk1TQ0lJOF9CSU4gICAgICAgICAgICAgICAgID0gNjQ7XG5leHBvcnRzLkFTQ0lJX0JJTiAgICAgICAgICAgICAgICAgICAgPSA2NTtcbmV4cG9ydHMuQ1AxMjUwX0JJTiAgICAgICAgICAgICAgICAgICA9IDY2O1xuZXhwb3J0cy5DUDEyNTZfQklOICAgICAgICAgICAgICAgICAgID0gNjc7XG5leHBvcnRzLkNQODY2X0JJTiAgICAgICAgICAgICAgICAgICAgPSA2ODtcbmV4cG9ydHMuREVDOF9CSU4gICAgICAgICAgICAgICAgICAgICA9IDY5O1xuZXhwb3J0cy5HUkVFS19CSU4gICAgICAgICAgICAgICAgICAgID0gNzA7XG5leHBvcnRzLkhFQlJFV19CSU4gICAgICAgICAgICAgICAgICAgPSA3MTtcbmV4cG9ydHMuSFA4X0JJTiAgICAgICAgICAgICAgICAgICAgICA9IDcyO1xuZXhwb3J0cy5LRVlCQ1MyX0JJTiAgICAgICAgICAgICAgICAgID0gNzM7XG5leHBvcnRzLktPSThSX0JJTiAgICAgICAgICAgICAgICAgICAgPSA3NDtcbmV4cG9ydHMuS09JOFVfQklOICAgICAgICAgICAgICAgICAgICA9IDc1O1xuZXhwb3J0cy5MQVRJTjJfQklOICAgICAgICAgICAgICAgICAgID0gNzc7XG5leHBvcnRzLkxBVElONV9CSU4gICAgICAgICAgICAgICAgICAgPSA3ODtcbmV4cG9ydHMuTEFUSU43X0JJTiAgICAgICAgICAgICAgICAgICA9IDc5O1xuZXhwb3J0cy5DUDg1MF9CSU4gICAgICAgICAgICAgICAgICAgID0gODA7XG5leHBvcnRzLkNQODUyX0JJTiAgICAgICAgICAgICAgICAgICAgPSA4MTtcbmV4cG9ydHMuU1dFN19CSU4gICAgICAgICAgICAgICAgICAgICA9IDgyO1xuZXhwb3J0cy5VVEY4X0JJTiAgICAgICAgICAgICAgICAgICAgID0gODM7XG5leHBvcnRzLkJJRzVfQklOICAgICAgICAgICAgICAgICAgICAgPSA4NDtcbmV4cG9ydHMuRVVDS1JfQklOICAgICAgICAgICAgICAgICAgICA9IDg1O1xuZXhwb3J0cy5HQjIzMTJfQklOICAgICAgICAgICAgICAgICAgID0gODY7XG5leHBvcnRzLkdCS19CSU4gICAgICAgICAgICAgICAgICAgICAgPSA4NztcbmV4cG9ydHMuU0pJU19CSU4gICAgICAgICAgICAgICAgICAgICA9IDg4O1xuZXhwb3J0cy5USVM2MjBfQklOICAgICAgICAgICAgICAgICAgID0gODk7XG5leHBvcnRzLlVDUzJfQklOICAgICAgICAgICAgICAgICAgICAgPSA5MDtcbmV4cG9ydHMuVUpJU19CSU4gICAgICAgICAgICAgICAgICAgICA9IDkxO1xuZXhwb3J0cy5HRU9TVEQ4X0dFTkVSQUxfQ0kgICAgICAgICAgID0gOTI7XG5leHBvcnRzLkdFT1NURDhfQklOICAgICAgICAgICAgICAgICAgPSA5MztcbmV4cG9ydHMuTEFUSU4xX1NQQU5JU0hfQ0kgICAgICAgICAgICA9IDk0O1xuZXhwb3J0cy5DUDkzMl9KQVBBTkVTRV9DSSAgICAgICAgICAgID0gOTU7XG5leHBvcnRzLkNQOTMyX0JJTiAgICAgICAgICAgICAgICAgICAgPSA5NjtcbmV4cG9ydHMuRVVDSlBNU19KQVBBTkVTRV9DSSAgICAgICAgICA9IDk3O1xuZXhwb3J0cy5FVUNKUE1TX0JJTiAgICAgICAgICAgICAgICAgID0gOTg7XG5leHBvcnRzLkNQMTI1MF9QT0xJU0hfQ0kgICAgICAgICAgICAgPSA5OTtcbmV4cG9ydHMuVVRGMTZfVU5JQ09ERV9DSSAgICAgICAgICAgICA9IDEwMTtcbmV4cG9ydHMuVVRGMTZfSUNFTEFORElDX0NJICAgICAgICAgICA9IDEwMjtcbmV4cG9ydHMuVVRGMTZfTEFUVklBTl9DSSAgICAgICAgICAgICA9IDEwMztcbmV4cG9ydHMuVVRGMTZfUk9NQU5JQU5fQ0kgICAgICAgICAgICA9IDEwNDtcbmV4cG9ydHMuVVRGMTZfU0xPVkVOSUFOX0NJICAgICAgICAgICA9IDEwNTtcbmV4cG9ydHMuVVRGMTZfUE9MSVNIX0NJICAgICAgICAgICAgICA9IDEwNjtcbmV4cG9ydHMuVVRGMTZfRVNUT05JQU5fQ0kgICAgICAgICAgICA9IDEwNztcbmV4cG9ydHMuVVRGMTZfU1BBTklTSF9DSSAgICAgICAgICAgICA9IDEwODtcbmV4cG9ydHMuVVRGMTZfU1dFRElTSF9DSSAgICAgICAgICAgICA9IDEwOTtcbmV4cG9ydHMuVVRGMTZfVFVSS0lTSF9DSSAgICAgICAgICAgICA9IDExMDtcbmV4cG9ydHMuVVRGMTZfQ1pFQ0hfQ0kgICAgICAgICAgICAgICA9IDExMTtcbmV4cG9ydHMuVVRGMTZfREFOSVNIX0NJICAgICAgICAgICAgICA9IDExMjtcbmV4cG9ydHMuVVRGMTZfTElUSFVBTklBTl9DSSAgICAgICAgICA9IDExMztcbmV4cG9ydHMuVVRGMTZfU0xPVkFLX0NJICAgICAgICAgICAgICA9IDExNDtcbmV4cG9ydHMuVVRGMTZfU1BBTklTSDJfQ0kgICAgICAgICAgICA9IDExNTtcbmV4cG9ydHMuVVRGMTZfUk9NQU5fQ0kgICAgICAgICAgICAgICA9IDExNjtcbmV4cG9ydHMuVVRGMTZfUEVSU0lBTl9DSSAgICAgICAgICAgICA9IDExNztcbmV4cG9ydHMuVVRGMTZfRVNQRVJBTlRPX0NJICAgICAgICAgICA9IDExODtcbmV4cG9ydHMuVVRGMTZfSFVOR0FSSUFOX0NJICAgICAgICAgICA9IDExOTtcbmV4cG9ydHMuVVRGMTZfU0lOSEFMQV9DSSAgICAgICAgICAgICA9IDEyMDtcbmV4cG9ydHMuVVRGMTZfR0VSTUFOMl9DSSAgICAgICAgICAgICA9IDEyMTtcbmV4cG9ydHMuVVRGMTZfQ1JPQVRJQU5fTVlTUUw1NjFfQ0kgICA9IDEyMjtcbmV4cG9ydHMuVVRGMTZfVU5JQ09ERV81MjBfQ0kgICAgICAgICA9IDEyMztcbmV4cG9ydHMuVVRGMTZfVklFVE5BTUVTRV9DSSAgICAgICAgICA9IDEyNDtcbmV4cG9ydHMuVUNTMl9VTklDT0RFX0NJICAgICAgICAgICAgICA9IDEyODtcbmV4cG9ydHMuVUNTMl9JQ0VMQU5ESUNfQ0kgICAgICAgICAgICA9IDEyOTtcbmV4cG9ydHMuVUNTMl9MQVRWSUFOX0NJICAgICAgICAgICAgICA9IDEzMDtcbmV4cG9ydHMuVUNTMl9ST01BTklBTl9DSSAgICAgICAgICAgICA9IDEzMTtcbmV4cG9ydHMuVUNTMl9TTE9WRU5JQU5fQ0kgICAgICAgICAgICA9IDEzMjtcbmV4cG9ydHMuVUNTMl9QT0xJU0hfQ0kgICAgICAgICAgICAgICA9IDEzMztcbmV4cG9ydHMuVUNTMl9FU1RPTklBTl9DSSAgICAgICAgICAgICA9IDEzNDtcbmV4cG9ydHMuVUNTMl9TUEFOSVNIX0NJICAgICAgICAgICAgICA9IDEzNTtcbmV4cG9ydHMuVUNTMl9TV0VESVNIX0NJICAgICAgICAgICAgICA9IDEzNjtcbmV4cG9ydHMuVUNTMl9UVVJLSVNIX0NJICAgICAgICAgICAgICA9IDEzNztcbmV4cG9ydHMuVUNTMl9DWkVDSF9DSSAgICAgICAgICAgICAgICA9IDEzODtcbmV4cG9ydHMuVUNTMl9EQU5JU0hfQ0kgICAgICAgICAgICAgICA9IDEzOTtcbmV4cG9ydHMuVUNTMl9MSVRIVUFOSUFOX0NJICAgICAgICAgICA9IDE0MDtcbmV4cG9ydHMuVUNTMl9TTE9WQUtfQ0kgICAgICAgICAgICAgICA9IDE0MTtcbmV4cG9ydHMuVUNTMl9TUEFOSVNIMl9DSSAgICAgICAgICAgICA9IDE0MjtcbmV4cG9ydHMuVUNTMl9ST01BTl9DSSAgICAgICAgICAgICAgICA9IDE0MztcbmV4cG9ydHMuVUNTMl9QRVJTSUFOX0NJICAgICAgICAgICAgICA9IDE0NDtcbmV4cG9ydHMuVUNTMl9FU1BFUkFOVE9fQ0kgICAgICAgICAgICA9IDE0NTtcbmV4cG9ydHMuVUNTMl9IVU5HQVJJQU5fQ0kgICAgICAgICAgICA9IDE0NjtcbmV4cG9ydHMuVUNTMl9TSU5IQUxBX0NJICAgICAgICAgICAgICA9IDE0NztcbmV4cG9ydHMuVUNTMl9HRVJNQU4yX0NJICAgICAgICAgICAgICA9IDE0ODtcbmV4cG9ydHMuVUNTMl9DUk9BVElBTl9NWVNRTDU2MV9DSSAgICA9IDE0OTtcbmV4cG9ydHMuVUNTMl9VTklDT0RFXzUyMF9DSSAgICAgICAgICA9IDE1MDtcbmV4cG9ydHMuVUNTMl9WSUVUTkFNRVNFX0NJICAgICAgICAgICA9IDE1MTtcbmV4cG9ydHMuVUNTMl9HRU5FUkFMX01ZU1FMNTAwX0NJICAgICA9IDE1OTtcbmV4cG9ydHMuVVRGMzJfVU5JQ09ERV9DSSAgICAgICAgICAgICA9IDE2MDtcbmV4cG9ydHMuVVRGMzJfSUNFTEFORElDX0NJICAgICAgICAgICA9IDE2MTtcbmV4cG9ydHMuVVRGMzJfTEFUVklBTl9DSSAgICAgICAgICAgICA9IDE2MjtcbmV4cG9ydHMuVVRGMzJfUk9NQU5JQU5fQ0kgICAgICAgICAgICA9IDE2MztcbmV4cG9ydHMuVVRGMzJfU0xPVkVOSUFOX0NJICAgICAgICAgICA9IDE2NDtcbmV4cG9ydHMuVVRGMzJfUE9MSVNIX0NJICAgICAgICAgICAgICA9IDE2NTtcbmV4cG9ydHMuVVRGMzJfRVNUT05JQU5fQ0kgICAgICAgICAgICA9IDE2NjtcbmV4cG9ydHMuVVRGMzJfU1BBTklTSF9DSSAgICAgICAgICAgICA9IDE2NztcbmV4cG9ydHMuVVRGMzJfU1dFRElTSF9DSSAgICAgICAgICAgICA9IDE2ODtcbmV4cG9ydHMuVVRGMzJfVFVSS0lTSF9DSSAgICAgICAgICAgICA9IDE2OTtcbmV4cG9ydHMuVVRGMzJfQ1pFQ0hfQ0kgICAgICAgICAgICAgICA9IDE3MDtcbmV4cG9ydHMuVVRGMzJfREFOSVNIX0NJICAgICAgICAgICAgICA9IDE3MTtcbmV4cG9ydHMuVVRGMzJfTElUSFVBTklBTl9DSSAgICAgICAgICA9IDE3MjtcbmV4cG9ydHMuVVRGMzJfU0xPVkFLX0NJICAgICAgICAgICAgICA9IDE3MztcbmV4cG9ydHMuVVRGMzJfU1BBTklTSDJfQ0kgICAgICAgICAgICA9IDE3NDtcbmV4cG9ydHMuVVRGMzJfUk9NQU5fQ0kgICAgICAgICAgICAgICA9IDE3NTtcbmV4cG9ydHMuVVRGMzJfUEVSU0lBTl9DSSAgICAgICAgICAgICA9IDE3NjtcbmV4cG9ydHMuVVRGMzJfRVNQRVJBTlRPX0NJICAgICAgICAgICA9IDE3NztcbmV4cG9ydHMuVVRGMzJfSFVOR0FSSUFOX0NJICAgICAgICAgICA9IDE3ODtcbmV4cG9ydHMuVVRGMzJfU0lOSEFMQV9DSSAgICAgICAgICAgICA9IDE3OTtcbmV4cG9ydHMuVVRGMzJfR0VSTUFOMl9DSSAgICAgICAgICAgICA9IDE4MDtcbmV4cG9ydHMuVVRGMzJfQ1JPQVRJQU5fTVlTUUw1NjFfQ0kgICA9IDE4MTtcbmV4cG9ydHMuVVRGMzJfVU5JQ09ERV81MjBfQ0kgICAgICAgICA9IDE4MjtcbmV4cG9ydHMuVVRGMzJfVklFVE5BTUVTRV9DSSAgICAgICAgICA9IDE4MztcbmV4cG9ydHMuVVRGOF9VTklDT0RFX0NJICAgICAgICAgICAgICA9IDE5MjtcbmV4cG9ydHMuVVRGOF9JQ0VMQU5ESUNfQ0kgICAgICAgICAgICA9IDE5MztcbmV4cG9ydHMuVVRGOF9MQVRWSUFOX0NJICAgICAgICAgICAgICA9IDE5NDtcbmV4cG9ydHMuVVRGOF9ST01BTklBTl9DSSAgICAgICAgICAgICA9IDE5NTtcbmV4cG9ydHMuVVRGOF9TTE9WRU5JQU5fQ0kgICAgICAgICAgICA9IDE5NjtcbmV4cG9ydHMuVVRGOF9QT0xJU0hfQ0kgICAgICAgICAgICAgICA9IDE5NztcbmV4cG9ydHMuVVRGOF9FU1RPTklBTl9DSSAgICAgICAgICAgICA9IDE5ODtcbmV4cG9ydHMuVVRGOF9TUEFOSVNIX0NJICAgICAgICAgICAgICA9IDE5OTtcbmV4cG9ydHMuVVRGOF9TV0VESVNIX0NJICAgICAgICAgICAgICA9IDIwMDtcbmV4cG9ydHMuVVRGOF9UVVJLSVNIX0NJICAgICAgICAgICAgICA9IDIwMTtcbmV4cG9ydHMuVVRGOF9DWkVDSF9DSSAgICAgICAgICAgICAgICA9IDIwMjtcbmV4cG9ydHMuVVRGOF9EQU5JU0hfQ0kgICAgICAgICAgICAgICA9IDIwMztcbmV4cG9ydHMuVVRGOF9MSVRIVUFOSUFOX0NJICAgICAgICAgICA9IDIwNDtcbmV4cG9ydHMuVVRGOF9TTE9WQUtfQ0kgICAgICAgICAgICAgICA9IDIwNTtcbmV4cG9ydHMuVVRGOF9TUEFOSVNIMl9DSSAgICAgICAgICAgICA9IDIwNjtcbmV4cG9ydHMuVVRGOF9ST01BTl9DSSAgICAgICAgICAgICAgICA9IDIwNztcbmV4cG9ydHMuVVRGOF9QRVJTSUFOX0NJICAgICAgICAgICAgICA9IDIwODtcbmV4cG9ydHMuVVRGOF9FU1BFUkFOVE9fQ0kgICAgICAgICAgICA9IDIwOTtcbmV4cG9ydHMuVVRGOF9IVU5HQVJJQU5fQ0kgICAgICAgICAgICA9IDIxMDtcbmV4cG9ydHMuVVRGOF9TSU5IQUxBX0NJICAgICAgICAgICAgICA9IDIxMTtcbmV4cG9ydHMuVVRGOF9HRVJNQU4yX0NJICAgICAgICAgICAgICA9IDIxMjtcbmV4cG9ydHMuVVRGOF9DUk9BVElBTl9NWVNRTDU2MV9DSSAgICA9IDIxMztcbmV4cG9ydHMuVVRGOF9VTklDT0RFXzUyMF9DSSAgICAgICAgICA9IDIxNDtcbmV4cG9ydHMuVVRGOF9WSUVUTkFNRVNFX0NJICAgICAgICAgICA9IDIxNTtcbmV4cG9ydHMuVVRGOF9HRU5FUkFMX01ZU1FMNTAwX0NJICAgICA9IDIyMztcbmV4cG9ydHMuVVRGOE1CNF9VTklDT0RFX0NJICAgICAgICAgICA9IDIyNDtcbmV4cG9ydHMuVVRGOE1CNF9JQ0VMQU5ESUNfQ0kgICAgICAgICA9IDIyNTtcbmV4cG9ydHMuVVRGOE1CNF9MQVRWSUFOX0NJICAgICAgICAgICA9IDIyNjtcbmV4cG9ydHMuVVRGOE1CNF9ST01BTklBTl9DSSAgICAgICAgICA9IDIyNztcbmV4cG9ydHMuVVRGOE1CNF9TTE9WRU5JQU5fQ0kgICAgICAgICA9IDIyODtcbmV4cG9ydHMuVVRGOE1CNF9QT0xJU0hfQ0kgICAgICAgICAgICA9IDIyOTtcbmV4cG9ydHMuVVRGOE1CNF9FU1RPTklBTl9DSSAgICAgICAgICA9IDIzMDtcbmV4cG9ydHMuVVRGOE1CNF9TUEFOSVNIX0NJICAgICAgICAgICA9IDIzMTtcbmV4cG9ydHMuVVRGOE1CNF9TV0VESVNIX0NJICAgICAgICAgICA9IDIzMjtcbmV4cG9ydHMuVVRGOE1CNF9UVVJLSVNIX0NJICAgICAgICAgICA9IDIzMztcbmV4cG9ydHMuVVRGOE1CNF9DWkVDSF9DSSAgICAgICAgICAgICA9IDIzNDtcbmV4cG9ydHMuVVRGOE1CNF9EQU5JU0hfQ0kgICAgICAgICAgICA9IDIzNTtcbmV4cG9ydHMuVVRGOE1CNF9MSVRIVUFOSUFOX0NJICAgICAgICA9IDIzNjtcbmV4cG9ydHMuVVRGOE1CNF9TTE9WQUtfQ0kgICAgICAgICAgICA9IDIzNztcbmV4cG9ydHMuVVRGOE1CNF9TUEFOSVNIMl9DSSAgICAgICAgICA9IDIzODtcbmV4cG9ydHMuVVRGOE1CNF9ST01BTl9DSSAgICAgICAgICAgICA9IDIzOTtcbmV4cG9ydHMuVVRGOE1CNF9QRVJTSUFOX0NJICAgICAgICAgICA9IDI0MDtcbmV4cG9ydHMuVVRGOE1CNF9FU1BFUkFOVE9fQ0kgICAgICAgICA9IDI0MTtcbmV4cG9ydHMuVVRGOE1CNF9IVU5HQVJJQU5fQ0kgICAgICAgICA9IDI0MjtcbmV4cG9ydHMuVVRGOE1CNF9TSU5IQUxBX0NJICAgICAgICAgICA9IDI0MztcbmV4cG9ydHMuVVRGOE1CNF9HRVJNQU4yX0NJICAgICAgICAgICA9IDI0NDtcbmV4cG9ydHMuVVRGOE1CNF9DUk9BVElBTl9NWVNRTDU2MV9DSSA9IDI0NTtcbmV4cG9ydHMuVVRGOE1CNF9VTklDT0RFXzUyMF9DSSAgICAgICA9IDI0NjtcbmV4cG9ydHMuVVRGOE1CNF9WSUVUTkFNRVNFX0NJICAgICAgICA9IDI0NztcbmV4cG9ydHMuVVRGOF9HRU5FUkFMNTBfQ0kgICAgICAgICAgICA9IDI1MztcblxuLy8gc2hvcnQgYWxpYXNlc1xuZXhwb3J0cy5BUk1TQ0lJOCA9IGV4cG9ydHMuQVJNU0NJSThfR0VORVJBTF9DSTtcbmV4cG9ydHMuQVNDSUkgICAgPSBleHBvcnRzLkFTQ0lJX0dFTkVSQUxfQ0k7XG5leHBvcnRzLkJJRzUgICAgID0gZXhwb3J0cy5CSUc1X0NISU5FU0VfQ0k7XG5leHBvcnRzLkJJTkFSWSAgID0gZXhwb3J0cy5CSU5BUlk7XG5leHBvcnRzLkNQMTI1MCAgID0gZXhwb3J0cy5DUDEyNTBfR0VORVJBTF9DSTtcbmV4cG9ydHMuQ1AxMjUxICAgPSBleHBvcnRzLkNQMTI1MV9HRU5FUkFMX0NJO1xuZXhwb3J0cy5DUDEyNTYgICA9IGV4cG9ydHMuQ1AxMjU2X0dFTkVSQUxfQ0k7XG5leHBvcnRzLkNQMTI1NyAgID0gZXhwb3J0cy5DUDEyNTdfR0VORVJBTF9DSTtcbmV4cG9ydHMuQ1A4NjYgICAgPSBleHBvcnRzLkNQODY2X0dFTkVSQUxfQ0k7XG5leHBvcnRzLkNQODUwICAgID0gZXhwb3J0cy5DUDg1MF9HRU5FUkFMX0NJO1xuZXhwb3J0cy5DUDg1MiAgICA9IGV4cG9ydHMuQ1A4NTJfR0VORVJBTF9DSTtcbmV4cG9ydHMuQ1A5MzIgICAgPSBleHBvcnRzLkNQOTMyX0pBUEFORVNFX0NJO1xuZXhwb3J0cy5ERUM4ICAgICA9IGV4cG9ydHMuREVDOF9TV0VESVNIX0NJO1xuZXhwb3J0cy5FVUNKUE1TICA9IGV4cG9ydHMuRVVDSlBNU19KQVBBTkVTRV9DSTtcbmV4cG9ydHMuRVVDS1IgICAgPSBleHBvcnRzLkVVQ0tSX0tPUkVBTl9DSTtcbmV4cG9ydHMuR0IyMzEyICAgPSBleHBvcnRzLkdCMjMxMl9DSElORVNFX0NJO1xuZXhwb3J0cy5HQksgICAgICA9IGV4cG9ydHMuR0JLX0NISU5FU0VfQ0k7XG5leHBvcnRzLkdFT1NURDggID0gZXhwb3J0cy5HRU9TVEQ4X0dFTkVSQUxfQ0k7XG5leHBvcnRzLkdSRUVLICAgID0gZXhwb3J0cy5HUkVFS19HRU5FUkFMX0NJO1xuZXhwb3J0cy5IRUJSRVcgICA9IGV4cG9ydHMuSEVCUkVXX0dFTkVSQUxfQ0k7XG5leHBvcnRzLkhQOCAgICAgID0gZXhwb3J0cy5IUDhfRU5HTElTSF9DSTtcbmV4cG9ydHMuS0VZQkNTMiAgPSBleHBvcnRzLktFWUJDUzJfR0VORVJBTF9DSTtcbmV4cG9ydHMuS09JOFIgICAgPSBleHBvcnRzLktPSThSX0dFTkVSQUxfQ0k7XG5leHBvcnRzLktPSThVICAgID0gZXhwb3J0cy5LT0k4VV9HRU5FUkFMX0NJO1xuZXhwb3J0cy5MQVRJTjEgICA9IGV4cG9ydHMuTEFUSU4xX1NXRURJU0hfQ0k7XG5leHBvcnRzLkxBVElOMiAgID0gZXhwb3J0cy5MQVRJTjJfR0VORVJBTF9DSTtcbmV4cG9ydHMuTEFUSU41ICAgPSBleHBvcnRzLkxBVElONV9UVVJLSVNIX0NJO1xuZXhwb3J0cy5MQVRJTjcgICA9IGV4cG9ydHMuTEFUSU43X0dFTkVSQUxfQ0k7XG5leHBvcnRzLk1BQ0NFICAgID0gZXhwb3J0cy5NQUNDRV9HRU5FUkFMX0NJO1xuZXhwb3J0cy5NQUNST01BTiA9IGV4cG9ydHMuTUFDUk9NQU5fR0VORVJBTF9DSTtcbmV4cG9ydHMuU0pJUyAgICAgPSBleHBvcnRzLlNKSVNfSkFQQU5FU0VfQ0k7XG5leHBvcnRzLlNXRTcgICAgID0gZXhwb3J0cy5TV0U3X1NXRURJU0hfQ0k7XG5leHBvcnRzLlRJUzYyMCAgID0gZXhwb3J0cy5USVM2MjBfVEhBSV9DSTtcbmV4cG9ydHMuVUNTMiAgICAgPSBleHBvcnRzLlVDUzJfR0VORVJBTF9DSTtcbmV4cG9ydHMuVUpJUyAgICAgPSBleHBvcnRzLlVKSVNfSkFQQU5FU0VfQ0k7XG5leHBvcnRzLlVURjE2ICAgID0gZXhwb3J0cy5VVEYxNl9HRU5FUkFMX0NJO1xuZXhwb3J0cy5VVEYxNkxFICA9IGV4cG9ydHMuVVRGMTZMRV9HRU5FUkFMX0NJO1xuZXhwb3J0cy5VVEY4ICAgICA9IGV4cG9ydHMuVVRGOF9HRU5FUkFMX0NJO1xuZXhwb3J0cy5VVEY4TUI0ICA9IGV4cG9ydHMuVVRGOE1CNF9HRU5FUkFMX0NJO1xuZXhwb3J0cy5VVEYzMiAgICA9IGV4cG9ydHMuVVRGMzJfR0VORVJBTF9DSTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL2xpYi9wcm90b2NvbC9jb25zdGFudHMvY2hhcnNldHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQ2VydGlmaWNhdGVzIGZvciBBbWF6b24gUkRTXG5leHBvcnRzWydBbWF6b24gUkRTJ10gPSB7XG4gIGNhOiBbXG4gICAgLyoqXG4gICAgICogQW1hem9uIFJEUyBnbG9iYWwgY2VydGlmaWNhdGUgMjAxMCB0byAyMDE1XG4gICAgICpcbiAgICAgKiAgIENOID0gYXdzLmFtYXpvbi5jb20vcmRzL1xuICAgICAqICAgT1UgPSBSRFNcbiAgICAgKiAgIE8gPSBBbWF6b24uY29tXG4gICAgICogICBMID0gU2VhdHRsZVxuICAgICAqICAgU1QgPSBXYXNoaW5ndG9uXG4gICAgICogICBDID0gVVNcbiAgICAgKiAgIFAgPSAyMDEwLTA0LTA1VDIyOjQ0OjMxWi8yMDE1LTA0LTA0VDIyOjQxOjMxWlxuICAgICAqICAgRiA9IDdGOjA5OjhEOkE1OjdEOkJCOkE2OkVGOjdDOjcwOkQ4OkNBOjRFOjQ5OjExOjU1OjdFOjg5OkE3OkQzXG4gICAgICovXG4gICAgJy0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLVxcbidcbiAgICArICdNSUlEUXpDQ0FxeWdBd0lCQWdJSkFPZDF0bGZpR29Fb01BMEdDU3FHU0liM0RRRUJCUVVBTUhVeEN6QUpCZ05WXFxuJ1xuICAgICsgJ0JBWVRBbFZUTVJNd0VRWURWUVFJRXdwWFlYTm9hVzVuZEc5dU1SQXdEZ1lEVlFRSEV3ZFRaV0YwZEd4bE1STXdcXG4nXG4gICAgKyAnRVFZRFZRUUtFd3BCYldGNmIyNHVZMjl0TVF3d0NnWURWUVFMRXdOU1JGTXhIREFhQmdOVkJBTVRFMkYzY3k1aFxcbidcbiAgICArICdiV0Y2YjI0dVkyOXRMM0prY3k4d0hoY05NVEF3TkRBMU1qSTBORE14V2hjTk1UVXdOREEwTWpJME5ETXhXakIxXFxuJ1xuICAgICsgJ01Rc3dDUVlEVlFRR0V3SlZVekVUTUJFR0ExVUVDQk1LVjJGemFHbHVaM1J2YmpFUU1BNEdBMVVFQnhNSFUyVmhcXG4nXG4gICAgKyAnZEhSc1pURVRNQkVHQTFVRUNoTUtRVzFoZW05dUxtTnZiVEVNTUFvR0ExVUVDeE1EVWtSVE1Sd3dHZ1lEVlFRRFxcbidcbiAgICArICdFeE5oZDNNdVlXMWhlbTl1TG1OdmJTOXlaSE12TUlHZk1BMEdDU3FHU0liM0RRRUJBUVVBQTRHTkFEQ0JpUUtCXFxuJ1xuICAgICsgJ2dRREtoWEdVN3RpenhVUjVXYUZvTVRGY3hOeGEwNVBFalphSU9FTjVjdGtXcnFZU1JvdjAvbk9Nb1pqcWs4YkNcXG4nXG4gICAgKyAnbWVkOXZQRm9RR0QwT1Rha1BzMGpWZTN3d21SNzM1aHlWd21LSVBQc0dsYUJZajFPNmxsSXBaZVFWeXVwTng1NlxcbidcbiAgICArICdVenF0aUxhRHpoMUtjbWZxUDNxUDJkSW56QmZKUUtqaVJ1ZG8xRlducFB0MzNRSURBUUFCbzRIYU1JSFhNQjBHXFxuJ1xuICAgICsgJ0ExVWREZ1FXQkJUL0gzeCtjcVNrUi9lUFNJaW5QdGM0eVdLZTNEQ0Jwd1lEVlIwakJJR2ZNSUdjZ0JUL0gzeCtcXG4nXG4gICAgKyAnY3FTa1IvZVBTSWluUHRjNHlXS2UzS0Y1cEhjd2RURUxNQWtHQTFVRUJoTUNWVk14RXpBUkJnTlZCQWdUQ2xkaFxcbidcbiAgICArICdjMmhwYm1kMGIyNHhFREFPQmdOVkJBY1RCMU5sWVhSMGJHVXhFekFSQmdOVkJBb1RDa0Z0WVhwdmJpNWpiMjB4XFxuJ1xuICAgICsgJ0REQUtCZ05WQkFzVEExSkVVekVjTUJvR0ExVUVBeE1UWVhkekxtRnRZWHB2Ymk1amIyMHZjbVJ6TDRJSkFPZDFcXG4nXG4gICAgKyAndGxmaUdvRW9NQXdHQTFVZEV3UUZNQU1CQWY4d0RRWUpLb1pJaHZjTkFRRUZCUUFEZ1lFQXZndVp5L0JEVDY2eFxcbidcbiAgICArICdHZmduSmx5UXduRlNlVkxRbTl1L0ZJdno0aHVHamJxOWRxbkQ2aC9HbTU2UVBGZHlNRXlEaVpXYXFZNlYwOGxZXFxuJ1xuICAgICsgJ0xUQk5iNGtjSWM5LzZwYzAvb2pLY2lQNVFKUm02T2laNHZnRzA1bkY0ZllqaFU3V0NsVXg3Y3hxMWZLak5jMkpcXG4nXG4gICAgKyAnVUNtbVlxZ2lWa0FHV1JFVFZvK2J5T1NEWjRzd2IxMD1cXG4nXG4gICAgKyAnLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLVxcbicsXG5cbiAgICAvKipcbiAgICAgKiBBbWF6b24gUkRTIGdsb2JhbCByb290IENBIDIwMTUgdG8gMjAyMFxuICAgICAqXG4gICAgICogICBDTiA9IEFtYXpvbiBSRFMgUm9vdCBDQVxuICAgICAqICAgT1UgPSBBbWF6b24gUkRTXG4gICAgICogICBPID0gQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLlxuICAgICAqICAgTCA9IFNlYXR0bGVcbiAgICAgKiAgIFNUID0gV2FzaGluZ3RvblxuICAgICAqICAgQyA9IFVTXG4gICAgICogICBQID0gMjAxNS0wMi0wNVQwOToxMTozMVovMjAyMC0wMy0wNVQwOToxMTozMVpcbiAgICAgKiAgIEYgPSBFODoxMTo4ODo1NjpFNzpBNzpDRTozRTo1RTpEQzo5QTozMToyNToxQjo5MzpBQzpEQzo0MzpDRTpCMFxuICAgICAqL1xuICAgICctLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS1cXG4nXG4gICAgKyAnTUlJRDlEQ0NBdHlnQXdJQkFnSUJRakFOQmdrcWhraUc5dzBCQVFVRkFEQ0JpakVMTUFrR0ExVUVCaE1DVlZNeFxcbidcbiAgICArICdFekFSQmdOVkJBZ01DbGRoYzJocGJtZDBiMjR4RURBT0JnTlZCQWNNQjFObFlYUjBiR1V4SWpBZ0JnTlZCQW9NXFxuJ1xuICAgICsgJ0dVRnRZWHB2YmlCWFpXSWdVMlZ5ZG1salpYTXNJRWx1WXk0eEV6QVJCZ05WQkFzTUNrRnRZWHB2YmlCU1JGTXhcXG4nXG4gICAgKyAnR3pBWkJnTlZCQU1NRWtGdFlYcHZiaUJTUkZNZ1VtOXZkQ0JEUVRBZUZ3MHhOVEF5TURVd09URXhNekZhRncweVxcbidcbiAgICArICdNREF6TURVd09URXhNekZhTUlHS01Rc3dDUVlEVlFRR0V3SlZVekVUTUJFR0ExVUVDQXdLVjJGemFHbHVaM1J2XFxuJ1xuICAgICsgJ2JqRVFNQTRHQTFVRUJ3d0hVMlZoZEhSc1pURWlNQ0FHQTFVRUNnd1pRVzFoZW05dUlGZGxZaUJUWlhKMmFXTmxcXG4nXG4gICAgKyAnY3l3Z1NXNWpMakVUTUJFR0ExVUVDd3dLUVcxaGVtOXVJRkpFVXpFYk1Ca0dBMVVFQXd3U1FXMWhlbTl1SUZKRVxcbidcbiAgICArICdVeUJTYjI5MElFTkJNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQXVEOG5yWjhWXFxuJ1xuICAgICsgJ3UrVkE4eVZsVWlwQ1pJS1BURGNPSUxZcFVlOFRjdDBZZVFRcjB1eWwwMThTdGRCc2EzQ2pCZ3Z3cERScTFIZ0ZcXG4nXG4gICAgKyAnSmkyTjMrMzkrc2hDTnNwUWVFNmFZVStCSFhoS2hJSVN0dDNyN2dsLzROcVlpRERNV0tIeEhxMG5zR0RGZkFyZlxcbidcbiAgICArICdBT2NqWmRKYWdPTXFiM2ZGNDZmbGM4azJFN1RIVG05U3o0TDdSWTFXZEFCTXV1cnBJQ0xGRTNvSGNHZGFwT2I5XFxuJ1xuICAgICsgJ1Q1M3BRUit4cEhXOWF0a2NmM3BmN2diTzBybEtWU0lvVWVuQmxaaXBVbHAxVlpsL09EL0UrVHRSaERETmRJMkpcXG4nXG4gICAgKyAnUC9EU01NM2FFc3E2WlFrZmJ6L0lsbWwrTHgzdEpZWFVEbXArWmp6TVBMay8rM2JlVDhFaHJ3dGNHM1ZQcHZ3cFxcbidcbiAgICArICdCSU9xc3FWVlR2dy9Dd0lEQVFBQm8yTXdZVEFPQmdOVkhROEJBZjhFQkFNQ0FRWXdEd1lEVlIwVEFRSC9CQVV3XFxuJ1xuICAgICsgJ0F3RUIvekFkQmdOVkhRNEVGZ1FVVGdMdXJENzJGY2hNN1N6MUJjR1BuSVFJU1lNd0h3WURWUjBqQkJnd0ZvQVVcXG4nXG4gICAgKyAnVGdMdXJENzJGY2hNN1N6MUJjR1BuSVFJU1lNd0RRWUpLb1pJaHZjTkFRRUZCUUFEZ2dFQkFIWmNnSWlvOHBBbVxcbidcbiAgICArICdNakhENWNsNndLalh4U2NYS3RYeWdXSDJCb0RNWUJKRjl5ZnlLTzJqRUZ4WUtiSGVQcG5YQjFSMDR6SlNXQXc1XFxuJ1xuICAgICsgJzJFVXVESTFwU0JoOUJBODIvNVBrdU5sTmVTVEIzZFhERDJQRVBkelZXYlNLdlVCOFpkb29WKzJ2bmdMMFptNHJcXG4nXG4gICAgKyAnNDdRUHlkMTh5UEhyUklidEJ0SFIvNkN3S2V2TFozOTR6Z0V4cWhuZWtZS0lxcUVYNDF4c1VWMEdtNng0dnBqZlxcbidcbiAgICArICcydTZPLytZRTJVK3F5eXhIRTVXZDVvcWRlMG9vOVVVcEZFVEpQVmI2UTJjRWVRaWI4UEJBeWkwaTZLbkYra0lWXFxuJ1xuICAgICsgJ0E5ZFk3SUhTdWJ0Q0svaTh3eE1WcWZkNUd0YkE4bW1wZUpGd25Edm05ckJFc0h5YmwwOHFsYXg5c3lFd3NVWXJcXG4nXG4gICAgKyAnLzQwTmF3WmZUVVU9XFxuJ1xuICAgICsgJy0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS1cXG4nLFxuXG4gICAgLyoqXG4gICAgICogQW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMSBjZXJ0aWZpY2F0ZSBDQSAyMDE1IHRvIDIwMjBcbiAgICAgKlxuICAgICAqICAgQ04gPSBBbWF6b24gUkRTIGFwLW5vcnRoZWFzdC0xIENBXG4gICAgICogICBPVSA9IEFtYXpvbiBSRFNcbiAgICAgKiAgIE8gPSBBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuXG4gICAgICogICBMID0gU2VhdHRsZVxuICAgICAqICAgU1QgPSBXYXNoaW5ndG9uXG4gICAgICogICBDID0gVVNcbiAgICAgKiAgIFAgPSAyMDE1LTAyLTA1VDIyOjAzOjA2Wi8yMDIwLTAzLTA1VDIyOjAzOjA2WlxuICAgICAqICAgRiA9IDRCOjJEOjhBOkUwOkMxOkEzOkE5OkFGOkE3OkJCOjY1OjBDOjVBOjE2OjhBOjM5OjNDOjAzOkYyOkM1XG4gICAgICovXG4gICAgJy0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLVxcbidcbiAgICArICdNSUlFQVRDQ0F1bWdBd0lCQWdJQlJEQU5CZ2txaGtpRzl3MEJBUVVGQURDQmlqRUxNQWtHQTFVRUJoTUNWVk14XFxuJ1xuICAgICsgJ0V6QVJCZ05WQkFnTUNsZGhjMmhwYm1kMGIyNHhFREFPQmdOVkJBY01CMU5sWVhSMGJHVXhJakFnQmdOVkJBb01cXG4nXG4gICAgKyAnR1VGdFlYcHZiaUJYWldJZ1UyVnlkbWxqWlhNc0lFbHVZeTR4RXpBUkJnTlZCQXNNQ2tGdFlYcHZiaUJTUkZNeFxcbidcbiAgICArICdHekFaQmdOVkJBTU1Fa0Z0WVhwdmJpQlNSRk1nVW05dmRDQkRRVEFlRncweE5UQXlNRFV5TWpBek1EWmFGdzB5XFxuJ1xuICAgICsgJ01EQXpNRFV5TWpBek1EWmFNSUdVTVFzd0NRWURWUVFHRXdKVlV6RVRNQkVHQTFVRUNBd0tWMkZ6YUdsdVozUnZcXG4nXG4gICAgKyAnYmpFUU1BNEdBMVVFQnd3SFUyVmhkSFJzWlRFaU1DQUdBMVVFQ2d3WlFXMWhlbTl1SUZkbFlpQlRaWEoyYVdObFxcbidcbiAgICArICdjeXdnU1c1akxqRVRNQkVHQTFVRUN3d0tRVzFoZW05dUlGSkVVekVsTUNNR0ExVUVBd3djUVcxaGVtOXVJRkpFXFxuJ1xuICAgICsgJ1V5QmhjQzF1YjNKMGFHVmhjM1F0TVNCRFFUQ0NBU0l3RFFZSktvWklodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NcXG4nXG4gICAgKyAnZ2dFQkFNbU0yQjRQZlRYQ1pqYlpNV2lEUHl4dmsvZWVOd0lSSkFoZnplc2lHVWlMb3pYNkNSeTNyd0MxWk9QVlxcbidcbiAgICArICdBY1FmMExCK084d1k4OEMvY1YrZDRRMm5CRG1uaytWeDdvMk15TWgzNDNyNXJSM05hKzRpemQ4OXRrUVZ0MFdXXFxuJ1xuICAgICsgJ3ZPMjFLUkg1aThFdUJqaW5ib093QXd1NklKK0h5aVFpTTBWamdqcm1Fci9ZekZQTDhNZ0hEL1lVSGVocWpBQ25cXG4nXG4gICAgKyAnQzArQjcvZ3U3VzRxSnpCTDJET2Y3dWIycXN6R3R3UEUrcVF6a0NSRHdFMUE0QUptVkUrKy9GTEgyWng3OEVnZ1xcbidcbiAgICArICdmVjFzVXhQdFlnakdINzZWeXlPNkdOS002ckFVTUQvcTVtblBBU1FWSVhnS2J1cHI2MThibkgrU1dIRmpCcVpxXFxuJ1xuICAgICsgJ0h2REdQTXRpaVdJSTQxRW1HVXlweXQ1QWJ5c0NBd0VBQWFObU1HUXdEZ1lEVlIwUEFRSC9CQVFEQWdFR01CSUdcXG4nXG4gICAgKyAnQTFVZEV3RUIvd1FJTUFZQkFmOENBUUF3SFFZRFZSME9CQllFRklpS00wUTZuMUs0RW1MeHMzWlh4SU5id0V3UlxcbidcbiAgICArICdNQjhHQTFVZEl3UVlNQmFBRkU0Qzdxdys5aFhJVE8wczlRWEJqNXlFQ0VtRE1BMEdDU3FHU0liM0RRRUJCUVVBXFxuJ1xuICAgICsgJ0E0SUJBUUJlekdiRTlSdy9rMmUyNWlHamo1bjhyK00zZGx5ZThPUmZDRS9kaWpIdHhxQUthc1hIZ0tYOEk5VHdcXG4nXG4gICAgKyAnSmtCaUdXaXV6cW43Z081TUowbk1Ncm8xK2dxMjlxalpuWVgxcERIUGdzUmpVWDhSK2p1UmhnSjNKU0hpalJiZlxcbidcbiAgICArICc0cU5Kcm53Z2E3cGo5NE1oY0xxOXUwZjZkeEg2ZFhieU12MjFUNFRaTVRtY0ZkdWYxS2dhaVZ4MVBFeUpqQzZyXFxuJ1xuICAgICsgJ00rUnUrQTBlTStqSjd1Q2pVb1pLY3BYOHhrajRubVNuejlOTVBvZzN3ZE9TQjljQVc3WEljNW1IYTY1NndyN0lcXG4nXG4gICAgKyAnV0p4VmNZTkhUWElqQ2NuZzJ6TUtkMWFDY2wyS1NGZnk1NnNSZlQ3SjVXcDY5UVNyK2pxOEtNNTVndzh1cUF3aVxcbidcbiAgICArICdWUHJYbjI4OTlUMXJjVHRGWUZQMTZXWGpHdWMwXFxuJ1xuICAgICsgJy0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS1cXG4nLFxuXG4gICAgLyoqXG4gICAgICogQW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMSBjZXJ0aWZpY2F0ZSBDQSAyMDE1IHRvIDIwMjBcbiAgICAgKlxuICAgICAqICAgQ04gPSBBbWF6b24gUkRTIGFwLXNvdXRoZWFzdC0xIENBXG4gICAgICogICBPVSA9IEFtYXpvbiBSRFNcbiAgICAgKiAgIE8gPSBBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuXG4gICAgICogICBMID0gU2VhdHRsZVxuICAgICAqICAgU1QgPSBXYXNoaW5ndG9uXG4gICAgICogICBDID0gVVNcbiAgICAgKiAgIFAgPSAyMDE1LTAyLTA1VDIyOjAzOjE5Wi8yMDIwLTAzLTA1VDIyOjAzOjE5WlxuICAgICAqICAgRiA9IDBFOkVDOjVEOkJEOkY5OjgwOkVFOkE5OkEwOjhEOjgxOkFDOjM3OkQ5OjhEOjM0OjFDOkNEOjI3OkQxXG4gICAgICovXG4gICAgJy0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLVxcbidcbiAgICArICdNSUlFQVRDQ0F1bWdBd0lCQWdJQlJUQU5CZ2txaGtpRzl3MEJBUVVGQURDQmlqRUxNQWtHQTFVRUJoTUNWVk14XFxuJ1xuICAgICsgJ0V6QVJCZ05WQkFnTUNsZGhjMmhwYm1kMGIyNHhFREFPQmdOVkJBY01CMU5sWVhSMGJHVXhJakFnQmdOVkJBb01cXG4nXG4gICAgKyAnR1VGdFlYcHZiaUJYWldJZ1UyVnlkbWxqWlhNc0lFbHVZeTR4RXpBUkJnTlZCQXNNQ2tGdFlYcHZiaUJTUkZNeFxcbidcbiAgICArICdHekFaQmdOVkJBTU1Fa0Z0WVhwdmJpQlNSRk1nVW05dmRDQkRRVEFlRncweE5UQXlNRFV5TWpBek1UbGFGdzB5XFxuJ1xuICAgICsgJ01EQXpNRFV5TWpBek1UbGFNSUdVTVFzd0NRWURWUVFHRXdKVlV6RVRNQkVHQTFVRUNBd0tWMkZ6YUdsdVozUnZcXG4nXG4gICAgKyAnYmpFUU1BNEdBMVVFQnd3SFUyVmhkSFJzWlRFaU1DQUdBMVVFQ2d3WlFXMWhlbTl1SUZkbFlpQlRaWEoyYVdObFxcbidcbiAgICArICdjeXdnU1c1akxqRVRNQkVHQTFVRUN3d0tRVzFoZW05dUlGSkVVekVsTUNNR0ExVUVBd3djUVcxaGVtOXVJRkpFXFxuJ1xuICAgICsgJ1V5QmhjQzF6YjNWMGFHVmhjM1F0TVNCRFFUQ0NBU0l3RFFZSktvWklodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NcXG4nXG4gICAgKyAnZ2dFQkFOYVhFbG1TRVl0L1V0eEhGc0FSRmhTVWFoVGYxS05KelIwRG1heTZocU9YUXVSVmJLUndQZDE5dTV2eFxcbidcbiAgICArICdEZEYxc0xUN0Q2OUlLM1ZEblVpUVNjYUN2MkRwdTlmb1p0K3JMeCtjcHgxcWlRZDFVSHJ2cXE4eFB6UU9xQ2RDXFxuJ1xuICAgICsgJ1JGU3RxNnlWWVo2OXlmcGZvSTY3QWpjbE1PamwyVnBoM2Z0Vm5xUDBJZ1ZLWmR6ZUM3ZmQrdW1HZ1I5eFkwUXJcXG4nXG4gICAgKyAnVWJoZC9sV2RzYk52ekszZjFUUFdjZklLUW5wdlN0ODVQSUVESmlyNi9udUpVS010bUpSd1R5bUpmMGkrSlo0eFxcbidcbiAgICArICc3ZEphMzQxcDJrSEtjSE1nT1BXN25KUWtsR0JBNzB5dGpVVjYvcWViUzN5SXVnci8yOG13UmVmbGczVEp6VkRsXFxuJ1xuICAgICsgJ0VPdmk2cHFicU5ia011RXdHRENtRVFJVnFna0NBd0VBQWFObU1HUXdEZ1lEVlIwUEFRSC9CQVFEQWdFR01CSUdcXG4nXG4gICAgKyAnQTFVZEV3RUIvd1FJTUFZQkFmOENBUUF3SFFZRFZSME9CQllFRkF1OTMvNGs1eGJXT3NnZENkbisvS2RpUnVpdFxcbidcbiAgICArICdNQjhHQTFVZEl3UVlNQmFBRkU0Qzdxdys5aFhJVE8wczlRWEJqNXlFQ0VtRE1BMEdDU3FHU0liM0RRRUJCUVVBXFxuJ1xuICAgICsgJ0E0SUJBUUJsY2pTeXNjcFBqZjUrTWd6TXVBc0N4QnlxVXQrV0ZzcHdjTUNwd2RhQmVIT1BTUXJYTnFYMlNrNlBcXG4nXG4gICAgKyAna3RoNm9DaXZBNjR0cldvOHRGTXZQWWxVQTFGWVZENVdwTjBrQ0srUDVwRDRLSGxhRHNYaHVoQ2xKenAvT1A4dFxcbidcbiAgICArICdwT3lVcjUxMDlSSEx4cW9LQjVKNW0xWEE3cmdjRmpuTXh3QlNXRmUzLzR1TWsvKzRUNTNZZkNWWHVjNlFWM2k3XFxuJ1xuICAgICsgJ0kvMkxBSndGZi8vcFR0dDZmWmVuWWZDc2FobnIybnZyTlJOeUF4Y2Z2R1ovNE9wbi9tSnRSNlIvQWp2UVpIaVJcXG4nXG4gICAgKyAnYmtSTktGMkdXMHVlSzVXNEZrWlZaVmhoWDl4aDFBajJPbGxiK2xiT3FBRGFWaitBVDNQb0pQWjNNUFFIS0NYbVxcbidcbiAgICArICd4d0cwTE9MbFJyL1RmRDZsaTFBZk9WVEFKWHY5XFxuJ1xuICAgICsgJy0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS1cXG4nLFxuXG4gICAgLyoqXG4gICAgICogQW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMiBjZXJ0aWZpY2F0ZSBDQSAyMDE1IHRvIDIwMjBcbiAgICAgKlxuICAgICAqICAgQ04gPSBBbWF6b24gUkRTIGFwLXNvdXRoZWFzdC0yIENBXG4gICAgICogICBPVSA9IEFtYXpvbiBSRFNcbiAgICAgKiAgIE8gPSBBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuXG4gICAgICogICBMID0gU2VhdHRsZVxuICAgICAqICAgU1QgPSBXYXNoaW5ndG9uXG4gICAgICogICBDID0gVVNcbiAgICAgKiAgIFAgPSAyMDE1LTAyLTA1VDIyOjAzOjI0Wi8yMDIwLTAzLTA1VDIyOjAzOjI0WlxuICAgICAqICAgRiA9IDIwOkQ5OkE4OjgyOjIzOkFCOkI5OkU1OkM1OjI0OjEwOkQzOjREOjBGOjNEOkIxOjMxOkRGOkU1OjE0XG4gICAgICovXG4gICAgJy0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLVxcbidcbiAgICArICdNSUlFQVRDQ0F1bWdBd0lCQWdJQlJqQU5CZ2txaGtpRzl3MEJBUVVGQURDQmlqRUxNQWtHQTFVRUJoTUNWVk14XFxuJ1xuICAgICsgJ0V6QVJCZ05WQkFnTUNsZGhjMmhwYm1kMGIyNHhFREFPQmdOVkJBY01CMU5sWVhSMGJHVXhJakFnQmdOVkJBb01cXG4nXG4gICAgKyAnR1VGdFlYcHZiaUJYWldJZ1UyVnlkbWxqWlhNc0lFbHVZeTR4RXpBUkJnTlZCQXNNQ2tGdFlYcHZiaUJTUkZNeFxcbidcbiAgICArICdHekFaQmdOVkJBTU1Fa0Z0WVhwdmJpQlNSRk1nVW05dmRDQkRRVEFlRncweE5UQXlNRFV5TWpBek1qUmFGdzB5XFxuJ1xuICAgICsgJ01EQXpNRFV5TWpBek1qUmFNSUdVTVFzd0NRWURWUVFHRXdKVlV6RVRNQkVHQTFVRUNBd0tWMkZ6YUdsdVozUnZcXG4nXG4gICAgKyAnYmpFUU1BNEdBMVVFQnd3SFUyVmhkSFJzWlRFaU1DQUdBMVVFQ2d3WlFXMWhlbTl1SUZkbFlpQlRaWEoyYVdObFxcbidcbiAgICArICdjeXdnU1c1akxqRVRNQkVHQTFVRUN3d0tRVzFoZW05dUlGSkVVekVsTUNNR0ExVUVBd3djUVcxaGVtOXVJRkpFXFxuJ1xuICAgICsgJ1V5QmhjQzF6YjNWMGFHVmhjM1F0TWlCRFFUQ0NBU0l3RFFZSktvWklodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NcXG4nXG4gICAgKyAnZ2dFQkFKcUJBSnV0ejY5aEZPaDNCdExIWlRid0U4ZWVqR0dLYXluOWh1OThZTURQeld6R1hXQ21XK1pZV0VMQVxcbidcbiAgICArICdjWTNjTldORjhLNEZxS1hGcjJzc29yQllpbTFVdFlGWDh5aHlkVDJoTUQ1emdRMnNDR1VwdWlkaWp1UEE2emFxXFxuJ1xuICAgICsgJ1ozdGRoVlI5NGYwcThtcHdwdjJ6cVI5UGNxYUdEeDJWUjF4NzczRnVwUlBSbzdtRVcxdkMzSXB0SENRbFAvekVcXG4nXG4gICAgKyAnN2pRaUxsMjhiRElIMjU2N3hnN2U3RTlXblpUb1JuaGxZZFRhRGFKc0hUemk1bXdJTGk0Y2loU29rN1Nodi9NRVxcbidcbiAgICArICdobnVrdnhlU1BVcGFWdEZhQmhmQnFxMDU1ZVBxOUkrTnM0S0dyZVRLTWhVME85ZmtrYUJhQm1QYUZnbWVYL1hPXFxuJ1xuICAgICsgJ24yQVg3Z01vdW8zbXR2MzRpRFRaMGg2WUNHa0NBd0VBQWFObU1HUXdEZ1lEVlIwUEFRSC9CQVFEQWdFR01CSUdcXG4nXG4gICAgKyAnQTFVZEV3RUIvd1FJTUFZQkFmOENBUUF3SFFZRFZSME9CQllFRklsUW5ZMEtIWVduMWpZdW1TZEpZZndqL05md1xcbidcbiAgICArICdNQjhHQTFVZEl3UVlNQmFBRkU0Qzdxdys5aFhJVE8wczlRWEJqNXlFQ0VtRE1BMEdDU3FHU0liM0RRRUJCUVVBXFxuJ1xuICAgICsgJ0E0SUJBUUEwd1ZVNi9sNDFjVHpIYzRhemM0Q0RZWTJXZDkwREZXaUg5Qy9tdzBTZ1RvWWZDSi81Q2ZpME5UL1lcXG4nXG4gICAgKyAnUFJuazNHY2h5Y2hDSmdvUEEvazlkMC8vSWhZRUFJaUlEanlGVmdqYlRrS1Yzc2g0UmJkbGRLVk9VQjlrdW16L1xcbidcbiAgICArICdacFNocGxzR3QzejRRUWlWbktmckFncXhXRGpSMEkwcFFLa3hYYTZTamtpY29zOUxReFZ0SjBYQTRpZUcxRTd6XFxuJ1xuICAgICsgJ3pKcis2dDgwd216eHZrSW5TYVdQM3hOSks5YXpWUlRyZ1FaUWx2a2JwRGJFeGw0bU5URzY2VkQzYkFwNnQzV2FcXG4nXG4gICAgKyAnQjQ5Ly91RGRmWm1Qa3FxYlgraHN4cDE2ME9IMHJ4SnBwd08zQmg4NjlQa0RuYVBFZC9QeHc3UGF3QytsaTBnaVxcbidcbiAgICArICdOUlY4aUNFeDg1YUZ4Y3lPaHFuMFdaT2FzeGVlXFxuJ1xuICAgICsgJy0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS1cXG4nLFxuXG4gICAgLyoqXG4gICAgICogQW1hem9uIFJEUyBldS1jZW50cmFsLTEgY2VydGlmaWNhdGUgQ0EgMjAxNSB0byAyMDIwXG4gICAgICpcbiAgICAgKiAgIENOID0gQW1hem9uIFJEUyBldS1jZW50cmFsLTEgQ0FcbiAgICAgKiAgIE9VID0gQW1hem9uIFJEU1xuICAgICAqICAgTyA9IEFtYXpvbiBXZWIgU2VydmljZXMsIEluYy5cbiAgICAgKiAgIEwgPSBTZWF0dGxlXG4gICAgICogICBTVCA9IFdhc2hpbmd0b25cbiAgICAgKiAgIEMgPSBVU1xuICAgICAqICAgUCA9IDIwMTUtMDItMDVUMjI6MDM6MzFaLzIwMjAtMDMtMDVUMjI6MDM6MzFaXG4gICAgICogICBGID0gOTQ6QjQ6REY6Qjk6NkQ6N0U6Rjc6QzM6Qjc6QkY6NTE6RTk6QTY6Qjc6NDQ6QTA6RDA6ODI6MTE6ODRcbiAgICAgKi9cbiAgICAnLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tXFxuJ1xuICAgICsgJ01JSUQvekNDQXVlZ0F3SUJBZ0lCUnpBTkJna3Foa2lHOXcwQkFRVUZBRENCaWpFTE1Ba0dBMVVFQmhNQ1ZWTXhcXG4nXG4gICAgKyAnRXpBUkJnTlZCQWdNQ2xkaGMyaHBibWQwYjI0eEVEQU9CZ05WQkFjTUIxTmxZWFIwYkdVeElqQWdCZ05WQkFvTVxcbidcbiAgICArICdHVUZ0WVhwdmJpQlhaV0lnVTJWeWRtbGpaWE1zSUVsdVl5NHhFekFSQmdOVkJBc01Da0Z0WVhwdmJpQlNSRk14XFxuJ1xuICAgICsgJ0d6QVpCZ05WQkFNTUVrRnRZWHB2YmlCU1JGTWdVbTl2ZENCRFFUQWVGdzB4TlRBeU1EVXlNakF6TXpGYUZ3MHlcXG4nXG4gICAgKyAnTURBek1EVXlNakF6TXpGYU1JR1NNUXN3Q1FZRFZRUUdFd0pWVXpFVE1CRUdBMVVFQ0F3S1YyRnphR2x1WjNSdlxcbidcbiAgICArICdiakVRTUE0R0ExVUVCd3dIVTJWaGRIUnNaVEVpTUNBR0ExVUVDZ3daUVcxaGVtOXVJRmRsWWlCVFpYSjJhV05sXFxuJ1xuICAgICsgJ2N5d2dTVzVqTGpFVE1CRUdBMVVFQ3d3S1FXMWhlbTl1SUZKRVV6RWpNQ0VHQTFVRUF3d2FRVzFoZW05dUlGSkVcXG4nXG4gICAgKyAnVXlCbGRTMWpaVzUwY21Gc0xURWdRMEV3Z2dFaU1BMEdDU3FHU0liM0RRRUJBUVVBQTRJQkR3QXdnZ0VLQW9JQlxcbidcbiAgICArICdBUURGdFAyZGhTTHVhUE9JNFpyclBXc0s0T1k5b2NRQnAzeUFwSDFLSlltSTl3cFFLWkcvS0NIMkU2T283SkF3XFxuJ1xuICAgICsgJ1FPUlU1MTlyMDMzVCtGTzJaN3BGUGxtejF5cnhHWHlIcEpzOHlTeDNZbzVTOG5jRENkWkpDTG10UGlxL2hhaGdcXG4nXG4gICAgKyAnNS8wZmZleE1GVUNRYVlpY0Zac3JKL2NTdGR4VVYrdFN3MkpRTEQ3VXhTOUo5N0xRV1VQeXlHK1pyallWVFZxK1xcbidcbiAgICArICd6dWRuRm1OU2U0UW9lY1hNaEFGVEdKRlFYeFA3bmhTTDlBbzVGR2dkWHk3L0pXZVdkUUlBajhrdTZjQkRLUGE2XFxuJ1xuICAgICsgJ1k2a1ArYWsrSW4rTHllOHo5cXNDRC9hZlVvemZXalBSMmFBNEpvSVpWRjhkTlJTaElNbzhsMFhmZ2ZNMnEwK25cXG4nXG4gICAgKyAnQXBaV1orQmpoSU81WHVvVWdIUzNEMllGQWdNQkFBR2paakJrTUE0R0ExVWREd0VCL3dRRUF3SUJCakFTQmdOVlxcbidcbiAgICArICdIUk1CQWY4RUNEQUdBUUgvQWdFQU1CMEdBMVVkRGdRV0JCUm00R3NXSUEvTTZxK3RLOFdHSFdER2gyZ2N5VEFmXFxuJ1xuICAgICsgJ0JnTlZIU01FR0RBV2dCUk9BdTZzUHZZVnlFenRMUFVGd1krY2hBaEpnekFOQmdrcWhraUc5dzBCQVFVRkFBT0NcXG4nXG4gICAgKyAnQVFFQUhwTW1lVlFOcWN4Z2ZRZGJESWk1VUl5K0U3elp5a210QXlnTjFYUXJ2Z2E5blhUaXM0a09UTjZnNS8rZ1xcbidcbiAgICArICdIQ3g3aklYZU5KekFidmc4WEZxQk44NFF1cWdwbC90UWticGNvOUpoMUhEczU1OEQ1Tm5aUXhOcUg1cVhRM01tXFxuJ1xuICAgICsgJ3VQZ0N3MHBZY1BPYTdiaHMwN2krTWRWd1BCc1gyN0NGRHRzZ0FJcnU4SHZLeFkxb1RacldueUlSbzkzdHQvcGtcXG4nXG4gICAgKyAnV3VJdFZNVkhqYVFaVmZUQ293MGFEVWJ0ZTZWbHc4MktqVUZxK24yTk1TQ0pEaURLc0RESFQ2QkpjNEFKSElxM1xcbidcbiAgICArICcvNFo1Mk1TQzlLTXIweUFhYW9XZlcveU1FajlMbGlRYXVBZ3dWakFyRjRxNzhyeHBmS1RHOVJmZDhVMUJaQU5QXFxuJ1xuICAgICsgJzdGckZNTjBUaGpmQTFJdm1PWWNnc2tZNWJRPT1cXG4nXG4gICAgKyAnLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLVxcbicsXG5cbiAgICAvKipcbiAgICAgKiBBbWF6b24gUkRTIGV1LXdlc3QtMSBjZXJ0aWZpY2F0ZSBDQSAyMDE1IHRvIDIwMjBcbiAgICAgKlxuICAgICAqICAgQ04gPSBBbWF6b24gUkRTIGV1LXdlc3QtMSBDQVxuICAgICAqICAgT1UgPSBBbWF6b24gUkRTXG4gICAgICogICBPID0gQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLlxuICAgICAqICAgTCA9IFNlYXR0bGVcbiAgICAgKiAgIFNUID0gV2FzaGluZ3RvblxuICAgICAqICAgQyA9IFVTXG4gICAgICogICBQID0gMjAxNS0wMi0wNVQyMjowMzozNVovMjAyMC0wMy0wNVQyMjowMzozNVpcbiAgICAgKiAgIEYgPSAxQTo5NTpGMDo0Mzo4MjpEMjo1RDpBNjpBRDpGNToxMzoyNzowQjo0MDo4QTo3MjpEOTo5MjpGMzpFMFxuICAgICAqL1xuICAgICctLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS1cXG4nXG4gICAgKyAnTUlJRC9EQ0NBdVNnQXdJQkFnSUJTREFOQmdrcWhraUc5dzBCQVFVRkFEQ0JpakVMTUFrR0ExVUVCaE1DVlZNeFxcbidcbiAgICArICdFekFSQmdOVkJBZ01DbGRoYzJocGJtZDBiMjR4RURBT0JnTlZCQWNNQjFObFlYUjBiR1V4SWpBZ0JnTlZCQW9NXFxuJ1xuICAgICsgJ0dVRnRZWHB2YmlCWFpXSWdVMlZ5ZG1salpYTXNJRWx1WXk0eEV6QVJCZ05WQkFzTUNrRnRZWHB2YmlCU1JGTXhcXG4nXG4gICAgKyAnR3pBWkJnTlZCQU1NRWtGdFlYcHZiaUJTUkZNZ1VtOXZkQ0JEUVRBZUZ3MHhOVEF5TURVeU1qQXpNelZhRncweVxcbidcbiAgICArICdNREF6TURVeU1qQXpNelZhTUlHUE1Rc3dDUVlEVlFRR0V3SlZVekVUTUJFR0ExVUVDQXdLVjJGemFHbHVaM1J2XFxuJ1xuICAgICsgJ2JqRVFNQTRHQTFVRUJ3d0hVMlZoZEhSc1pURWlNQ0FHQTFVRUNnd1pRVzFoZW05dUlGZGxZaUJUWlhKMmFXTmxcXG4nXG4gICAgKyAnY3l3Z1NXNWpMakVUTUJFR0ExVUVDd3dLUVcxaGVtOXVJRkpFVXpFZ01CNEdBMVVFQXd3WFFXMWhlbTl1SUZKRVxcbidcbiAgICArICdVeUJsZFMxM1pYTjBMVEVnUTBFd2dnRWlNQTBHQ1NxR1NJYjNEUUVCQVFVQUE0SUJEd0F3Z2dFS0FvSUJBUUN4XFxuJ1xuICAgICsgJ1BkYnFRMEhLUmo3OVBtb2N4dmpjK1A2aTRVeDI0a2dGSWwrY2tpaXIxdnprbWVzYzNhNThnanJNbENrc0VPYnRcXG4nXG4gICAgKyAnWWloczVJaHpFcTFlUFQwZ2JmUzlHWUZwMzRVai9NdFB3bHJmQ0JXRzRkMlRjcnNLUkhyMS9FWFVZaFdxbWRyYlxcbidcbiAgICArICdSaFg4WHFvUmhWa2JGL2F1ekZTQmhUemNHR3ZacFEyS0lheFJjUWZjWGxNVmhqL3B4eEFqaDhVNEYzNTBGYjBoXFxuJ1xuICAgICsgJ25YMWp3NC9LdkVyZUJMMFhiMmxubEdUa3dWeGFLR1NnWEVuT2dJeU9GZE9RYzYxdmRvbWUwK2VlWnNQNGpxZVJcXG4nXG4gICAgKyAnVEdZSkE5aXpKc1JiZTJZSnhIdWF6RCs1NDhoc1BsTTN2RnpLS0VWVVJDaGE0NjZyQWFZQUh5M3JLdXIzSFlReFxcbidcbiAgICArICdZdCtTb0tjRXo5UFh1U0dqOTZlakFnTUJBQUdqWmpCa01BNEdBMVVkRHdFQi93UUVBd0lCQmpBU0JnTlZIUk1CXFxuJ1xuICAgICsgJ0FmOEVDREFHQVFIL0FnRUFNQjBHQTFVZERnUVdCQlRlYmcvL2gyb2VYYlpqUTR1dW9pdUxZenVpUERBZkJnTlZcXG4nXG4gICAgKyAnSFNNRUdEQVdnQlJPQXU2c1B2WVZ5RXp0TFBVRndZK2NoQWhKZ3pBTkJna3Foa2lHOXcwQkFRVUZBQU9DQVFFQVxcbidcbiAgICArICdUaWtQYUdlWmFzVFB3KzRSQmVtbHN5UEFqdEZGUUxvN2RkYUZkT1JMZ2RFeXNWZjhhQnFuZHZiQTZNVC92NGxqXFxuJ1xuICAgICsgJ0d0RXRVZEY1OVpjYldPclZtK2ZCWjJoL2pZSjU5ZFlGL3h6YjA5bnlSYmRNU3pCOStta1Nzbk9NcWx1cTV5OG9cXG4nXG4gICAgKyAnRFkvUGZQMnZHaEVnLzJabmNSQzdubFFVMURtOEY0bEZXRWlRMmZpN08xY1c4NTJWbWJxNjFSSWZjWXNILzlNYVxcbidcbiAgICArICdrcGdrMTBWWjc1YjhtM1VobXBaLzJ1UlkrSkVISW1INVdwY1RKN3dOaVBOSnNjaVpNem5HdHJnT25QelljbzhMXFxuJ1xuICAgICsgJ2NEbGVPQVNJWmlmTk1RaTlQS09KS3ZpMElUejBCL2ltcjhLQnNXMFlqWlZKNTRITWE3VzFsd3VnU003YU1BcytcXG4nXG4gICAgKyAnRTNTZDVsUytTSHdXYU9DSHdoT0VWQT09XFxuJ1xuICAgICsgJy0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS1cXG4nLFxuXG4gICAgLyoqXG4gICAgICogQW1hem9uIFJEUyBzYS1lYXN0LTEgY2VydGlmaWNhdGUgQ0EgMjAxNSB0byAyMDIwXG4gICAgICpcbiAgICAgKiAgIENOID0gQW1hem9uIFJEUyBzYS1lYXN0LTEgQ0FcbiAgICAgKiAgIE9VID0gQW1hem9uIFJEU1xuICAgICAqICAgTyA9IEFtYXpvbiBXZWIgU2VydmljZXMsIEluYy5cbiAgICAgKiAgIEwgPSBTZWF0dGxlXG4gICAgICogICBTVCA9IFdhc2hpbmd0b25cbiAgICAgKiAgIEMgPSBVU1xuICAgICAqICAgUCA9IDIwMTUtMDItMDVUMjI6MDM6NDBaLzIwMjAtMDMtMDVUMjI6MDM6NDBaXG4gICAgICogICBGID0gMzI6MTA6M0Q6RkE6NkQ6NDI6RjU6MzU6OTg6NDA6MTU6RjQ6NEM6NzQ6NzQ6Mjc6Q0I6Q0U6RDQ6QjVcbiAgICAgKi9cbiAgICAnLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tXFxuJ1xuICAgICsgJ01JSUQvRENDQXVTZ0F3SUJBZ0lCU1RBTkJna3Foa2lHOXcwQkFRVUZBRENCaWpFTE1Ba0dBMVVFQmhNQ1ZWTXhcXG4nXG4gICAgKyAnRXpBUkJnTlZCQWdNQ2xkaGMyaHBibWQwYjI0eEVEQU9CZ05WQkFjTUIxTmxZWFIwYkdVeElqQWdCZ05WQkFvTVxcbidcbiAgICArICdHVUZ0WVhwdmJpQlhaV0lnVTJWeWRtbGpaWE1zSUVsdVl5NHhFekFSQmdOVkJBc01Da0Z0WVhwdmJpQlNSRk14XFxuJ1xuICAgICsgJ0d6QVpCZ05WQkFNTUVrRnRZWHB2YmlCU1JGTWdVbTl2ZENCRFFUQWVGdzB4TlRBeU1EVXlNakF6TkRCYUZ3MHlcXG4nXG4gICAgKyAnTURBek1EVXlNakF6TkRCYU1JR1BNUXN3Q1FZRFZRUUdFd0pWVXpFVE1CRUdBMVVFQ0F3S1YyRnphR2x1WjNSdlxcbidcbiAgICArICdiakVRTUE0R0ExVUVCd3dIVTJWaGRIUnNaVEVpTUNBR0ExVUVDZ3daUVcxaGVtOXVJRmRsWWlCVFpYSjJhV05sXFxuJ1xuICAgICsgJ2N5d2dTVzVqTGpFVE1CRUdBMVVFQ3d3S1FXMWhlbTl1SUZKRVV6RWdNQjRHQTFVRUF3d1hRVzFoZW05dUlGSkVcXG4nXG4gICAgKyAnVXlCellTMWxZWE4wTFRFZ1EwRXdnZ0VpTUEwR0NTcUdTSWIzRFFFQkFRVUFBNElCRHdBd2dnRUtBb0lCQVFDVVxcbidcbiAgICArICdYNE9CblE1eEE2VExKQWlGRUk2bDdiVVdqb1ZKQmEvVmJNZENDU3MyaTJkT0ttcVVhWHUyaXgyemNQSUxqM2xaXFxuJ1xuICAgICsgJ0dNazNkLzJ6dlRLL2NLaGNGcmV3SFVCYW1UZVZIZEVteW5oTVFhbXFObWtNNHB0WXpGY3ZFVXcxVEd4SFQ0cFZcXG4nXG4gICAgKyAnUTZnU043Ky9BSmV3UXZ5SGV4SG84RDArTEROMC9XYTltUm00aXhDWUgyQ3lZWUpOS2FadDkrRVpmTnUrUFBTNFxcbidcbiAgICArICc4aUIwVFdIMERnUWtiV01CZkNSZ29sTExpdEFaa2xaNGR2ZGxFQlM3ZXZOMS83dHRCeFVLNlN2a2VlU3gzekJsXFxuJ1xuICAgICsgJ3d3M0JsWHFjM2J2VFFMMEErUlJ5c2FWeUZidnRwOWRvbUZhREtaQ3BNbURGQU4vbnR4MjE1eG1RZHJTdCtLM0ZcXG4nXG4gICAgKyAnY1hkR1FZSHg1cTQxMENBY2xHbmJBZ01CQUFHalpqQmtNQTRHQTFVZER3RUIvd1FFQXdJQkJqQVNCZ05WSFJNQlxcbidcbiAgICArICdBZjhFQ0RBR0FRSC9BZ0VBTUIwR0ExVWREZ1FXQkJUNmlWV25tL3Vha1MrdEVYMm16SWZ3KzhKTDB6QWZCZ05WXFxuJ1xuICAgICsgJ0hTTUVHREFXZ0JST0F1NnNQdllWeUV6dExQVUZ3WStjaEFoSmd6QU5CZ2txaGtpRzl3MEJBUVVGQUFPQ0FRRUFcXG4nXG4gICAgKyAnRm1ERCtRdURrbFhuMkVnU2h3UXhWMTMrdHhQUnVWZE9TcnV0SGhvQ2dNd0ZXQ010UFB0QkFLczZLUFk3R3V2d1xcbidcbiAgICArICdEcEpvWlNlaERpT2ZzZ01pcmpPV2p2ZmtlV1NOdktmaldUVm5lWDdwWkQ5VzVXUG5zREJ2VGJDR2V6bSt2ODd6XFxuJ1xuICAgICsgJ2IrWk0yWk1vOThtL3drTWNJRUFnZFNLaWxSMmZ1dzhyTGtBamhZRmZzMEE3dERnWjlub0t3Z0h2b0U0ZHNySTBcXG4nXG4gICAgKyAnS1pZY282RGxQL2JyQVNmSFRQYTJwdUJMTjlNY0szditoMEphU3FxbTVSbzJCaDU2dFprUWg4QVd5L21pdUR1S1xcbidcbiAgICArICczK2hORVZkeG9zeGxrTTFUUGExREdqMEV6eksweW9lZXJYdUgySFg3TGxDcnJ4ZjYvd2RLbmpSMTJQTXJMUTRBXFxuJ1xuICAgICsgJ3BDcWtjV3c4OTR6NmJWOU1BdktlNkE9PVxcbidcbiAgICArICctLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tXFxuJyxcblxuICAgIC8qKlxuICAgICAqIEFtYXpvbiBSRFMgdXMtZWFzdC0xIGNlcnRpZmljYXRlIENBIDIwMTUgdG8gMjAyMFxuICAgICAqXG4gICAgICogICBDTiA9IEFtYXpvbiBSRFMgdXMtZWFzdC0xIENBXG4gICAgICogICBPVSA9IEFtYXpvbiBSRFNcbiAgICAgKiAgIE8gPSBBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuXG4gICAgICogICBMID0gU2VhdHRsZVxuICAgICAqICAgU1QgPSBXYXNoaW5ndG9uXG4gICAgICogICBDID0gVVNcbiAgICAgKiAgIFAgPSAyMDE1LTAyLTA1VDIxOjU0OjA0Wi8yMDIwLTAzLTA1VDIxOjU0OjA0WlxuICAgICAqICAgRiA9IDM0OjQ3OjhBOjkwOjhBOjgzOkFFOjQ1OkRDOkI2OjE2Ojc2OkQyOjM1OkVDOkU5Ojc1OkM2OjJDOjYzXG4gICAgICovXG4gICAgJy0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLVxcbidcbiAgICArICdNSUlEL0RDQ0F1U2dBd0lCQWdJQlF6QU5CZ2txaGtpRzl3MEJBUVVGQURDQmlqRUxNQWtHQTFVRUJoTUNWVk14XFxuJ1xuICAgICsgJ0V6QVJCZ05WQkFnTUNsZGhjMmhwYm1kMGIyNHhFREFPQmdOVkJBY01CMU5sWVhSMGJHVXhJakFnQmdOVkJBb01cXG4nXG4gICAgKyAnR1VGdFlYcHZiaUJYWldJZ1UyVnlkbWxqWlhNc0lFbHVZeTR4RXpBUkJnTlZCQXNNQ2tGdFlYcHZiaUJTUkZNeFxcbidcbiAgICArICdHekFaQmdOVkJBTU1Fa0Z0WVhwdmJpQlNSRk1nVW05dmRDQkRRVEFlRncweE5UQXlNRFV5TVRVME1EUmFGdzB5XFxuJ1xuICAgICsgJ01EQXpNRFV5TVRVME1EUmFNSUdQTVFzd0NRWURWUVFHRXdKVlV6RVRNQkVHQTFVRUNBd0tWMkZ6YUdsdVozUnZcXG4nXG4gICAgKyAnYmpFUU1BNEdBMVVFQnd3SFUyVmhkSFJzWlRFaU1DQUdBMVVFQ2d3WlFXMWhlbTl1SUZkbFlpQlRaWEoyYVdObFxcbidcbiAgICArICdjeXdnU1c1akxqRVRNQkVHQTFVRUN3d0tRVzFoZW05dUlGSkVVekVnTUI0R0ExVUVBd3dYUVcxaGVtOXVJRkpFXFxuJ1xuICAgICsgJ1V5QjFjeTFsWVhOMExURWdRMEV3Z2dFaU1BMEdDU3FHU0liM0RRRUJBUVVBQTRJQkR3QXdnZ0VLQW9JQkFRRElcXG4nXG4gICAgKyAnVUl1d2g4TnVzS0hrMVNxUFhjUDdPcXhZM1MvTTJaeVFXRDN3N0JmaWhweXl5L2ZjMXcwL3N1SXBYM2tiTWhBVlxcbidcbiAgICArICcyRVN3Z2VkMi8yelN4NHBWbmpwLzQ5M3I0bHVoU3FRWXpydTc4VHVQdDliaEpJSjUxV1h1blpXMlNXa2lzU2FmXFxuJ1xuICAgICsgJ1VTWVV6Vk45ZXpSL2JqWFR1bVNVUWFMSW91SnQzT0hMWDQ5cyszTkFiVXlPSThFZHZnQlFXRDY4SDFlcHNDMG5cXG4nXG4gICAgKyAnQ0k1cytwSWt0eU9aNTljNERDRExRY1hFclErdE5iREMrK29jdDFBTmQvcThwOVVSb25Zd0dDR09CeTdzYkNZcVxcbidcbiAgICArICc5ZVZIaDFJeTJNK1NOWGRkVk9HdzVFdXJ1dkhvQ0lReU96NUx6NHpTdVpBOWRSYnJmenROT3BlekNOWXU2TktNXFxuJ1xuICAgICsgJ24raHpjdmRpeXh2Nzd1Tm04RWF4QWdNQkFBR2paakJrTUE0R0ExVWREd0VCL3dRRUF3SUJCakFTQmdOVkhSTUJcXG4nXG4gICAgKyAnQWY4RUNEQUdBUUgvQWdFQU1CMEdBMVVkRGdRV0JCUVNRRzNUbU1lNlNhM0t1ZmFQQmE3MnY0UUZEekFmQmdOVlxcbidcbiAgICArICdIU01FR0RBV2dCUk9BdTZzUHZZVnlFenRMUFVGd1krY2hBaEpnekFOQmdrcWhraUc5dzBCQVFVRkFBT0NBUUVBXFxuJ1xuICAgICsgJ0wvbU9aZkIzMTg3eFRtak9ITXFOMkcyb1NLSEJLaVFMTTl1djgrOTdxVCtYUitUVnNCVDZiM3lvUHBNQUdoSEFcXG4nXG4gICAgKyAnUGM3bnhBRjVnUHB1emF0eDBPVExQY21ZdWNGbWZxVC8xcUE1V2xnQ25NTnRjenlOTUg5N2xLRlROVjdOanRla1xcbidcbiAgICArICdqV0V6QUVRU3lFV3JrTnBObEM0ajZrTVl5UHpWWFFlWFVlWlRnSjlGTm5WWnFtdmZqaXAyTjIydGF3TWpyQ241XFxuJ1xuICAgICsgJzdLTi96TjY1RXdZMm9POVhzYVR3d1dtQnUzTnJEZE1iekpuYnhvV2NGV2o0UkJ3YW5SMVhqUU9WTmhEd21DT2xcXG4nXG4gICAgKyAnLzFFdDEzYjhDUHlqNjlQQzhCT1ZVNmNmVFN4OFdVVnkwcXZZT0tITlk5QnFhNUJEbklMM0lWbVVrZVRsTTFtdFxcbidcbiAgICArICdlblJweUJqK0JrOXJoL0lDZGlSS21BPT1cXG4nXG4gICAgKyAnLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLVxcbicsXG5cbiAgICAvKipcbiAgICAgKiBBbWF6b24gUkRTIHVzLXdlc3QtMSBjZXJ0aWZpY2F0ZSBDQSAyMDE1IHRvIDIwMjBcbiAgICAgKlxuICAgICAqICAgQ04gPSBBbWF6b24gUkRTIHVzLXdlc3QtMSBDQVxuICAgICAqICAgT1UgPSBBbWF6b24gUkRTXG4gICAgICogICBPID0gQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLlxuICAgICAqICAgTCA9IFNlYXR0bGVcbiAgICAgKiAgIFNUID0gV2FzaGluZ3RvblxuICAgICAqICAgQyA9IFVTXG4gICAgICogICBQID0gMjAxNS0wMi0wNVQyMjowMzo0NVovMjAyMC0wMy0wNVQyMjowMzo0NVpcbiAgICAgKiAgIEYgPSBFRjo5NDoyRjpFMzo1ODowRTowOTpENjo3OTpDMjoxNjo5Nzo5MTpGQjozNzpFQTpENzo3MDpBODo0QlxuICAgICAqL1xuICAgICctLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS1cXG4nXG4gICAgKyAnTUlJRC9EQ0NBdVNnQXdJQkFnSUJTakFOQmdrcWhraUc5dzBCQVFVRkFEQ0JpakVMTUFrR0ExVUVCaE1DVlZNeFxcbidcbiAgICArICdFekFSQmdOVkJBZ01DbGRoYzJocGJtZDBiMjR4RURBT0JnTlZCQWNNQjFObFlYUjBiR1V4SWpBZ0JnTlZCQW9NXFxuJ1xuICAgICsgJ0dVRnRZWHB2YmlCWFpXSWdVMlZ5ZG1salpYTXNJRWx1WXk0eEV6QVJCZ05WQkFzTUNrRnRZWHB2YmlCU1JGTXhcXG4nXG4gICAgKyAnR3pBWkJnTlZCQU1NRWtGdFlYcHZiaUJTUkZNZ1VtOXZkQ0JEUVRBZUZ3MHhOVEF5TURVeU1qQXpORFZhRncweVxcbidcbiAgICArICdNREF6TURVeU1qQXpORFZhTUlHUE1Rc3dDUVlEVlFRR0V3SlZVekVUTUJFR0ExVUVDQXdLVjJGemFHbHVaM1J2XFxuJ1xuICAgICsgJ2JqRVFNQTRHQTFVRUJ3d0hVMlZoZEhSc1pURWlNQ0FHQTFVRUNnd1pRVzFoZW05dUlGZGxZaUJUWlhKMmFXTmxcXG4nXG4gICAgKyAnY3l3Z1NXNWpMakVUTUJFR0ExVUVDd3dLUVcxaGVtOXVJRkpFVXpFZ01CNEdBMVVFQXd3WFFXMWhlbTl1SUZKRVxcbidcbiAgICArICdVeUIxY3kxM1pYTjBMVEVnUTBFd2dnRWlNQTBHQ1NxR1NJYjNEUUVCQVFVQUE0SUJEd0F3Z2dFS0FvSUJBUURFXFxuJ1xuICAgICsgJ0Rodyt1dy95Y2FpSWhoeXUycFhGUmltcTBEbEI4Y050SWU4aGRxbmRIOFRWL1RGcmxqTmdSOFFkek9nWnRaOUNcXG4nXG4gICAgKyAnenpRMkdScEluTi9xSkY2c2xFZDZ3Tys2VGFEQlFrUFkrMDdUWE50NTJQT0ZVaGRWa2hKWEhwRTJCUzdYbjZKN1xcbidcbiAgICArICc3UkZBT2VHMUlabWMyRER0K3NSMUJnWHpVcUhzbFFHZkZZTlMwL01CTzRQK3lhNlc3SWhydUIxcWZhNEhpWVFTXFxuJ1xuICAgICsgJ2RiZTRNdkdXbnYwVXp3QXFkUjdPRjgrOC81YzU4WVhaSVhDTzlyaVlGMnFsNktOU0w1Y3lEUGNZSzVWSzArUTlcXG4nXG4gICAgKyAnVkk2dnVKSFNNWWNGN3dMZVB3OGp0Qmt0cUFGRS93YmRaaUlIaFp2TnlpTldQUE5UR1VtUWJhSitUelFFSERzNVxcbidcbiAgICArICc4ZW4rL1c3SktuUHlCT2t4eEVOYkFnTUJBQUdqWmpCa01BNEdBMVVkRHdFQi93UUVBd0lCQmpBU0JnTlZIUk1CXFxuJ1xuICAgICsgJ0FmOEVDREFHQVFIL0FnRUFNQjBHQTFVZERnUVdCQlMwbncvdEZSOWJDamdxV1RQSmt5eTRvT0Q4YnpBZkJnTlZcXG4nXG4gICAgKyAnSFNNRUdEQVdnQlJPQXU2c1B2WVZ5RXp0TFBVRndZK2NoQWhKZ3pBTkJna3Foa2lHOXcwQkFRVUZBQU9DQVFFQVxcbidcbiAgICArICdDWEdBWTNmZUFhazZsSGRxajYrWVdqeTZ5eVVuTEszN2JSeFpEc3lEVlhyUFJRYVhSelBUeng3OWp2RHdFYi9IXFxuJ1xuICAgICsgJ1EvYmRRN3pRUldxSmNiaXZRbHdodVBKNGtXUFVaZ1N0M0pVVXVxa01zRHpzdmovYndJamxyRUZET2RIR2gwbWlcXG4nXG4gICAgKyAnZVZJbmdGRWpVWGpNaCs1YUhQRUY5QmxRbkI4TGZWdEtqMThlMTVVRFRYRmEreEpQRnhVUjd3RHpDZm80V0kxbVxcbidcbiAgICArICdzVU1HNHExRmtHQVpnc295RlBaZkY4SVZ2Z0N1R2RSOHozMFZXS2tsRnh0dGxLMGVHTGxQQXlJTzBDUXhQUWxvXFxuJ1xuICAgICsgJ3NhTkpySGY0dExPZ1pJV2srTHBEaE5kOUV0NUV6dkozYVVSVXNLWTRwSVNQUEY1V2R2TTlPRTU5YkVSd1VFcmRcXG4nXG4gICAgKyAnbnVPdVFXUWVlYWRNY2VabmF1UnpKUT09XFxuJ1xuICAgICsgJy0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS1cXG4nLFxuXG4gICAgLyoqXG4gICAgICogQW1hem9uIFJEUyB1cy13ZXN0LTIgY2VydGlmaWNhdGUgQ0EgMjAxNSB0byAyMDIwXG4gICAgICpcbiAgICAgKiAgIENOID0gQW1hem9uIFJEUyB1cy13ZXN0LTIgQ0FcbiAgICAgKiAgIE9VID0gQW1hem9uIFJEU1xuICAgICAqICAgTyA9IEFtYXpvbiBXZWIgU2VydmljZXMsIEluYy5cbiAgICAgKiAgIEwgPSBTZWF0dGxlXG4gICAgICogICBTVCA9IFdhc2hpbmd0b25cbiAgICAgKiAgIEMgPSBVU1xuICAgICAqICAgUCA9IDIwMTUtMDItMDVUMjI6MDM6NTBaLzIwMjAtMDMtMDVUMjI6MDM6NTBaXG4gICAgICogICBGID0gOTQ6MkM6QTg6QjA6MjM6NDg6MTc6RjA6Q0Q6MkY6MTk6N0Y6QzE6RTA6MjE6N0M6NjU6Nzk6MTM6M0FcbiAgICAgKi9cbiAgICAnLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tXFxuJ1xuICAgICsgJ01JSUQvRENDQXVTZ0F3SUJBZ0lCU3pBTkJna3Foa2lHOXcwQkFRVUZBRENCaWpFTE1Ba0dBMVVFQmhNQ1ZWTXhcXG4nXG4gICAgKyAnRXpBUkJnTlZCQWdNQ2xkaGMyaHBibWQwYjI0eEVEQU9CZ05WQkFjTUIxTmxZWFIwYkdVeElqQWdCZ05WQkFvTVxcbidcbiAgICArICdHVUZ0WVhwdmJpQlhaV0lnVTJWeWRtbGpaWE1zSUVsdVl5NHhFekFSQmdOVkJBc01Da0Z0WVhwdmJpQlNSRk14XFxuJ1xuICAgICsgJ0d6QVpCZ05WQkFNTUVrRnRZWHB2YmlCU1JGTWdVbTl2ZENCRFFUQWVGdzB4TlRBeU1EVXlNakF6TlRCYUZ3MHlcXG4nXG4gICAgKyAnTURBek1EVXlNakF6TlRCYU1JR1BNUXN3Q1FZRFZRUUdFd0pWVXpFVE1CRUdBMVVFQ0F3S1YyRnphR2x1WjNSdlxcbidcbiAgICArICdiakVRTUE0R0ExVUVCd3dIVTJWaGRIUnNaVEVpTUNBR0ExVUVDZ3daUVcxaGVtOXVJRmRsWWlCVFpYSjJhV05sXFxuJ1xuICAgICsgJ2N5d2dTVzVqTGpFVE1CRUdBMVVFQ3d3S1FXMWhlbTl1SUZKRVV6RWdNQjRHQTFVRUF3d1hRVzFoZW05dUlGSkVcXG4nXG4gICAgKyAnVXlCMWN5MTNaWE4wTFRJZ1EwRXdnZ0VpTUEwR0NTcUdTSWIzRFFFQkFRVUFBNElCRHdBd2dnRUtBb0lCQVFETVxcbidcbiAgICArICdINThTUjQ4VTZqeUVSQzF2WVRudWIzNHNtZjVFUVZYeXphVG1zcFdHV0d6VDMxTkxOWkdTREZhYTd5ZWY5a2RPXFxuJ1xuICAgICsgJ216SnNnZWJSNXRYcTZMZHdsSW9Xa0tZUTd5Y1VhYWR0VktWWWRJNDBRY0kzY0huMHFMRmxnMmlCWG1XcC9CK2lcXG4nXG4gICAgKyAnWjM0VnVWbENoMzFVajVXbWhhQm96OHQvR1JxaDFWL2FDc2YzV2M2akNlekgzUWZ1Q2pCcHp4ZE9PSE42SWUydlxcbidcbiAgICArICd4WDA5TzVxbVpUdk1vUkJBdlBreGRhUGcvTWk3Znh1ZVdUYkVWazc4a3VGYkYxakhZdzhVMUJMSUxJQWhjcWxxXFxuJ1xuICAgICsgJ3g0dThubDczdDNPM2wvc29OVWNJd1VESzAvUytLZnFod245eVF5UGxoYjRXeTNwZm5aTEpka3lIbGRrdG5RYXZcXG4nXG4gICAgKyAnOVRCOXU3S0g1TGswYUFZc2xNTHhBZ01CQUFHalpqQmtNQTRHQTFVZER3RUIvd1FFQXdJQkJqQVNCZ05WSFJNQlxcbidcbiAgICArICdBZjhFQ0RBR0FRSC9BZ0VBTUIwR0ExVWREZ1FXQkJUOHJvTTRsUm5sRkhXTVBXUnowemt3RlpvZzFqQWZCZ05WXFxuJ1xuICAgICsgJ0hTTUVHREFXZ0JST0F1NnNQdllWeUV6dExQVUZ3WStjaEFoSmd6QU5CZ2txaGtpRzl3MEJBUVVGQUFPQ0FRRUFcXG4nXG4gICAgKyAnSndyeHdnd21QdGNkYVU3TzdXRGRZYTRocHJwT01hbUk0OU5Eem1FMHMxMG9HcnFtTHdaeWdjV1UwalQrZkorWVxcbidcbiAgICArICdwSmUxdzBDVmZLYWVMWU5zT0JWVzNYNFpQbWZmWWZXQmhlWmlhaUVmbHEvUDZ0Ny9FZzgxZ2FLWW5aL3gxRGZhXFxuJ1xuICAgICsgJ3NVWWt6UHZDa1hlOXdFejV6ZFVUT0NwdER0ODlyQlI5Q3N0TDl2RTdXWVVnaVZWbUJKZmZXYkhRTHRmanY2T0ZcXG4nXG4gICAgKyAnTk1iMFFNRTk4MWtHUnpjMldoZ1A3MVlTMmhIZDFrWHRzb1lQMXlUdTR2VGhTS3NvTjRia2lIc2FDMWNSa0xveVxcbidcbiAgICArICcwZkZBNHdwQjNXbG9NRXZDRGFVdnZIMUxabEJYVE5sd2k5S3Rjd0Q0dER4a2tCdDR0UWN6S0xHcFEvbkYvVzluXFxuJ1xuICAgICsgJzhZRFdrM0lJYzFzZDBia1pxb2F1MlE9PVxcbidcbiAgICArICctLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tXFxuJ1xuICBdXG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9saWIvcHJvdG9jb2wvY29uc3RhbnRzL3NzbF9wcm9maWxlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgUGFyc2VyICAgICAgID0gcmVxdWlyZSgnLi9QYXJzZXInKTtcbnZhciBTZXF1ZW5jZXMgICAgPSByZXF1aXJlKCcuL3NlcXVlbmNlcycpO1xudmFyIFBhY2tldHMgICAgICA9IHJlcXVpcmUoJy4vcGFja2V0cycpO1xudmFyIFRpbWVycyAgICAgICA9IHJlcXVpcmUoJ3RpbWVycycpO1xudmFyIFN0cmVhbSAgICAgICA9IHJlcXVpcmUoJ3N0cmVhbScpLlN0cmVhbTtcbnZhciBVdGlsICAgICAgICAgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgUGFja2V0V3JpdGVyID0gcmVxdWlyZSgnLi9QYWNrZXRXcml0ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm90b2NvbDtcblV0aWwuaW5oZXJpdHMoUHJvdG9jb2wsIFN0cmVhbSk7XG5mdW5jdGlvbiBQcm90b2NvbChvcHRpb25zKSB7XG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICB0aGlzLl9jb25maWcgICAgICAgICAgICAgICAgICAgICAgICA9IG9wdGlvbnMuY29uZmlnIHx8IHt9O1xuICB0aGlzLl9jb25uZWN0aW9uICAgICAgICAgICAgICAgICAgICA9IG9wdGlvbnMuY29ubmVjdGlvbjtcbiAgdGhpcy5fY2FsbGJhY2sgICAgICAgICAgICAgICAgICAgICAgPSBudWxsO1xuICB0aGlzLl9mYXRhbEVycm9yICAgICAgICAgICAgICAgICAgICA9IG51bGw7XG4gIHRoaXMuX3F1aXRTZXF1ZW5jZSAgICAgICAgICAgICAgICAgID0gbnVsbDtcbiAgdGhpcy5faGFuZHNoYWtlU2VxdWVuY2UgICAgICAgICAgICAgPSBudWxsO1xuICB0aGlzLl9oYW5kc2hha2VkICAgICAgICAgICAgICAgICAgICA9IGZhbHNlO1xuICB0aGlzLl9lbmRlZCAgICAgICAgICAgICAgICAgICAgICAgICA9IGZhbHNlO1xuICB0aGlzLl9kZXN0cm95ZWQgICAgICAgICAgICAgICAgICAgICA9IGZhbHNlO1xuICB0aGlzLl9xdWV1ZSAgICAgICAgICAgICAgICAgICAgICAgICA9IFtdO1xuICB0aGlzLl9oYW5kc2hha2VJbml0aWFsaXphdGlvblBhY2tldCA9IG51bGw7XG5cbiAgdGhpcy5fcGFyc2VyID0gbmV3IFBhcnNlcih7XG4gICAgb25FcnJvciAgOiB0aGlzLmhhbmRsZVBhcnNlckVycm9yLmJpbmQodGhpcyksXG4gICAgb25QYWNrZXQgOiB0aGlzLl9wYXJzZVBhY2tldC5iaW5kKHRoaXMpLFxuICAgIGNvbmZpZyAgIDogdGhpcy5fY29uZmlnXG4gIH0pO1xufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdGhpcy5fcGFyc2VyLndyaXRlKGJ1ZmZlcik7XG4gIHJldHVybiB0cnVlO1xufTtcblxuUHJvdG9jb2wucHJvdG90eXBlLmhhbmRzaGFrZSA9IGZ1bmN0aW9uIGhhbmRzaGFrZShvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuY29uZmlnID0gdGhpcy5fY29uZmlnO1xuXG4gIHJldHVybiB0aGlzLl9oYW5kc2hha2VTZXF1ZW5jZSA9IHRoaXMuX2VucXVldWUobmV3IFNlcXVlbmNlcy5IYW5kc2hha2Uob3B0aW9ucywgY2FsbGJhY2spKTtcbn07XG5cblByb3RvY29sLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9lbnF1ZXVlKG5ldyBTZXF1ZW5jZXMuUXVlcnkob3B0aW9ucywgY2FsbGJhY2spKTtcbn07XG5cblByb3RvY29sLnByb3RvdHlwZS5jaGFuZ2VVc2VyID0gZnVuY3Rpb24gY2hhbmdlVXNlcihvcHRpb25zLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5fZW5xdWV1ZShuZXcgU2VxdWVuY2VzLkNoYW5nZVVzZXIob3B0aW9ucywgY2FsbGJhY2spKTtcbn07XG5cblByb3RvY29sLnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gcGluZyhvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2VucXVldWUobmV3IFNlcXVlbmNlcy5QaW5nKG9wdGlvbnMsIGNhbGxiYWNrKSk7XG59O1xuXG5Qcm90b2NvbC5wcm90b3R5cGUuc3RhdHMgPSBmdW5jdGlvbiBzdGF0cyhvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2VucXVldWUobmV3IFNlcXVlbmNlcy5TdGF0aXN0aWNzKG9wdGlvbnMsIGNhbGxiYWNrKSk7XG59O1xuXG5Qcm90b2NvbC5wcm90b3R5cGUucXVpdCA9IGZ1bmN0aW9uIHF1aXQob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9xdWl0U2VxdWVuY2UgPSB0aGlzLl9lbnF1ZXVlKG5ldyBTZXF1ZW5jZXMuUXVpdChvcHRpb25zLCBjYWxsYmFjaykpO1xufTtcblxuUHJvdG9jb2wucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICBpZih0aGlzLl9lbmRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9lbmRlZCA9IHRydWU7XG5cbiAgdmFyIGV4cGVjdGVkID0gKHRoaXMuX3F1aXRTZXF1ZW5jZSAmJiB0aGlzLl9xdWV1ZVswXSA9PT0gdGhpcy5fcXVpdFNlcXVlbmNlKTtcbiAgaWYgKGV4cGVjdGVkKSB7XG4gICAgdGhpcy5fcXVpdFNlcXVlbmNlLmVuZCgpO1xuICAgIHRoaXMuZW1pdCgnZW5kJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVyciA9IG5ldyBFcnJvcignQ29ubmVjdGlvbiBsb3N0OiBUaGUgc2VydmVyIGNsb3NlZCB0aGUgY29ubmVjdGlvbi4nKTtcbiAgZXJyLmZhdGFsID0gdHJ1ZTtcbiAgZXJyLmNvZGUgPSAnUFJPVE9DT0xfQ09OTkVDVElPTl9MT1NUJztcblxuICB0aGlzLl9kZWxlZ2F0ZUVycm9yKGVycik7XG59O1xuXG5Qcm90b2NvbC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcGFyc2VyLnBhdXNlKCk7XG4gIC8vIFNpbmNlIHRoZXJlIGlzIGEgZmlsZSBzdHJlYW0gaW4gcXVlcnksIHdlIG11c3QgdHJhbnNtaXQgcGF1c2UvcmVzdW1lIGV2ZW50IHRvIGN1cnJlbnQgc2VxdWVuY2UuXG4gIHZhciBzZXEgPSB0aGlzLl9xdWV1ZVswXTtcbiAgaWYgKHNlcSAmJiBzZXEuZW1pdCkge1xuICAgIHNlcS5lbWl0KCdwYXVzZScpO1xuICB9XG59O1xuXG5Qcm90b2NvbC5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3BhcnNlci5yZXN1bWUoKTtcbiAgLy8gU2luY2UgdGhlcmUgaXMgYSBmaWxlIHN0cmVhbSBpbiBxdWVyeSwgd2UgbXVzdCB0cmFuc21pdCBwYXVzZS9yZXN1bWUgZXZlbnQgdG8gY3VycmVudCBzZXF1ZW5jZS5cbiAgdmFyIHNlcSA9IHRoaXMuX3F1ZXVlWzBdO1xuICBpZiAoc2VxICYmIHNlcS5lbWl0KSB7XG4gICAgc2VxLmVtaXQoJ3Jlc3VtZScpO1xuICB9XG59O1xuXG5Qcm90b2NvbC5wcm90b3R5cGUuX2VucXVldWUgPSBmdW5jdGlvbihzZXF1ZW5jZSkge1xuICBpZiAoIXRoaXMuX3ZhbGlkYXRlRW5xdWV1ZShzZXF1ZW5jZSkpIHtcbiAgICByZXR1cm4gc2VxdWVuY2U7XG4gIH1cblxuICBpZiAodGhpcy5fY29uZmlnLnRyYWNlKSB7XG4gICAgLy8gTG9uZyBzdGFjayB0cmFjZSBzdXBwb3J0XG4gICAgc2VxdWVuY2UuX2NhbGxTaXRlID0gc2VxdWVuY2UuX2NhbGxTaXRlIHx8IG5ldyBFcnJvcjtcbiAgfVxuXG4gIHRoaXMuX3F1ZXVlLnB1c2goc2VxdWVuY2UpO1xuICB0aGlzLmVtaXQoJ2VucXVldWUnLCBzZXF1ZW5jZSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZXF1ZW5jZVxuICAgIC5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIHNlbGYuX2RlbGVnYXRlRXJyb3IoZXJyLCBzZXF1ZW5jZSk7XG4gICAgfSlcbiAgICAub24oJ3BhY2tldCcsIGZ1bmN0aW9uKHBhY2tldCkge1xuICAgICAgVGltZXJzLmFjdGl2ZShzZXF1ZW5jZSk7XG4gICAgICBzZWxmLl9lbWl0UGFja2V0KHBhY2tldCk7XG4gICAgfSlcbiAgICAub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5fZGVxdWV1ZShzZXF1ZW5jZSk7XG4gICAgfSlcbiAgICAub24oJ3RpbWVvdXQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3Ioc2VxdWVuY2UuY29uc3RydWN0b3IubmFtZSArICcgaW5hY3Rpdml0eSB0aW1lb3V0Jyk7XG5cbiAgICAgIGVyci5jb2RlICAgID0gJ1BST1RPQ09MX1NFUVVFTkNFX1RJTUVPVVQnO1xuICAgICAgZXJyLmZhdGFsICAgPSB0cnVlO1xuICAgICAgZXJyLnRpbWVvdXQgPSBzZXF1ZW5jZS5fdGltZW91dDtcblxuICAgICAgc2VsZi5fZGVsZWdhdGVFcnJvcihlcnIsIHNlcXVlbmNlKTtcbiAgICB9KVxuICAgIC5vbignc3RhcnQtdGxzJywgZnVuY3Rpb24oKSB7XG4gICAgICBUaW1lcnMuYWN0aXZlKHNlcXVlbmNlKTtcbiAgICAgIHNlbGYuX2Nvbm5lY3Rpb24uX3N0YXJ0VExTKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gU1NMIG5lZ290aWF0aW9uIGVycm9yIGFyZSBmYXRhbFxuICAgICAgICAgIGVyci5jb2RlICA9ICdIQU5EU0hBS0VfU1NMX0VSUk9SJztcbiAgICAgICAgICBlcnIuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgIHNlcXVlbmNlLmVuZChlcnIpO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgVGltZXJzLmFjdGl2ZShzZXF1ZW5jZSk7XG4gICAgICAgIHNlcXVlbmNlLl90bHNVcGdyYWRlQ29tcGxldGVIYW5kbGVyKCk7XG4gICAgICB9KSBcbiAgICB9KTtcblxuICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5fcGFyc2VyLnJlc2V0UGFja2V0TnVtYmVyKCk7XG4gICAgdGhpcy5fc3RhcnRTZXF1ZW5jZShzZXF1ZW5jZSk7XG4gIH1cblxuICByZXR1cm4gc2VxdWVuY2U7XG59O1xuXG5Qcm90b2NvbC5wcm90b3R5cGUuX3ZhbGlkYXRlRW5xdWV1ZSA9IGZ1bmN0aW9uIF92YWxpZGF0ZUVucXVldWUoc2VxdWVuY2UpIHtcbiAgdmFyIGVycjtcbiAgdmFyIHByZWZpeCA9ICdDYW5ub3QgZW5xdWV1ZSAnICsgc2VxdWVuY2UuY29uc3RydWN0b3IubmFtZTtcbiAgdmFyIHByZWZpeEJlZm9yZSA9IHByZWZpeCArICcgYmVmb3JlICc7XG4gIHZhciBwcmVmaXhBZnRlciA9IHByZWZpeCArICcgYWZ0ZXIgJztcblxuICBpZiAodGhpcy5fZmF0YWxFcnJvcikge1xuICAgIGVyciAgICAgID0gbmV3IEVycm9yKHByZWZpeEFmdGVyICsgJ2ZhdGFsIGVycm9yLicpO1xuICAgIGVyci5jb2RlID0gJ1BST1RPQ09MX0VOUVVFVUVfQUZURVJfRkFUQUxfRVJST1InO1xuICB9IGVsc2UgaWYgKHRoaXMuX3F1aXRTZXF1ZW5jZSkge1xuICAgIGVyciAgICAgID0gbmV3IEVycm9yKHByZWZpeEFmdGVyICsgJ2ludm9raW5nIHF1aXQuJyk7XG4gICAgZXJyLmNvZGUgPSAnUFJPVE9DT0xfRU5RVUVVRV9BRlRFUl9RVUlUJztcbiAgfSBlbHNlIGlmICh0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICBlcnIgICAgICA9IG5ldyBFcnJvcihwcmVmaXhBZnRlciArICdiZWluZyBkZXN0cm95ZWQuJyk7XG4gICAgZXJyLmNvZGUgPSAnUFJPVE9DT0xfRU5RVUVVRV9BRlRFUl9ERVNUUk9ZJztcbiAgfSBlbHNlIGlmICh0aGlzLl9oYW5kc2hha2VTZXF1ZW5jZSAmJiBzZXF1ZW5jZS5jb25zdHJ1Y3RvciA9PT0gU2VxdWVuY2VzLkhhbmRzaGFrZSkge1xuICAgIGVyciAgICAgID0gbmV3IEVycm9yKHByZWZpeEFmdGVyICsgJ2FscmVhZHkgZW5xdWV1aW5nIGEgSGFuZHNoYWtlLicpO1xuICAgIGVyci5jb2RlID0gJ1BST1RPQ09MX0VOUVVFVUVfSEFORFNIQUtFX1RXSUNFJztcbiAgfSBlbHNlIGlmICghdGhpcy5faGFuZHNoYWtlU2VxdWVuY2UgJiYgc2VxdWVuY2UuY29uc3RydWN0b3IgPT09IFNlcXVlbmNlcy5DaGFuZ2VVc2VyKSB7XG4gICAgZXJyICAgICAgPSBuZXcgRXJyb3IocHJlZml4QmVmb3JlICsgJ2EgSGFuZHNoYWtlLicpO1xuICAgIGVyci5jb2RlID0gJ1BST1RPQ09MX0VOUVVFVUVfQkVGT1JFX0hBTkRTSEFLRSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgc2VsZiAgPSB0aGlzO1xuICBlcnIuZmF0YWwgPSBmYWxzZTtcblxuICAvLyBhZGQgZXJyb3IgaGFuZGxlclxuICBzZXF1ZW5jZS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5fZGVsZWdhdGVFcnJvcihlcnIsIHNlcXVlbmNlKTtcbiAgfSk7XG5cbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgc2VxdWVuY2UuZW5kKGVycik7XG4gIH0pO1xuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cblByb3RvY29sLnByb3RvdHlwZS5fcGFyc2VQYWNrZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlcXVlbmNlID0gdGhpcy5fcXVldWVbMF07XG5cbiAgaWYgKCFzZXF1ZW5jZSkge1xuICAgIHZhciBlcnIgICA9IG5ldyBFcnJvcignUmVjZWl2ZWQgcGFja2V0IHdpdGggbm8gYWN0aXZlIHNlcXVlbmNlLicpO1xuICAgIGVyci5jb2RlICA9ICdQUk9UT0NPTF9TVFJBWV9QQUNLRVQnO1xuICAgIGVyci5mYXRhbCA9IHRydWU7XG5cbiAgICB0aGlzLl9kZWxlZ2F0ZUVycm9yKGVycik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIFBhY2tldCAgICAgPSB0aGlzLl9kZXRlcm1pbmVQYWNrZXQoc2VxdWVuY2UpO1xuICB2YXIgcGFja2V0ICAgICA9IG5ldyBQYWNrZXQoe3Byb3RvY29sNDE6IHRoaXMuX2NvbmZpZy5wcm90b2NvbDQxfSk7XG4gIHZhciBwYWNrZXROYW1lID0gUGFja2V0Lm5hbWU7XG5cbiAgLy8gU3BlY2lhbCBjYXNlOiBGYXN0ZXIgZGlzcGF0Y2gsIGFuZCBwYXJzaW5nIGRvbmUgaW5zaWRlIHNlcXVlbmNlXG4gIGlmIChQYWNrZXQgPT09IFBhY2tldHMuUm93RGF0YVBhY2tldCkge1xuICAgIHNlcXVlbmNlLlJvd0RhdGFQYWNrZXQocGFja2V0LCB0aGlzLl9wYXJzZXIsIHRoaXMuX2Nvbm5lY3Rpb24pO1xuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5kZWJ1Zykge1xuICAgICAgdGhpcy5fZGVidWdQYWNrZXQodHJ1ZSwgcGFja2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5fY29uZmlnLmRlYnVnKSB7XG4gICAgdGhpcy5fcGFyc2VQYWNrZXREZWJ1ZyhwYWNrZXQpO1xuICB9IGVsc2Uge1xuICAgIHBhY2tldC5wYXJzZSh0aGlzLl9wYXJzZXIpO1xuICB9XG5cbiAgaWYgKFBhY2tldCA9PT0gUGFja2V0cy5IYW5kc2hha2VJbml0aWFsaXphdGlvblBhY2tldCkge1xuICAgIHRoaXMuX2hhbmRzaGFrZUluaXRpYWxpemF0aW9uUGFja2V0ID0gcGFja2V0O1xuICB9XG5cbiAgVGltZXJzLmFjdGl2ZShzZXF1ZW5jZSk7XG5cbiAgaWYgKCFzZXF1ZW5jZVtwYWNrZXROYW1lXSkge1xuICAgIHZhciBlcnIgICA9IG5ldyBFcnJvcignUmVjZWl2ZWQgcGFja2V0IGluIHRoZSB3cm9uZyBzZXF1ZW5jZS4nKTtcbiAgICBlcnIuY29kZSAgPSAnUFJPVE9DT0xfSU5DT1JSRUNUX1BBQ0tFVF9TRVFVRU5DRSc7XG4gICAgZXJyLmZhdGFsID0gdHJ1ZTtcblxuICAgIHRoaXMuX2RlbGVnYXRlRXJyb3IoZXJyKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzZXF1ZW5jZVtwYWNrZXROYW1lXShwYWNrZXQpO1xufTtcblxuUHJvdG9jb2wucHJvdG90eXBlLl9wYXJzZVBhY2tldERlYnVnID0gZnVuY3Rpb24gX3BhcnNlUGFja2V0RGVidWcocGFja2V0KSB7XG4gIHRyeSB7XG4gICAgcGFja2V0LnBhcnNlKHRoaXMuX3BhcnNlcik7XG4gIH0gZmluYWxseSB7XG4gICAgdGhpcy5fZGVidWdQYWNrZXQodHJ1ZSwgcGFja2V0KTtcbiAgfVxufTtcblxuUHJvdG9jb2wucHJvdG90eXBlLl9lbWl0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHZhciBwYWNrZXRXcml0ZXIgPSBuZXcgUGFja2V0V3JpdGVyKCk7XG4gIHBhY2tldC53cml0ZShwYWNrZXRXcml0ZXIpO1xuICB0aGlzLmVtaXQoJ2RhdGEnLCBwYWNrZXRXcml0ZXIudG9CdWZmZXIodGhpcy5fcGFyc2VyKSk7XG5cbiAgaWYgKHRoaXMuX2NvbmZpZy5kZWJ1Zykge1xuICAgIHRoaXMuX2RlYnVnUGFja2V0KGZhbHNlLCBwYWNrZXQpO1xuICB9XG59O1xuXG5Qcm90b2NvbC5wcm90b3R5cGUuX2RldGVybWluZVBhY2tldCA9IGZ1bmN0aW9uKHNlcXVlbmNlKSB7XG4gIHZhciBmaXJzdEJ5dGUgPSB0aGlzLl9wYXJzZXIucGVhaygpO1xuXG4gIGlmIChzZXF1ZW5jZS5kZXRlcm1pbmVQYWNrZXQpIHtcbiAgICB2YXIgUGFja2V0ID0gc2VxdWVuY2UuZGV0ZXJtaW5lUGFja2V0KGZpcnN0Qnl0ZSwgdGhpcy5fcGFyc2VyKTtcbiAgICBpZiAoUGFja2V0KSB7XG4gICAgICByZXR1cm4gUGFja2V0O1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAoZmlyc3RCeXRlKSB7XG4gICAgY2FzZSAweDAwOlxuICAgICAgaWYgKCF0aGlzLl9oYW5kc2hha2VkKSB7XG4gICAgICAgIHRoaXMuX2hhbmRzaGFrZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoJ2hhbmRzaGFrZScsIHRoaXMuX2hhbmRzaGFrZUluaXRpYWxpemF0aW9uUGFja2V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQYWNrZXRzLk9rUGFja2V0O1xuICAgIGNhc2UgMHhmZTogcmV0dXJuIFBhY2tldHMuRW9mUGFja2V0O1xuICAgIGNhc2UgMHhmZjogcmV0dXJuIFBhY2tldHMuRXJyb3JQYWNrZXQ7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgcGFja2V0LCBmaXJzdEJ5dGUgPSAnICsgZmlyc3RCeXRlKTtcbn07XG5cblByb3RvY29sLnByb3RvdHlwZS5fZGVxdWV1ZSA9IGZ1bmN0aW9uKHNlcXVlbmNlKSB7XG4gIFRpbWVycy51bmVucm9sbChzZXF1ZW5jZSk7XG5cbiAgLy8gTm8gcG9pbnQgaW4gYWR2YW5jaW5nIHRoZSBxdWV1ZSwgd2UgYXJlIGRlYWRcbiAgaWYgKHRoaXMuX2ZhdGFsRXJyb3IpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuXG4gIHZhciBzZXF1ZW5jZSA9IHRoaXMuX3F1ZXVlWzBdO1xuICBpZiAoIXNlcXVlbmNlKSB7XG4gICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX3BhcnNlci5yZXNldFBhY2tldE51bWJlcigpO1xuXG4gIHRoaXMuX3N0YXJ0U2VxdWVuY2Uoc2VxdWVuY2UpO1xufTtcblxuUHJvdG9jb2wucHJvdG90eXBlLl9zdGFydFNlcXVlbmNlID0gZnVuY3Rpb24oc2VxdWVuY2UpIHtcbiAgaWYgKHNlcXVlbmNlLl90aW1lb3V0ID4gMCAmJiBpc0Zpbml0ZShzZXF1ZW5jZS5fdGltZW91dCkpIHtcbiAgICBUaW1lcnMuZW5yb2xsKHNlcXVlbmNlLCBzZXF1ZW5jZS5fdGltZW91dCk7XG4gICAgVGltZXJzLmFjdGl2ZShzZXF1ZW5jZSk7XG4gIH1cblxuICBpZiAoc2VxdWVuY2UuY29uc3RydWN0b3IgPT09IFNlcXVlbmNlcy5DaGFuZ2VVc2VyKSB7XG4gICAgc2VxdWVuY2Uuc3RhcnQodGhpcy5faGFuZHNoYWtlSW5pdGlhbGl6YXRpb25QYWNrZXQpO1xuICB9IGVsc2Uge1xuICAgIHNlcXVlbmNlLnN0YXJ0KCk7XG4gIH1cbn07XG5cblByb3RvY29sLnByb3RvdHlwZS5oYW5kbGVOZXR3b3JrRXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgZXJyLmZhdGFsID0gdHJ1ZTtcblxuICB2YXIgc2VxdWVuY2UgPSB0aGlzLl9xdWV1ZVswXTtcbiAgaWYgKHNlcXVlbmNlKSB7XG4gICAgc2VxdWVuY2UuZW5kKGVycik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZGVsZWdhdGVFcnJvcihlcnIpO1xuICB9XG59O1xuXG5Qcm90b2NvbC5wcm90b3R5cGUuaGFuZGxlUGFyc2VyRXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVQYXJzZXJFcnJvcihlcnIpIHtcbiAgdmFyIHNlcXVlbmNlID0gdGhpcy5fcXVldWVbMF07XG4gIGlmIChzZXF1ZW5jZSkge1xuICAgIHNlcXVlbmNlLmVuZChlcnIpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2RlbGVnYXRlRXJyb3IoZXJyKTtcbiAgfVxufTtcblxuUHJvdG9jb2wucHJvdG90eXBlLl9kZWxlZ2F0ZUVycm9yID0gZnVuY3Rpb24oZXJyLCBzZXF1ZW5jZSkge1xuICAvLyBTdG9wIGRlbGVnYXRpbmcgZXJyb3JzIGFmdGVyIHRoZSBmaXJzdCBmYXRhbCBlcnJvclxuICBpZiAodGhpcy5fZmF0YWxFcnJvcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChlcnIuZmF0YWwpIHtcbiAgICB0aGlzLl9mYXRhbEVycm9yID0gZXJyO1xuICB9XG5cbiAgaWYgKHRoaXMuX3Nob3VsZEVycm9yQnViYmxlVXAoZXJyLCBzZXF1ZW5jZSkpIHtcbiAgICAvLyBDYW4ndCB1c2UgcmVndWxhciAnZXJyb3InIGV2ZW50IGhlcmUgYXMgdGhhdCBhbHdheXMgZGVzdHJveXMgdGhlIHBpcGVcbiAgICAvLyBiZXR3ZWVuIHNvY2tldCBhbmQgcHJvdG9jb2wgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudCAodW5sZXNzIHRoZVxuICAgIC8vIGV4Y2VwdGlvbiB3YXMgZmF0YWwpLlxuICAgIHRoaXMuZW1pdCgndW5oYW5kbGVkRXJyb3InLCBlcnIpO1xuICB9IGVsc2UgaWYgKGVyci5mYXRhbCkge1xuICAgIC8vIFNlbmQgZmF0YWwgZXJyb3IgdG8gYWxsIHNlcXVlbmNlcyBpbiB0aGUgcXVldWVcbiAgICB2YXIgcXVldWUgPSB0aGlzLl9xdWV1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKHNlcXVlbmNlKSB7XG4gICAgICAgIHNlcXVlbmNlLmVuZChlcnIpO1xuICAgICAgfSk7XG4gICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHRoZSBzdHJlYW0gd2UgYXJlIHBpcGluZyB0byBpcyBnZXR0aW5nIGNsb3NlZFxuICBpZiAoZXJyLmZhdGFsKSB7XG4gICAgdGhpcy5lbWl0KCdlbmQnLCBlcnIpO1xuICB9XG59O1xuXG5Qcm90b2NvbC5wcm90b3R5cGUuX3Nob3VsZEVycm9yQnViYmxlVXAgPSBmdW5jdGlvbihlcnIsIHNlcXVlbmNlKSB7XG4gIGlmIChzZXF1ZW5jZSkge1xuICAgIGlmIChzZXF1ZW5jZS5oYXNFcnJvckhhbmRsZXIoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWVyci5mYXRhbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChlcnIuZmF0YWwgJiYgIXRoaXMuX2hhc1BlbmRpbmdFcnJvckhhbmRsZXJzKCkpO1xufTtcblxuUHJvdG9jb2wucHJvdG90eXBlLl9oYXNQZW5kaW5nRXJyb3JIYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcXVldWUuc29tZShmdW5jdGlvbihzZXF1ZW5jZSkge1xuICAgIHJldHVybiBzZXF1ZW5jZS5oYXNFcnJvckhhbmRsZXIoKTtcbiAgfSk7XG59O1xuXG5Qcm90b2NvbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICB0aGlzLl9wYXJzZXIucGF1c2UoKTtcblxuICBpZiAodGhpcy5fY29ubmVjdGlvbi5zdGF0ZSAhPT0gXCJkaXNjb25uZWN0ZWRcIikge1xuICAgIGlmKCF0aGlzLl9lbmRlZCkge1xuICAgICAgdGhpcy5lbmQoKTtcbiAgICB9XG4gIH1cbn07XG5cblByb3RvY29sLnByb3RvdHlwZS5fZGVidWdQYWNrZXQgPSBmdW5jdGlvbihpbmNvbWluZywgcGFja2V0KSB7XG4gIHZhciBoZWFkbGluZSA9IChpbmNvbWluZylcbiAgICA/ICc8LS0gJ1xuICAgIDogJy0tPiAnO1xuXG4gIGhlYWRsaW5lID0gaGVhZGxpbmUgKyBwYWNrZXQuY29uc3RydWN0b3IubmFtZTtcblxuICAvLyBjaGVjayBmb3IgZGVidWcgcGFja2V0IHJlc3RyaWN0aW9uXG4gIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX2NvbmZpZy5kZWJ1ZykgJiYgdGhpcy5fY29uZmlnLmRlYnVnLmluZGV4T2YocGFja2V0LmNvbnN0cnVjdG9yLm5hbWUpID09PSAtMSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnNvbGUubG9nKGhlYWRsaW5lKTtcbiAgY29uc29sZS5sb2cocGFja2V0KTtcbiAgY29uc29sZS5sb2coJycpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL2xpYi9wcm90b2NvbC9Qcm90b2NvbC5qc1xuICoqIG1vZHVsZSBpZCA9IDI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgTUFYX1BBQ0tFVF9MRU5HVEggPSBNYXRoLnBvdygyLCAyNCkgLSAxO1xudmFyIE1VTF8zMkJJVCAgICAgICAgID0gTWF0aC5wb3coMiwgMzIpO1xudmFyIFBhY2tldEhlYWRlciAgICAgID0gcmVxdWlyZSgnLi9QYWNrZXRIZWFkZXInKTtcbnZhciBCaWdOdW1iZXIgICAgICAgICA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlcjtcbmZ1bmN0aW9uIFBhcnNlcihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMuX3N1cHBvcnRCaWdOdW1iZXJzID0gb3B0aW9ucy5jb25maWcgJiYgb3B0aW9ucy5jb25maWcuc3VwcG9ydEJpZ051bWJlcnM7XG4gIHRoaXMuX2J1ZmZlciAgICAgICAgICAgID0gbmV3IEJ1ZmZlcigwKTtcbiAgdGhpcy5fbG9uZ1BhY2tldEJ1ZmZlcnMgPSBbXTtcbiAgdGhpcy5fb2Zmc2V0ICAgICAgICAgICAgPSAwO1xuICB0aGlzLl9wYWNrZXRFbmQgICAgICAgICA9IG51bGw7XG4gIHRoaXMuX3BhY2tldEhlYWRlciAgICAgID0gbnVsbDtcbiAgdGhpcy5fcGFja2V0T2Zmc2V0ICAgICAgPSBudWxsO1xuICB0aGlzLl9vbkVycm9yICAgICAgICAgICA9IG9wdGlvbnMub25FcnJvciB8fCBmdW5jdGlvbihlcnIpIHsgdGhyb3cgZXJyOyB9O1xuICB0aGlzLl9vblBhY2tldCAgICAgICAgICA9IG9wdGlvbnMub25QYWNrZXQgfHwgZnVuY3Rpb24oKSB7fTtcbiAgdGhpcy5fbmV4dFBhY2tldE51bWJlciAgPSAwO1xuICB0aGlzLl9lbmNvZGluZyAgICAgICAgICA9ICd1dGYtOCc7XG4gIHRoaXMuX3BhdXNlZCAgICAgICAgICAgID0gZmFsc2U7XG59XG5cblBhcnNlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdGhpcy5hcHBlbmQoYnVmZmVyKTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3BhY2tldEhlYWRlcikge1xuICAgICAgaWYgKHRoaXMuX2J5dGVzUmVtYWluaW5nKCkgPCA0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wYWNrZXRIZWFkZXIgPSBuZXcgUGFja2V0SGVhZGVyKFxuICAgICAgICB0aGlzLnBhcnNlVW5zaWduZWROdW1iZXIoMyksXG4gICAgICAgIHRoaXMucGFyc2VVbnNpZ25lZE51bWJlcigxKVxuICAgICAgKTtcblxuICAgICAgaWYgKHRoaXMuX3BhY2tldEhlYWRlci5udW1iZXIgIT09IHRoaXMuX25leHRQYWNrZXROdW1iZXIpIHtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnUGFja2V0cyBvdXQgb2Ygb3JkZXIuIEdvdDogJyArIHRoaXMuX3BhY2tldEhlYWRlci5udW1iZXIgKyAnICcgK1xuICAgICAgICAgICdFeHBlY3RlZDogJyArIHRoaXMuX25leHRQYWNrZXROdW1iZXJcbiAgICAgICAgKTtcblxuICAgICAgICBlcnIuY29kZSAgPSAnUFJPVE9DT0xfUEFDS0VUU19PVVRfT0ZfT1JERVInO1xuICAgICAgICBlcnIuZmF0YWwgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX29uRXJyb3IoZXJyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbmNyZW1lbnRQYWNrZXROdW1iZXIoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYnl0ZXNSZW1haW5pbmcoKSA8IHRoaXMuX3BhY2tldEhlYWRlci5sZW5ndGgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX3BhY2tldEVuZCAgICA9IHRoaXMuX29mZnNldCArIHRoaXMuX3BhY2tldEhlYWRlci5sZW5ndGg7XG4gICAgdGhpcy5fcGFja2V0T2Zmc2V0ID0gdGhpcy5fb2Zmc2V0O1xuXG4gICAgaWYgKHRoaXMuX3BhY2tldEhlYWRlci5sZW5ndGggPT09IE1BWF9QQUNLRVRfTEVOR1RIKSB7XG4gICAgICB0aGlzLl9sb25nUGFja2V0QnVmZmVycy5wdXNoKHRoaXMuX2J1ZmZlci5zbGljZSh0aGlzLl9wYWNrZXRPZmZzZXQsIHRoaXMuX3BhY2tldEVuZCkpO1xuXG4gICAgICB0aGlzLl9hZHZhbmNlVG9OZXh0UGFja2V0KCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0aGlzLl9jb21iaW5lTG9uZ1BhY2tldEJ1ZmZlcnMoKTtcblxuICAgIC8vIFRyeS4uLmZpbmFsbHkgdG8gZW5zdXJlIGV4Y2VwdGlvbiBzYWZldHkuIFVuZm9ydHVuYXRlbHkgdGhpcyBpcyBjb3N0aW5nXG4gICAgLy8gdXMgdXAgdG8gfjEwJSBwZXJmb3JtYW5jZSBpbiBzb21lIGJlbmNobWFya3MuXG4gICAgdmFyIGhhZEV4Y2VwdGlvbiA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX29uUGFja2V0KHRoaXMuX3BhY2tldEhlYWRlcik7XG4gICAgICBoYWRFeGNlcHRpb24gPSBmYWxzZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghZXJyIHx8IHR5cGVvZiBlcnIuY29kZSAhPT0gJ3N0cmluZycgfHwgZXJyLmNvZGUuc3Vic3RyKDAsIDcpICE9PSAnUEFSU0VSXycpIHtcbiAgICAgICAgLy8gUmV0aHJvdyB1bmtub3duIGVycm9yc1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG5cbiAgICAgIC8vIFBhc3MgZG93biBwYXJzZXIgZXJyb3JzXG4gICAgICB0aGlzLl9vbkVycm9yKGVycik7XG4gICAgICBoYWRFeGNlcHRpb24gPSBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fYWR2YW5jZVRvTmV4dFBhY2tldCgpO1xuXG4gICAgICAvLyBJZiB3ZSBoYWQgYW4gZXhjZXB0aW9uLCB0aGUgcGFyc2VyIHdoaWxlIGxvb3Agd2lsbCBiZSBicm9rZW4gb3V0XG4gICAgICAvLyBvZiBhZnRlciB0aGUgZmluYWxseSBibG9jay4gU28gd2UgbmVlZCB0byBtYWtlIHN1cmUgdG8gcmUtZW50ZXIgaXRcbiAgICAgIC8vIHRvIGNvbnRpbnVlIHBhcnNpbmcgYW55IGJ5dGVzIHRoYXQgbWF5IGFscmVhZHkgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICAgICAgaWYgKGhhZEV4Y2VwdGlvbikge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKHRoaXMud3JpdGUuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChjaHVuaykge1xuICBpZiAoIWNodW5rIHx8IGNodW5rLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBidWZmZXIgICAgICA9IGNodW5rO1xuICB2YXIgc2xpY2VFbmQgICAgPSB0aGlzLl9idWZmZXIubGVuZ3RoO1xuICB2YXIgc2xpY2VTdGFydCAgPSB0aGlzLl9wYWNrZXRPZmZzZXQgPT09IG51bGxcbiAgICA/IHRoaXMuX29mZnNldFxuICAgIDogdGhpcy5fcGFja2V0T2Zmc2V0O1xuICB2YXIgc2xpY2VMZW5ndGggPSBzbGljZUVuZCAtIHNsaWNlU3RhcnQ7XG5cbiAgaWYgKHNsaWNlTGVuZ3RoICE9PSAwKSB7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IEJ1ZmZlclxuICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXIoc2xpY2VMZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuXG4gICAgLy8gQ29weSBkYXRhXG4gICAgdGhpcy5fYnVmZmVyLmNvcHkoYnVmZmVyLCAwLCBzbGljZVN0YXJ0LCBzbGljZUVuZCk7XG4gICAgY2h1bmsuY29weShidWZmZXIsIHNsaWNlTGVuZ3RoKTtcbiAgfVxuXG4gIC8vIEFkanVzdCBkYXRhLXRyYWNraW5nIHBvaW50ZXJzXG4gIHRoaXMuX2J1ZmZlciAgICAgICA9IGJ1ZmZlcjtcbiAgdGhpcy5fb2Zmc2V0ICAgICAgID0gdGhpcy5fb2Zmc2V0IC0gc2xpY2VTdGFydDtcbiAgdGhpcy5fcGFja2V0RW5kICAgID0gdGhpcy5fcGFja2V0RW5kICE9PSBudWxsXG4gICAgPyB0aGlzLl9wYWNrZXRFbmQgLSBzbGljZVN0YXJ0XG4gICAgOiBudWxsO1xuICB0aGlzLl9wYWNrZXRPZmZzZXQgPSB0aGlzLl9wYWNrZXRPZmZzZXQgIT09IG51bGxcbiAgICA/IHRoaXMuX3BhY2tldE9mZnNldCAtIHNsaWNlU3RhcnRcbiAgICA6IG51bGw7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3BhdXNlZCA9IHRydWU7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblxuICAvLyBuZXh0VGljaygpIHRvIGF2b2lkIGVudGVyaW5nIHdyaXRlKCkgbXVsdGlwbGUgdGltZXMgd2l0aGluIHRoZSBzYW1lIHN0YWNrXG4gIC8vIHdoaWNoIHdvdWxkIGNhdXNlIHByb2JsZW1zIGFzIHdyaXRlIG1hbmlwdWxhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgb2JqZWN0LlxuICBwcm9jZXNzLm5leHRUaWNrKHRoaXMud3JpdGUuYmluZCh0aGlzKSk7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBlYWsgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2J1ZmZlclt0aGlzLl9vZmZzZXRdO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVuc2lnbmVkTnVtYmVyID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgaWYgKGJ5dGVzID09PSAxKSB7XG4gICAgcmV0dXJuIHRoaXMuX2J1ZmZlclt0aGlzLl9vZmZzZXQrK107XG4gIH1cblxuICB2YXIgYnVmZmVyID0gdGhpcy5fYnVmZmVyO1xuICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0ICsgYnl0ZXMgLSAxO1xuICB2YXIgdmFsdWUgID0gMDtcblxuICBpZiAoYnl0ZXMgPiA0KSB7XG4gICAgdmFyIGVyciAgICA9IG5ldyBFcnJvcigncGFyc2VVbnNpZ25lZE51bWJlcjogU3VwcG9ydHMgb25seSB1cCB0byA0IGJ5dGVzJyk7XG4gICAgZXJyLm9mZnNldCA9ICh0aGlzLl9vZmZzZXQgLSB0aGlzLl9wYWNrZXRPZmZzZXQgLSAxKTtcbiAgICBlcnIuY29kZSAgID0gJ1BBUlNFUl9VTlNJR05FRF9UT09fTE9ORyc7XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgd2hpbGUgKG9mZnNldCA+PSB0aGlzLl9vZmZzZXQpIHtcbiAgICB2YWx1ZSA9ICgodmFsdWUgPDwgOCkgfCBidWZmZXJbb2Zmc2V0XSkgPj4+IDA7XG4gICAgb2Zmc2V0LS07XG4gIH1cblxuICB0aGlzLl9vZmZzZXQgKz0gYnl0ZXM7XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxlbmd0aENvZGVkU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLnBhcnNlTGVuZ3RoQ29kZWROdW1iZXIoKTtcblxuICBpZiAobGVuZ3RoID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gdGhpcy5wYXJzZVN0cmluZyhsZW5ndGgpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxlbmd0aENvZGVkQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLnBhcnNlTGVuZ3RoQ29kZWROdW1iZXIoKTtcblxuICBpZiAobGVuZ3RoID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gdGhpcy5wYXJzZUJ1ZmZlcihsZW5ndGgpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxlbmd0aENvZGVkTnVtYmVyID0gZnVuY3Rpb24gcGFyc2VMZW5ndGhDb2RlZE51bWJlcigpIHtcbiAgaWYgKHRoaXMuX29mZnNldCA+PSB0aGlzLl9idWZmZXIubGVuZ3RoKSB7XG4gICAgdmFyIGVyciAgICA9IG5ldyBFcnJvcignUGFyc2VyOiByZWFkIHBhc3QgZW5kJyk7XG4gICAgZXJyLm9mZnNldCA9ICh0aGlzLl9vZmZzZXQgLSB0aGlzLl9wYWNrZXRPZmZzZXQpO1xuICAgIGVyci5jb2RlICAgPSAnUEFSU0VSX1JFQURfUEFTVF9FTkQnO1xuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIHZhciBiaXRzID0gdGhpcy5fYnVmZmVyW3RoaXMuX29mZnNldCsrXTtcblxuICBpZiAoYml0cyA8PSAyNTApIHtcbiAgICByZXR1cm4gYml0cztcbiAgfVxuXG4gIHN3aXRjaCAoYml0cykge1xuICAgIGNhc2UgMjUxOlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAyNTI6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVVuc2lnbmVkTnVtYmVyKDIpO1xuICAgIGNhc2UgMjUzOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VVbnNpZ25lZE51bWJlcigzKTtcbiAgICBjYXNlIDI1NDpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyICAgID0gbmV3IEVycm9yKCdVbmV4cGVjdGVkIGZpcnN0IGJ5dGUnICsgKGJpdHMgPyAnOiAweCcgKyBiaXRzLnRvU3RyaW5nKDE2KSA6ICcnKSk7XG4gICAgICBlcnIub2Zmc2V0ID0gKHRoaXMuX29mZnNldCAtIHRoaXMuX3BhY2tldE9mZnNldCAtIDEpO1xuICAgICAgZXJyLmNvZGUgICA9ICdQQVJTRVJfQkFEX0xFTkdUSF9CWVRFJztcbiAgICAgIHRocm93IGVycjtcbiAgfVxuXG4gIHZhciBsb3cgPSB0aGlzLnBhcnNlVW5zaWduZWROdW1iZXIoNCk7XG4gIHZhciBoaWdoID0gdGhpcy5wYXJzZVVuc2lnbmVkTnVtYmVyKDQpO1xuICB2YXIgdmFsdWU7XG5cbiAgaWYgKGhpZ2ggPj4+IDIxKSB7XG4gICAgdmFsdWUgPSAobmV3IEJpZ051bWJlcihsb3cpKS5wbHVzKChuZXcgQmlnTnVtYmVyKE1VTF8zMkJJVCkpLnRpbWVzKGhpZ2gpKS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMuX3N1cHBvcnRCaWdOdW1iZXJzKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGVyciAgICA9IG5ldyBFcnJvcihcbiAgICAgICdwYXJzZUxlbmd0aENvZGVkTnVtYmVyOiBKUyBwcmVjaXNpb24gcmFuZ2UgZXhjZWVkZWQsICcgK1xuICAgICAgJ251bWJlciBpcyA+PSA1MyBiaXQ6IFwiJyArIHZhbHVlICsgJ1wiJ1xuICAgICk7XG4gICAgZXJyLm9mZnNldCA9ICh0aGlzLl9vZmZzZXQgLSB0aGlzLl9wYWNrZXRPZmZzZXQgLSA4KTtcbiAgICBlcnIuY29kZSAgID0gJ1BBUlNFUl9KU19QUkVDSVNJT05fUkFOR0VfRVhDRUVERUQnO1xuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIHZhbHVlID0gbG93ICsgKE1VTF8zMkJJVCAqIGhpZ2gpO1xuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VGaWxsZXIgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgcmV0dXJuIHRoaXMucGFyc2VCdWZmZXIobGVuZ3RoKTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VOdWxsVGVybWluYXRlZEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZW5kICAgICAgPSB0aGlzLl9udWxsQnl0ZU9mZnNldCgpO1xuICB2YXIgdmFsdWUgICAgPSB0aGlzLl9idWZmZXIuc2xpY2UodGhpcy5fb2Zmc2V0LCBlbmQpO1xuICB0aGlzLl9vZmZzZXQgPSBlbmQgKyAxO1xuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZW5kICAgICAgPSB0aGlzLl9udWxsQnl0ZU9mZnNldCgpO1xuICB2YXIgdmFsdWUgICAgPSB0aGlzLl9idWZmZXIudG9TdHJpbmcodGhpcy5fZW5jb2RpbmcsIHRoaXMuX29mZnNldCwgZW5kKTtcbiAgdGhpcy5fb2Zmc2V0ID0gZW5kICsgMTtcblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLl9udWxsQnl0ZU9mZnNldCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0O1xuXG4gIHdoaWxlICh0aGlzLl9idWZmZXJbb2Zmc2V0XSAhPT0gMHgwMCkge1xuICAgIG9mZnNldCsrO1xuXG4gICAgaWYgKG9mZnNldCA+PSB0aGlzLl9idWZmZXIubGVuZ3RoKSB7XG4gICAgICB2YXIgZXJyICAgID0gbmV3IEVycm9yKCdPZmZzZXQgb2YgbnVsbCB0ZXJtaW5hdGVkIHN0cmluZyBub3QgZm91bmQuJyk7XG4gICAgICBlcnIub2Zmc2V0ID0gKHRoaXMuX29mZnNldCAtIHRoaXMuX3BhY2tldE9mZnNldCk7XG4gICAgICBlcnIuY29kZSAgID0gJ1BBUlNFUl9NSVNTSU5HX05VTExfQllURSc7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VQYWNrZXRUZXJtaW5hdGVkU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLl9wYWNrZXRFbmQgLSB0aGlzLl9vZmZzZXQ7XG4gIHJldHVybiB0aGlzLnBhcnNlU3RyaW5nKGxlbmd0aCk7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQnVmZmVyID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gIHZhciByZXNwb25zZSA9IG5ldyBCdWZmZXIobGVuZ3RoKTtcbiAgdGhpcy5fYnVmZmVyLmNvcHkocmVzcG9uc2UsIDAsIHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0ICsgbGVuZ3RoKTtcblxuICB0aGlzLl9vZmZzZXQgKz0gbGVuZ3RoO1xuICByZXR1cm4gcmVzcG9uc2U7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU3RyaW5nID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG4gIHZhciBlbmQgPSBvZmZzZXQgKyBsZW5ndGg7XG4gIHZhciB2YWx1ZSA9IHRoaXMuX2J1ZmZlci50b1N0cmluZyh0aGlzLl9lbmNvZGluZywgb2Zmc2V0LCBlbmQpO1xuXG4gIHRoaXMuX29mZnNldCA9IGVuZDtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUdlb21ldHJ5VmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXMucGFyc2VMZW5ndGhDb2RlZEJ1ZmZlcigpO1xuICB2YXIgb2Zmc2V0ID0gNDtcblxuICBpZiAoYnVmZmVyID09PSBudWxsIHx8wqAhYnVmZmVyLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VHZW9tZXRyeSgpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICB2YXIgYnl0ZU9yZGVyID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpOyBvZmZzZXQgKz0gMTtcbiAgICB2YXIgd2tiVHlwZSA9IGJ5dGVPcmRlcj8gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQpIDogYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgICBzd2l0Y2god2tiVHlwZSkge1xuICAgICAgY2FzZSAxOiAvLyBXS0JQb2ludFxuICAgICAgICB2YXIgeCA9IGJ5dGVPcmRlcj8gYnVmZmVyLnJlYWREb3VibGVMRShvZmZzZXQpIDogYnVmZmVyLnJlYWREb3VibGVCRShvZmZzZXQpOyBvZmZzZXQgKz0gODtcbiAgICAgICAgdmFyIHkgPSBieXRlT3JkZXI/IGJ1ZmZlci5yZWFkRG91YmxlTEUob2Zmc2V0KSA6IGJ1ZmZlci5yZWFkRG91YmxlQkUob2Zmc2V0KTsgb2Zmc2V0ICs9IDg7XG4gICAgICAgIHJlc3VsdCA9IHt4OiB4LCB5OiB5fTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6IC8vIFdLQkxpbmVTdHJpbmdcbiAgICAgICAgdmFyIG51bVBvaW50cyA9IGJ5dGVPcmRlcj8gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQpIDogYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIGZvcih2YXIgaT1udW1Qb2ludHM7aT4wO2ktLSkge1xuICAgICAgICAgIHZhciB4ID0gYnl0ZU9yZGVyPyBidWZmZXIucmVhZERvdWJsZUxFKG9mZnNldCkgOiBidWZmZXIucmVhZERvdWJsZUJFKG9mZnNldCk7IG9mZnNldCArPSA4O1xuICAgICAgICAgIHZhciB5ID0gYnl0ZU9yZGVyPyBidWZmZXIucmVhZERvdWJsZUxFKG9mZnNldCkgOiBidWZmZXIucmVhZERvdWJsZUJFKG9mZnNldCk7IG9mZnNldCArPSA4O1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHt4OiB4LCB5OiB5fSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6IC8vIFdLQlBvbHlnb25cbiAgICAgICAgdmFyIG51bVJpbmdzID0gYnl0ZU9yZGVyPyBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCkgOiBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7IG9mZnNldCArPSA0O1xuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yKHZhciBpPW51bVJpbmdzO2k+MDtpLS0pIHtcbiAgICAgICAgICB2YXIgbnVtUG9pbnRzID0gYnl0ZU9yZGVyPyBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCkgOiBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7IG9mZnNldCArPSA0O1xuICAgICAgICAgIHZhciBsaW5lID0gW107XG4gICAgICAgICAgZm9yKHZhciBqPW51bVBvaW50cztqPjA7ai0tKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGJ5dGVPcmRlcj8gYnVmZmVyLnJlYWREb3VibGVMRShvZmZzZXQpIDogYnVmZmVyLnJlYWREb3VibGVCRShvZmZzZXQpOyBvZmZzZXQgKz0gODtcbiAgICAgICAgICAgIHZhciB5ID0gYnl0ZU9yZGVyPyBidWZmZXIucmVhZERvdWJsZUxFKG9mZnNldCkgOiBidWZmZXIucmVhZERvdWJsZUJFKG9mZnNldCk7IG9mZnNldCArPSA4O1xuICAgICAgICAgICAgbGluZS5wdXNoKHt4OiB4LCB5OiB5fSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OiAvLyBXS0JNdWx0aVBvaW50XG4gICAgICBjYXNlIDU6IC8vIFdLQk11bHRpTGluZVN0cmluZ1xuICAgICAgY2FzZSA2OiAvLyBXS0JNdWx0aVBvbHlnb25cbiAgICAgIGNhc2UgNzogLy8gV0tCR2VvbWV0cnlDb2xsZWN0aW9uXG4gICAgICAgIHZhciBudW0gPSBieXRlT3JkZXI/IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0KSA6IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTsgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yKHZhciBpPW51bTtpPjA7aS0tKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VHZW9tZXRyeSgpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gcGFyc2VHZW9tZXRyeSgpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5yZWFjaGVkUGFja2V0RW5kID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9vZmZzZXQgPT09IHRoaXMuX3BhY2tldEVuZDtcbn07XG5cblBhcnNlci5wcm90b3R5cGUuX2J5dGVzUmVtYWluaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9idWZmZXIubGVuZ3RoIC0gdGhpcy5fb2Zmc2V0O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5pbmNyZW1lbnRQYWNrZXROdW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGN1cnJlbnRQYWNrZXROdW1iZXIgPSB0aGlzLl9uZXh0UGFja2V0TnVtYmVyO1xuICB0aGlzLl9uZXh0UGFja2V0TnVtYmVyID0gKHRoaXMuX25leHRQYWNrZXROdW1iZXIgKyAxKSAlIDI1NjtcblxuICByZXR1cm4gY3VycmVudFBhY2tldE51bWJlcjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucmVzZXRQYWNrZXROdW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fbmV4dFBhY2tldE51bWJlciA9IDA7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhY2tldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbG9uZ1BhY2tldEJ1ZmZlcnMucmVkdWNlKGZ1bmN0aW9uKGxlbmd0aCwgYnVmZmVyKSB7XG4gICAgcmV0dXJuIGxlbmd0aCArIGJ1ZmZlci5sZW5ndGg7XG4gIH0sIHRoaXMuX3BhY2tldEhlYWRlci5sZW5ndGgpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5fY29tYmluZUxvbmdQYWNrZXRCdWZmZXJzID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fbG9uZ1BhY2tldEJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRyYWlsaW5nUGFja2V0Qnl0ZXMgPSB0aGlzLl9idWZmZXIubGVuZ3RoIC0gdGhpcy5fcGFja2V0RW5kO1xuXG4gIHZhciBsZW5ndGggPSB0aGlzLl9sb25nUGFja2V0QnVmZmVycy5yZWR1Y2UoZnVuY3Rpb24obGVuZ3RoLCBidWZmZXIpIHtcbiAgICByZXR1cm4gbGVuZ3RoICsgYnVmZmVyLmxlbmd0aDtcbiAgfSwgdGhpcy5fYnl0ZXNSZW1haW5pbmcoKSk7XG5cbiAgdmFyIGNvbWJpbmVkQnVmZmVyID0gbmV3IEJ1ZmZlcihsZW5ndGgpO1xuXG4gIHZhciBvZmZzZXQgPSB0aGlzLl9sb25nUGFja2V0QnVmZmVycy5yZWR1Y2UoZnVuY3Rpb24ob2Zmc2V0LCBidWZmZXIpIHtcbiAgICBidWZmZXIuY29weShjb21iaW5lZEJ1ZmZlciwgb2Zmc2V0KTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgYnVmZmVyLmxlbmd0aDtcbiAgfSwgMCk7XG5cbiAgdGhpcy5fYnVmZmVyLmNvcHkoY29tYmluZWRCdWZmZXIsIG9mZnNldCwgdGhpcy5fb2Zmc2V0KTtcblxuICB0aGlzLl9idWZmZXIgICAgICAgICAgICA9IGNvbWJpbmVkQnVmZmVyO1xuICB0aGlzLl9sb25nUGFja2V0QnVmZmVycyA9IFtdO1xuICB0aGlzLl9vZmZzZXQgICAgICAgICAgICA9IDA7XG4gIHRoaXMuX3BhY2tldEVuZCAgICAgICAgID0gdGhpcy5fYnVmZmVyLmxlbmd0aCAtIHRyYWlsaW5nUGFja2V0Qnl0ZXM7XG4gIHRoaXMuX3BhY2tldE9mZnNldCAgICAgID0gMDtcbn07XG5cblBhcnNlci5wcm90b3R5cGUuX2FkdmFuY2VUb05leHRQYWNrZXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fb2Zmc2V0ICAgICAgID0gdGhpcy5fcGFja2V0RW5kO1xuICB0aGlzLl9wYWNrZXRIZWFkZXIgPSBudWxsO1xuICB0aGlzLl9wYWNrZXRFbmQgICAgPSBudWxsO1xuICB0aGlzLl9wYWNrZXRPZmZzZXQgPSBudWxsO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL2xpYi9wcm90b2NvbC9QYXJzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBQYWNrZXRIZWFkZXI7XG5mdW5jdGlvbiBQYWNrZXRIZWFkZXIobGVuZ3RoLCBudW1iZXIpIHtcbiAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gIHRoaXMubnVtYmVyID0gbnVtYmVyO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbXlzcWwvbGliL3Byb3RvY29sL1BhY2tldEhlYWRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiEgYmlnbnVtYmVyLmpzIHYyLjAuNyBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWdudW1iZXIuanMvTElDRU5DRSAqL1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgLypcclxuICAgICAgYmlnbnVtYmVyLmpzIHYyLjAuN1xyXG4gICAgICBBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgYXJiaXRyYXJ5LXByZWNpc2lvbiBhcml0aG1ldGljLlxyXG4gICAgICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWdudW1iZXIuanNcclxuICAgICAgQ29weXJpZ2h0IChjKSAyMDE1IE1pY2hhZWwgTWNsYXVnaGxpbiA8TThjaDg4bEBnbWFpbC5jb20+XHJcbiAgICAgIE1JVCBFeHBhdCBMaWNlbmNlXHJcbiAgICAqL1xyXG5cclxuXHJcbiAgICB2YXIgQmlnTnVtYmVyLCBjcnlwdG8sIHBhcnNlTnVtZXJpYyxcclxuICAgICAgICBpc051bWVyaWMgPSAvXi0/KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaSxcclxuICAgICAgICBtYXRoY2VpbCA9IE1hdGguY2VpbCxcclxuICAgICAgICBtYXRoZmxvb3IgPSBNYXRoLmZsb29yLFxyXG4gICAgICAgIG5vdEJvb2wgPSAnIG5vdCBhIGJvb2xlYW4gb3IgYmluYXJ5IGRpZ2l0JyxcclxuICAgICAgICByb3VuZGluZ01vZGUgPSAncm91bmRpbmcgbW9kZScsXHJcbiAgICAgICAgdG9vTWFueURpZ2l0cyA9ICdudW1iZXIgdHlwZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0cycsXHJcbiAgICAgICAgQUxQSEFCRVQgPSAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVokXycsXHJcbiAgICAgICAgQkFTRSA9IDFlMTQsXHJcbiAgICAgICAgTE9HX0JBU0UgPSAxNCxcclxuICAgICAgICBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZiwgICAgICAgICAvLyAyXjUzIC0gMVxyXG4gICAgICAgIC8vIE1BWF9JTlQzMiA9IDB4N2ZmZmZmZmYsICAgICAgICAgICAgICAgICAgIC8vIDJeMzEgLSAxXHJcbiAgICAgICAgUE9XU19URU4gPSBbMSwgMTAsIDEwMCwgMWUzLCAxZTQsIDFlNSwgMWU2LCAxZTcsIDFlOCwgMWU5LCAxZTEwLCAxZTExLCAxZTEyLCAxZTEzXSxcclxuICAgICAgICBTUVJUX0JBU0UgPSAxZTcsXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogVGhlIGxpbWl0IG9uIHRoZSB2YWx1ZSBvZiBERUNJTUFMX1BMQUNFUywgVE9fRVhQX05FRywgVE9fRVhQX1BPUywgTUlOX0VYUCwgTUFYX0VYUCwgYW5kXHJcbiAgICAgICAgICogdGhlIGFyZ3VtZW50cyB0byB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCwgYW5kIHRvUHJlY2lzaW9uLCBiZXlvbmQgd2hpY2ggYW5cclxuICAgICAgICAgKiBleGNlcHRpb24gaXMgdGhyb3duIChpZiBFUlJPUlMgaXMgdHJ1ZSkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTUFYID0gMUU5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhfSU5UMzJcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgQmlnTnVtYmVyIGNvbnN0cnVjdG9yLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhbm90aGVyKGNvbmZpZ09iaikge1xyXG4gICAgICAgIHZhciBkaXYsXHJcblxyXG4gICAgICAgICAgICAvLyBpZCB0cmFja3MgdGhlIGNhbGxlciBmdW5jdGlvbiwgc28gaXRzIG5hbWUgY2FuIGJlIGluY2x1ZGVkIGluIGVycm9yIG1lc3NhZ2VzLlxyXG4gICAgICAgICAgICBpZCA9IDAsXHJcbiAgICAgICAgICAgIFAgPSBCaWdOdW1iZXIucHJvdG90eXBlLFxyXG4gICAgICAgICAgICBPTkUgPSBuZXcgQmlnTnVtYmVyKDEpLFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogRURJVEFCTEUgREVGQVVMVFMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZXMgYmVsb3cgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZXMgc3RhdGVkLlxyXG4gICAgICAgICAgICAgKiBUaGUgdmFsdWVzIGNhbiBhbHNvIGJlIGNoYW5nZWQgYXQgcnVuLXRpbWUgdXNpbmcgQmlnTnVtYmVyLmNvbmZpZy5cclxuICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIG9wZXJhdGlvbnMgaW52b2x2aW5nIGRpdmlzaW9uLlxyXG4gICAgICAgICAgICBERUNJTUFMX1BMQUNFUyA9IDIwLCAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gdGhlIGFib3ZlIGRlY2ltYWwgcGxhY2VzLCBhbmQgd2hlbiB1c2luZ1xyXG4gICAgICAgICAgICAgKiB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCBhbmQgdG9QcmVjaXNpb24sIGFuZCByb3VuZCAoZGVmYXVsdCB2YWx1ZSkuXHJcbiAgICAgICAgICAgICAqIFVQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cclxuICAgICAgICAgICAgICogRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cclxuICAgICAgICAgICAgICogQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAgICAgICAgKiBGTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgICAgICAgICAqIEhBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXHJcbiAgICAgICAgICAgICAqIEhBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgICAgICAgICAgICogSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxyXG4gICAgICAgICAgICAgKiBIQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAgICAgICAgKiBIQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9IDQsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDhcclxuXHJcbiAgICAgICAgICAgIC8vIEVYUE9ORU5USUFMX0FUIDogW1RPX0VYUF9ORUcgLCBUT19FWFBfUE9TXVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBiZW5lYXRoIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgICAgIC8vIE51bWJlciB0eXBlOiAtN1xyXG4gICAgICAgICAgICBUT19FWFBfTkVHID0gLTcsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gLU1BWFxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBhYm92ZSB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAgICAgICAvLyBOdW1iZXIgdHlwZTogMjFcclxuICAgICAgICAgICAgVE9fRVhQX1BPUyA9IDIxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgICAgICAgLy8gUkFOR0UgOiBbTUlOX0VYUCwgTUFYX0VYUF1cclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBtaW5pbXVtIGV4cG9uZW50IHZhbHVlLCBiZW5lYXRoIHdoaWNoIHVuZGVyZmxvdyB0byB6ZXJvIG9jY3Vycy5cclxuICAgICAgICAgICAgLy8gTnVtYmVyIHR5cGU6IC0zMjQgICg1ZS0zMjQpXHJcbiAgICAgICAgICAgIE1JTl9FWFAgPSAtMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLTEgdG8gLU1BWFxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIG1heGltdW0gZXhwb25lbnQgdmFsdWUsIGFib3ZlIHdoaWNoIG92ZXJmbG93IHRvIEluZmluaXR5IG9jY3Vycy5cclxuICAgICAgICAgICAgLy8gTnVtYmVyIHR5cGU6ICAzMDggICgxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOClcclxuICAgICAgICAgICAgLy8gRm9yIE1BWF9FWFAgPiAxZTcsIGUuZy4gbmV3IEJpZ051bWJlcignMWUxMDAwMDAwMDAnKS5wbHVzKDEpIG1heSBiZSBzbG93LlxyXG4gICAgICAgICAgICBNQVhfRVhQID0gMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEgdG8gTUFYXHJcblxyXG4gICAgICAgICAgICAvLyBXaGV0aGVyIEJpZ051bWJlciBFcnJvcnMgYXJlIGV2ZXIgdGhyb3duLlxyXG4gICAgICAgICAgICBFUlJPUlMgPSB0cnVlLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgb3IgZmFsc2VcclxuXHJcbiAgICAgICAgICAgIC8vIENoYW5nZSB0byBpbnRWYWxpZGF0b3JOb0Vycm9ycyBpZiBFUlJPUlMgaXMgZmFsc2UuXHJcbiAgICAgICAgICAgIGlzVmFsaWRJbnQgPSBpbnRWYWxpZGF0b3JXaXRoRXJyb3JzLCAgICAgLy8gaW50VmFsaWRhdG9yV2l0aEVycm9ycy9pbnRWYWxpZGF0b3JOb0Vycm9yc1xyXG5cclxuICAgICAgICAgICAgLy8gV2hldGhlciB0byB1c2UgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiwgaWYgYXZhaWxhYmxlLlxyXG4gICAgICAgICAgICBDUllQVE8gPSBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgb3IgZmFsc2VcclxuXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIFRoZSBtb2R1bG8gbW9kZSB1c2VkIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG1vZHVsdXM6IGEgbW9kIG4uXHJcbiAgICAgICAgICAgICAqIFRoZSBxdW90aWVudCAocSA9IGEgLyBuKSBpcyBjYWxjdWxhdGVkIGFjY29yZGluZyB0byB0aGUgY29ycmVzcG9uZGluZyByb3VuZGluZyBtb2RlLlxyXG4gICAgICAgICAgICAgKiBUaGUgcmVtYWluZGVyIChyKSBpcyBjYWxjdWxhdGVkIGFzOiByID0gYSAtIG4gKiBxLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBVUCAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cclxuICAgICAgICAgICAgICogRE9XTiAgICAgIDEgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aWRlbmQuXHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgIFRoaXMgbW9kdWxvIG1vZGUgaXMgY29tbW9ubHkga25vd24gYXMgJ3RydW5jYXRlZCBkaXZpc2lvbicgYW5kIGlzXHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gKGEgJSBuKSBpbiBKYXZhU2NyaXB0LlxyXG4gICAgICAgICAgICAgKiBGTE9PUiAgICAgMyBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpc29yIChQeXRob24gJSkuXHJcbiAgICAgICAgICAgICAqIEhBTEZfRVZFTiA2IFRoaXMgbW9kdWxvIG1vZGUgaW1wbGVtZW50cyB0aGUgSUVFRSA3NTQgcmVtYWluZGVyIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICAgKiBFVUNMSUQgICAgOSBFdWNsaWRpYW4gZGl2aXNpb24uIHEgPSBzaWduKG4pICogZmxvb3IoYSAvIGFicyhuKSkuXHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgIFRoZSByZW1haW5kZXIgaXMgYWx3YXlzIHBvc2l0aXZlLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBUaGUgdHJ1bmNhdGVkIGRpdmlzaW9uLCBmbG9vcmVkIGRpdmlzaW9uLCBFdWNsaWRpYW4gZGl2aXNpb24gYW5kIElFRUUgNzU0IHJlbWFpbmRlclxyXG4gICAgICAgICAgICAgKiBtb2RlcyBhcmUgY29tbW9ubHkgdXNlZCBmb3IgdGhlIG1vZHVsdXMgb3BlcmF0aW9uLlxyXG4gICAgICAgICAgICAgKiBBbHRob3VnaCB0aGUgb3RoZXIgcm91bmRpbmcgbW9kZXMgY2FuIGFsc28gYmUgdXNlZCwgdGhleSBtYXkgbm90IGdpdmUgdXNlZnVsIHJlc3VsdHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBNT0RVTE9fTU9ERSA9IDEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIHRoZSB0b1Bvd2VyIG9wZXJhdGlvbi5cclxuICAgICAgICAgICAgLy8gSWYgUE9XX1BSRUNJU0lPTiBpcyAwLCB0aGVyZSB3aWxsIGJlIHVubGltaXRlZCBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgICAgICAgIFBPV19QUkVDSVNJT04gPSAxMDAsICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBmb3JtYXQgc3BlY2lmaWNhdGlvbiB1c2VkIGJ5IHRoZSBCaWdOdW1iZXIucHJvdG90eXBlLnRvRm9ybWF0IG1ldGhvZC5cclxuICAgICAgICAgICAgRk9STUFUID0ge1xyXG4gICAgICAgICAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAgICAgICAgICAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAgICAgICAgICAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAgICAgICAgICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgICAgICAgICAgICBmcmFjdGlvbkdyb3VwU2l6ZTogMFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG4gICAgICAgIC8vIENPTlNUUlVDVE9SXHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFRoZSBCaWdOdW1iZXIgY29uc3RydWN0b3IgYW5kIGV4cG9ydGVkIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmlnTnVtYmVyIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIG4ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBBIG51bWVyaWMgdmFsdWUuXHJcbiAgICAgICAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIG4uIEludGVnZXIsIDIgdG8gNjQgaW5jbHVzaXZlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEJpZ051bWJlciggbiwgYiApIHtcclxuICAgICAgICAgICAgdmFyIGMsIGUsIGksIG51bSwgbGVuLCBzdHIsXHJcbiAgICAgICAgICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIC8vIEVuYWJsZSBjb25zdHJ1Y3RvciB1c2FnZSB3aXRob3V0IG5ldy5cclxuICAgICAgICAgICAgaWYgKCAhKCB4IGluc3RhbmNlb2YgQmlnTnVtYmVyICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gJ0JpZ051bWJlcigpIGNvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBuZXc6IHtufSdcclxuICAgICAgICAgICAgICAgIGlmIChFUlJPUlMpIHJhaXNlKCAyNiwgJ2NvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBuZXcnLCBuICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlciggbiwgYiApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyAnbmV3IEJpZ051bWJlcigpIGJhc2Ugbm90IGFuIGludGVnZXI6IHtifSdcclxuICAgICAgICAgICAgLy8gJ25ldyBCaWdOdW1iZXIoKSBiYXNlIG91dCBvZiByYW5nZToge2J9J1xyXG4gICAgICAgICAgICBpZiAoIGIgPT0gbnVsbCB8fCAhaXNWYWxpZEludCggYiwgMiwgNjQsIGlkLCAnYmFzZScgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEdXBsaWNhdGUuXHJcbiAgICAgICAgICAgICAgICBpZiAoIG4gaW5zdGFuY2VvZiBCaWdOdW1iZXIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5zID0gbi5zO1xyXG4gICAgICAgICAgICAgICAgICAgIHguZSA9IG4uZTtcclxuICAgICAgICAgICAgICAgICAgICB4LmMgPSAoIG4gPSBuLmMgKSA/IG4uc2xpY2UoKSA6IG47XHJcbiAgICAgICAgICAgICAgICAgICAgaWQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoICggbnVtID0gdHlwZW9mIG4gPT0gJ251bWJlcicgKSAmJiBuICogMCA9PSAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHgucyA9IDEgLyBuIDwgMCA/ICggbiA9IC1uLCAtMSApIDogMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBpbnRlZ2Vycy5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIG4gPT09IH5+biApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggZSA9IDAsIGkgPSBuOyBpID49IDEwOyBpIC89IDEwLCBlKysgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeC5jID0gW25dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IG4gKyAnJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhaXNOdW1lcmljLnRlc3QoIHN0ciA9IG4gKyAnJyApICkgcmV0dXJuIHBhcnNlTnVtZXJpYyggeCwgc3RyLCBudW0gKTtcclxuICAgICAgICAgICAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PT0gNDUgPyAoIHN0ciA9IHN0ci5zbGljZSgxKSwgLTEgKSA6IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBiID0gYiB8IDA7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBuICsgJyc7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHJldHVybiB2YWx1ZSBpcyByb3VuZGVkIHRvIERFQ0lNQUxfUExBQ0VTIGFzIHdpdGggb3RoZXIgYmFzZXMuXHJcbiAgICAgICAgICAgICAgICAvLyBBbGxvdyBleHBvbmVudGlhbCBub3RhdGlvbiB0byBiZSB1c2VkIHdpdGggYmFzZSAxMCBhcmd1bWVudC5cclxuICAgICAgICAgICAgICAgIGlmICggYiA9PSAxMCApIHtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gbmV3IEJpZ051bWJlciggbiBpbnN0YW5jZW9mIEJpZ051bWJlciA/IG4gOiBzdHIgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm91bmQoIHgsIERFQ0lNQUxfUExBQ0VTICsgeC5lICsgMSwgUk9VTkRJTkdfTU9ERSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEF2b2lkIHBvdGVudGlhbCBpbnRlcnByZXRhdGlvbiBvZiBJbmZpbml0eSBhbmQgTmFOIGFzIGJhc2UgNDQrIHZhbHVlcy5cclxuICAgICAgICAgICAgICAgIC8vIEFueSBudW1iZXIgaW4gZXhwb25lbnRpYWwgZm9ybSB3aWxsIGZhaWwgZHVlIHRvIHRoZSBbRWVdWystXS5cclxuICAgICAgICAgICAgICAgIGlmICggKCBudW0gPSB0eXBlb2YgbiA9PSAnbnVtYmVyJyApICYmIG4gKiAwICE9IDAgfHxcclxuICAgICAgICAgICAgICAgICAgISggbmV3IFJlZ0V4cCggJ14tPycgKyAoIGMgPSAnWycgKyBBTFBIQUJFVC5zbGljZSggMCwgYiApICsgJ10rJyApICtcclxuICAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4nICsgYyArICcpPyQnLGIgPCAzNyA/ICdpJyA6ICcnICkgKS50ZXN0KHN0cikgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpYyggeCwgc3RyLCBudW0sIGIgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobnVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5zID0gMSAvIG4gPCAwID8gKCBzdHIgPSBzdHIuc2xpY2UoMSksIC0xICkgOiAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIEVSUk9SUyAmJiBzdHIucmVwbGFjZSggL14wXFwuMCp8XFwuLywgJycgKS5sZW5ndGggPiAxNSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICduZXcgQmlnTnVtYmVyKCkgbnVtYmVyIHR5cGUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2UoIGlkLCB0b29NYW55RGlnaXRzLCBuICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGxhdGVyIGNoZWNrIGZvciBsZW5ndGggb24gY29udmVydGVkIG51bWJlci5cclxuICAgICAgICAgICAgICAgICAgICBudW0gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT09IDQ1ID8gKCBzdHIgPSBzdHIuc2xpY2UoMSksIC0xICkgOiAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKCBzdHIsIDEwLCBiLCB4LnMgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICAgICAgaWYgKCAoIGUgPSBzdHIuaW5kZXhPZignLicpICkgPiAtMSApIHN0ciA9IHN0ci5yZXBsYWNlKCAnLicsICcnICk7XHJcblxyXG4gICAgICAgICAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xyXG4gICAgICAgICAgICBpZiAoICggaSA9IHN0ci5zZWFyY2goIC9lL2kgKSApID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgZXhwb25lbnQuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGUgPCAwICkgZSA9IGk7XHJcbiAgICAgICAgICAgICAgICBlICs9ICtzdHIuc2xpY2UoIGkgKyAxICk7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKCAwLCBpICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGUgPCAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEludGVnZXIuXHJcbiAgICAgICAgICAgICAgICBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBzdHIuY2hhckNvZGVBdChpKSA9PT0gNDg7IGkrKyApO1xyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgICBmb3IgKCBsZW4gPSBzdHIubGVuZ3RoOyBzdHIuY2hhckNvZGVBdCgtLWxlbikgPT09IDQ4OyApO1xyXG4gICAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoIGksIGxlbiArIDEgKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzdHIpIHtcclxuICAgICAgICAgICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGlzYWxsb3cgbnVtYmVycyB3aXRoIG92ZXIgMTUgc2lnbmlmaWNhbnQgZGlnaXRzIGlmIG51bWJlciB0eXBlLlxyXG4gICAgICAgICAgICAgICAgLy8gJ25ldyBCaWdOdW1iZXIoKSBudW1iZXIgdHlwZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgICAgICAgICAgaWYgKCBudW0gJiYgRVJST1JTICYmIGxlbiA+IDE1ICkgcmFpc2UoIGlkLCB0b29NYW55RGlnaXRzLCB4LnMgKiBuICk7XHJcblxyXG4gICAgICAgICAgICAgICAgZSA9IGUgLSBpIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgICAgICAgICAgICBpZiAoIGUgPiBNQVhfRVhQICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICAgICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGUgPCBNSU5fRVhQICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgICAgICAgICAgIHguYyA9IFsgeC5lID0gMCBdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHguYyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gYmFzZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBlIGlzIHRoZSBiYXNlIDEwIGV4cG9uZW50LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGkgaXMgd2hlcmUgdG8gc2xpY2Ugc3RyIHRvIGdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgY29lZmZpY2llbnQgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9ICggZSArIDEgKSAlIExPR19CQVNFO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggZSA8IDAgKSBpICs9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGkgPCBsZW4gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpKSB4LmMucHVzaCggK3N0ci5zbGljZSggMCwgaSApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBsZW4gLT0gTE9HX0JBU0U7IGkgPCBsZW47ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5jLnB1c2goICtzdHIuc2xpY2UoIGksIGkgKz0gTE9HX0JBU0UgKSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBMT0dfQkFTRSAtIHN0ci5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSAtPSBsZW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGktLTsgc3RyICs9ICcwJyApO1xyXG4gICAgICAgICAgICAgICAgICAgIHguYy5wdXNoKCArc3RyICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgICAgICAgIHguYyA9IFsgeC5lID0gMCBdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8gQ09OU1RSVUNUT1IgUFJPUEVSVElFU1xyXG5cclxuXHJcbiAgICAgICAgQmlnTnVtYmVyLmFub3RoZXIgPSBhbm90aGVyO1xyXG5cclxuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfVVAgPSAwO1xyXG4gICAgICAgIEJpZ051bWJlci5ST1VORF9ET1dOID0gMTtcclxuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfQ0VJTCA9IDI7XHJcbiAgICAgICAgQmlnTnVtYmVyLlJPVU5EX0ZMT09SID0gMztcclxuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9VUCA9IDQ7XHJcbiAgICAgICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRE9XTiA9IDU7XHJcbiAgICAgICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRVZFTiA9IDY7XHJcbiAgICAgICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfQ0VJTCA9IDc7XHJcbiAgICAgICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRkxPT1IgPSA4O1xyXG4gICAgICAgIEJpZ051bWJlci5FVUNMSUQgPSA5O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBDb25maWd1cmUgaW5mcmVxdWVudGx5LWNoYW5naW5nIGxpYnJhcnktd2lkZSBzZXR0aW5ncy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEFjY2VwdCBhbiBvYmplY3Qgb3IgYW4gYXJndW1lbnQgbGlzdCwgd2l0aCBvbmUgb3IgbWFueSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgb3JcclxuICAgICAgICAgKiBwYXJhbWV0ZXJzIHJlc3BlY3RpdmVseTpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgREVDSU1BTF9QTEFDRVMgIHtudW1iZXJ9ICBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmVcclxuICAgICAgICAgKiAgIFJPVU5ESU5HX01PREUgICB7bnVtYmVyfSAgSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZVxyXG4gICAgICAgICAqICAgRVhQT05FTlRJQUxfQVQgIHtudW1iZXJ8bnVtYmVyW119ICBJbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2ludGVnZXIgLU1BWCB0byAwIGluY2wuLCAwIHRvIE1BWCBpbmNsLl1cclxuICAgICAgICAgKiAgIFJBTkdFICAgICAgICAgICB7bnVtYmVyfG51bWJlcltdfSAgTm9uLXplcm8gaW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpbnRlZ2VyIC1NQVggdG8gLTEgaW5jbC4sIGludGVnZXIgMSB0byBNQVggaW5jbC5dXHJcbiAgICAgICAgICogICBFUlJPUlMgICAgICAgICAge2Jvb2xlYW58bnVtYmVyfSAgIHRydWUsIGZhbHNlLCAxIG9yIDBcclxuICAgICAgICAgKiAgIENSWVBUTyAgICAgICAgICB7Ym9vbGVhbnxudW1iZXJ9ICAgdHJ1ZSwgZmFsc2UsIDEgb3IgMFxyXG4gICAgICAgICAqICAgTU9EVUxPX01PREUgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDkgaW5jbHVzaXZlXHJcbiAgICAgICAgICogICBQT1dfUFJFQ0lTSU9OICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYIGluY2x1c2l2ZVxyXG4gICAgICAgICAqICAgRk9STUFUICAgICAgICAgIHtvYmplY3R9ICAgICAgICAgICBTZWUgQmlnTnVtYmVyLnByb3RvdHlwZS50b0Zvcm1hdFxyXG4gICAgICAgICAqICAgICAgZGVjaW1hbFNlcGFyYXRvciAgICAgICB7c3RyaW5nfVxyXG4gICAgICAgICAqICAgICAgZ3JvdXBTZXBhcmF0b3IgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICAgICAqICAgICAgZ3JvdXBTaXplICAgICAgICAgICAgICB7bnVtYmVyfVxyXG4gICAgICAgICAqICAgICAgc2Vjb25kYXJ5R3JvdXBTaXplICAgICB7bnVtYmVyfVxyXG4gICAgICAgICAqICAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB7c3RyaW5nfVxyXG4gICAgICAgICAqICAgICAgZnJhY3Rpb25Hcm91cFNpemUgICAgICB7bnVtYmVyfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogKFRoZSB2YWx1ZXMgYXNzaWduZWQgdG8gdGhlIGFib3ZlIEZPUk1BVCBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90IGNoZWNrZWQgZm9yIHZhbGlkaXR5LilcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEUuZy5cclxuICAgICAgICAgKiBCaWdOdW1iZXIuY29uZmlnKDIwLCA0KSBpcyBlcXVpdmFsZW50IHRvXHJcbiAgICAgICAgICogQmlnTnVtYmVyLmNvbmZpZyh7IERFQ0lNQUxfUExBQ0VTIDogMjAsIFJPVU5ESU5HX01PREUgOiA0IH0pXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBJZ25vcmUgcHJvcGVydGllcy9wYXJhbWV0ZXJzIHNldCB0byBudWxsIG9yIHVuZGVmaW5lZC5cclxuICAgICAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgY3VycmVudCB2YWx1ZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmlnTnVtYmVyLmNvbmZpZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHYsIHAsXHJcbiAgICAgICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgICAgIHIgPSB7fSxcclxuICAgICAgICAgICAgICAgIGEgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgICAgICAgICBvID0gYVswXSxcclxuICAgICAgICAgICAgICAgIGhhcyA9IG8gJiYgdHlwZW9mIG8gPT0gJ29iamVjdCdcclxuICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7IGlmICggby5oYXNPd25Qcm9wZXJ0eShwKSApIHJldHVybiAoIHYgPSBvW3BdICkgIT0gbnVsbDsgfVxyXG4gICAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uICgpIHsgaWYgKCBhLmxlbmd0aCA+IGkgKSByZXR1cm4gKCB2ID0gYVtpKytdICkgIT0gbnVsbDsgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIERFQ0lNQUxfUExBQ0VTIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIERFQ0lNQUxfUExBQ0VTIG5vdCBhbiBpbnRlZ2VyOiB7dn0nXHJcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBERUNJTUFMX1BMQUNFUyBvdXQgb2YgcmFuZ2U6IHt2fSdcclxuICAgICAgICAgICAgaWYgKCBoYXMoIHAgPSAnREVDSU1BTF9QTEFDRVMnICkgJiYgaXNWYWxpZEludCggdiwgMCwgTUFYLCAyLCBwICkgKSB7XHJcbiAgICAgICAgICAgICAgICBERUNJTUFMX1BMQUNFUyA9IHYgfCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJbcF0gPSBERUNJTUFMX1BMQUNFUztcclxuXHJcbiAgICAgICAgICAgIC8vIFJPVU5ESU5HX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIFJPVU5ESU5HX01PREUgbm90IGFuIGludGVnZXI6IHt2fSdcclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIFJPVU5ESU5HX01PREUgb3V0IG9mIHJhbmdlOiB7dn0nXHJcbiAgICAgICAgICAgIGlmICggaGFzKCBwID0gJ1JPVU5ESU5HX01PREUnICkgJiYgaXNWYWxpZEludCggdiwgMCwgOCwgMiwgcCApICkge1xyXG4gICAgICAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9IHYgfCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJbcF0gPSBST1VORElOR19NT0RFO1xyXG5cclxuICAgICAgICAgICAgLy8gRVhQT05FTlRJQUxfQVQge251bWJlcnxudW1iZXJbXX1cclxuICAgICAgICAgICAgLy8gSW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yIFtpbnRlZ2VyIC1NQVggdG8gMCBpbmNsdXNpdmUsIDAgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBFWFBPTkVOVElBTF9BVCBub3QgYW4gaW50ZWdlcjoge3Z9J1xyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgRVhQT05FTlRJQUxfQVQgb3V0IG9mIHJhbmdlOiB7dn0nXHJcbiAgICAgICAgICAgIGlmICggaGFzKCBwID0gJ0VYUE9ORU5USUFMX0FUJyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaXNBcnJheSh2KSApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGlzVmFsaWRJbnQoIHZbMF0sIC1NQVgsIDAsIDIsIHAgKSAmJiBpc1ZhbGlkSW50KCB2WzFdLCAwLCBNQVgsIDIsIHAgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IHZbMF0gfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBUT19FWFBfUE9TID0gdlsxXSB8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggaXNWYWxpZEludCggdiwgLU1BWCwgTUFYLCAyLCBwICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IC0oIFRPX0VYUF9QT1MgPSAoIHYgPCAwID8gLXYgOiB2ICkgfCAwICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcltwXSA9IFsgVE9fRVhQX05FRywgVE9fRVhQX1BPUyBdO1xyXG5cclxuICAgICAgICAgICAgLy8gUkFOR0Uge251bWJlcnxudW1iZXJbXX0gTm9uLXplcm8gaW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gLTEgaW5jbHVzaXZlLCBpbnRlZ2VyIDEgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBSQU5HRSBub3QgYW4gaW50ZWdlcjoge3Z9J1xyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgUkFOR0UgY2Fubm90IGJlIHplcm86IHt2fSdcclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIFJBTkdFIG91dCBvZiByYW5nZToge3Z9J1xyXG4gICAgICAgICAgICBpZiAoIGhhcyggcCA9ICdSQU5HRScgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGlzQXJyYXkodikgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpc1ZhbGlkSW50KCB2WzBdLCAtTUFYLCAtMSwgMiwgcCApICYmIGlzVmFsaWRJbnQoIHZbMV0sIDEsIE1BWCwgMiwgcCApICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBNSU5fRVhQID0gdlswXSB8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1BWF9FWFAgPSB2WzFdIHwgMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBpc1ZhbGlkSW50KCB2LCAtTUFYLCBNQVgsIDIsIHAgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHYgfCAwICkgTUlOX0VYUCA9IC0oIE1BWF9FWFAgPSAoIHYgPCAwID8gLXYgOiB2ICkgfCAwICk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoRVJST1JTKSByYWlzZSggMiwgcCArICcgY2Fubm90IGJlIHplcm8nLCB2ICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcltwXSA9IFsgTUlOX0VYUCwgTUFYX0VYUCBdO1xyXG5cclxuICAgICAgICAgICAgLy8gRVJST1JTIHtib29sZWFufG51bWJlcn0gdHJ1ZSwgZmFsc2UsIDEgb3IgMC5cclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIEVSUk9SUyBub3QgYSBib29sZWFuIG9yIGJpbmFyeSBkaWdpdDoge3Z9J1xyXG4gICAgICAgICAgICBpZiAoIGhhcyggcCA9ICdFUlJPUlMnICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB2ID09PSAhIXYgfHwgdiA9PT0gMSB8fCB2ID09PSAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkSW50ID0gKCBFUlJPUlMgPSAhIXYgKSA/IGludFZhbGlkYXRvcldpdGhFcnJvcnMgOiBpbnRWYWxpZGF0b3JOb0Vycm9ycztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoRVJST1JTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFpc2UoIDIsIHAgKyBub3RCb29sLCB2ICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcltwXSA9IEVSUk9SUztcclxuXHJcbiAgICAgICAgICAgIC8vIENSWVBUTyB7Ym9vbGVhbnxudW1iZXJ9IHRydWUsIGZhbHNlLCAxIG9yIDAuXHJcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBDUllQVE8gbm90IGEgYm9vbGVhbiBvciBiaW5hcnkgZGlnaXQ6IHt2fSdcclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIGNyeXB0byB1bmF2YWlsYWJsZToge2NyeXB0b30nXHJcbiAgICAgICAgICAgIGlmICggaGFzKCBwID0gJ0NSWVBUTycgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHYgPT09ICEhdiB8fCB2ID09PSAxIHx8IHYgPT09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gISEoIHYgJiYgY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8gPT0gJ29iamVjdCcgKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHYgJiYgIUNSWVBUTyAmJiBFUlJPUlMgKSByYWlzZSggMiwgJ2NyeXB0byB1bmF2YWlsYWJsZScsIGNyeXB0byApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChFUlJPUlMpIHtcclxuICAgICAgICAgICAgICAgICAgICByYWlzZSggMiwgcCArIG5vdEJvb2wsIHYgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByW3BdID0gQ1JZUFRPO1xyXG5cclxuICAgICAgICAgICAgLy8gTU9EVUxPX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA5IGluY2x1c2l2ZS5cclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIE1PRFVMT19NT0RFIG5vdCBhbiBpbnRlZ2VyOiB7dn0nXHJcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBNT0RVTE9fTU9ERSBvdXQgb2YgcmFuZ2U6IHt2fSdcclxuICAgICAgICAgICAgaWYgKCBoYXMoIHAgPSAnTU9EVUxPX01PREUnICkgJiYgaXNWYWxpZEludCggdiwgMCwgOSwgMiwgcCApICkge1xyXG4gICAgICAgICAgICAgICAgTU9EVUxPX01PREUgPSB2IHwgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByW3BdID0gTU9EVUxPX01PREU7XHJcblxyXG4gICAgICAgICAgICAvLyBQT1dfUFJFQ0lTSU9OIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIFBPV19QUkVDSVNJT04gbm90IGFuIGludGVnZXI6IHt2fSdcclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIFBPV19QUkVDSVNJT04gb3V0IG9mIHJhbmdlOiB7dn0nXHJcbiAgICAgICAgICAgIGlmICggaGFzKCBwID0gJ1BPV19QUkVDSVNJT04nICkgJiYgaXNWYWxpZEludCggdiwgMCwgTUFYLCAyLCBwICkgKSB7XHJcbiAgICAgICAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gdiB8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcltwXSA9IFBPV19QUkVDSVNJT047XHJcblxyXG4gICAgICAgICAgICAvLyBGT1JNQVQge29iamVjdH1cclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIEZPUk1BVCBub3QgYW4gb2JqZWN0OiB7dn0nXHJcbiAgICAgICAgICAgIGlmICggaGFzKCBwID0gJ0ZPUk1BVCcgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiB2ID09ICdvYmplY3QnICkge1xyXG4gICAgICAgICAgICAgICAgICAgIEZPUk1BVCA9IHY7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEVSUk9SUykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhaXNlKCAyLCBwICsgJyBub3QgYW4gb2JqZWN0JywgdiApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJbcF0gPSBGT1JNQVQ7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJpZ051bWJlci5tYXggPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXhPck1pbiggYXJndW1lbnRzLCBQLmx0ICk7IH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1pbmltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmlnTnVtYmVyLm1pbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heE9yTWluKCBhcmd1bWVudHMsIFAuZ3QgKTsgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aXRoIGEgcmFuZG9tIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMSxcclxuICAgICAgICAgKiBhbmQgd2l0aCBkcCwgb3IgREVDSU1BTF9QTEFDRVMgaWYgZHAgaXMgb21pdHRlZCwgZGVjaW1hbCBwbGFjZXMgKG9yIGxlc3MgaWYgdHJhaWxpbmdcclxuICAgICAgICAgKiB6ZXJvcyBhcmUgcHJvZHVjZWQpLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogJ3JhbmRvbSgpIGRlY2ltYWwgcGxhY2VzIG5vdCBhbiBpbnRlZ2VyOiB7ZHB9J1xyXG4gICAgICAgICAqICdyYW5kb20oKSBkZWNpbWFsIHBsYWNlcyBvdXQgb2YgcmFuZ2U6IHtkcH0nXHJcbiAgICAgICAgICogJ3JhbmRvbSgpIGNyeXB0byB1bmF2YWlsYWJsZToge2NyeXB0b30nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmlnTnVtYmVyLnJhbmRvbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3cyXzUzID0gMHgyMDAwMDAwMDAwMDAwMDtcclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiBhIDUzIGJpdCBpbnRlZ2VyIG4sIHdoZXJlIDAgPD0gbiA8IDkwMDcxOTkyNTQ3NDA5OTIuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIE1hdGgucmFuZG9tKCkgcHJvZHVjZXMgbW9yZSB0aGFuIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cclxuICAgICAgICAgICAgLy8gSWYgaXQgZG9lcywgYXNzdW1lIGF0IGxlYXN0IDUzIGJpdHMgYXJlIHByb2R1Y2VkLCBvdGhlcndpc2UgYXNzdW1lIGF0IGxlYXN0IDMwIGJpdHMuXHJcbiAgICAgICAgICAgIC8vIDB4NDAwMDAwMDAgaXMgMl4zMCwgMHg4MDAwMDAgaXMgMl4yMywgMHgxZmZmZmYgaXMgMl4yMSAtIDEuXHJcbiAgICAgICAgICAgIHZhciByYW5kb201M2JpdEludCA9IChNYXRoLnJhbmRvbSgpICogcG93Ml81MykgJiAweDFmZmZmZlxyXG4gICAgICAgICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aGZsb29yKCBNYXRoLnJhbmRvbSgpICogcG93Ml81MyApOyB9XHJcbiAgICAgICAgICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoKE1hdGgucmFuZG9tKCkgKiAweDQwMDAwMDAwIHwgMCkgKiAweDgwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgICAoTWF0aC5yYW5kb20oKSAqIDB4ODAwMDAwIHwgMCk7IH07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSwgYiwgZSwgaywgdixcclxuICAgICAgICAgICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgICAgICAgICBjID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgICAgICAgICAgICBkcCA9IGRwID09IG51bGwgfHwgIWlzVmFsaWRJbnQoIGRwLCAwLCBNQVgsIDE0ICkgPyBERUNJTUFMX1BMQUNFUyA6IGRwIHwgMDtcclxuICAgICAgICAgICAgICAgIGsgPSBtYXRoY2VpbCggZHAgLyBMT0dfQkFTRSApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQnJvd3NlcnMgc3VwcG9ydGluZyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyggbmV3IFVpbnQzMkFycmF5KCBrICo9IDIgKSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgazsgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNTMgYml0czpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgKiBNYXRoLnBvdygyLCAyMSkpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTEwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSA+Pj4gMTEpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMHgyMDAwMCBpcyAyXjIxLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGFbaV0gKiAweDIwMDAwICsgKGFbaSArIDFdID4+PiAxMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVqZWN0aW9uIHNhbXBsaW5nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvYmFiaWxpdHkgdGhhdCB2ID49IDllMTUsIGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA3MTk5MjU0NzQwOTkyIC8gOTAwNzE5OTI1NDc0MDk5MiB+PSAwLjAwMDgsIGkuZS4gMSBpbiAxMjUxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHYgPj0gOWUxNSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyggbmV3IFVpbnQzMkFycmF5KDIpICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtpXSA9IGJbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtpICsgMV0gPSBiWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCA8PSB2IDw9IDg5OTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnB1c2goIHYgJSAxZTE0ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBrIC8gMjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm9kZS5qcyBzdXBwb3J0aW5nIGNyeXB0by5yYW5kb21CeXRlcy5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBjcnlwdG8gJiYgY3J5cHRvLnJhbmRvbUJ5dGVzICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoIGsgKj0gNyApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgazsgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAwMDAwIGlzIDJeNDgsIDB4MTAwMDAwMDAwMDAgaXMgMl40MFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAgaXMgMl4zMiwgMHgxMDAwMDAwIGlzIDJeMjRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gKCAoIGFbaV0gJiAzMSApICogMHgxMDAwMDAwMDAwMDAwICkgKyAoIGFbaSArIDFdICogMHgxMDAwMDAwMDAwMCApICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggYVtpICsgMl0gKiAweDEwMDAwMDAwMCApICsgKCBhW2kgKyAzXSAqIDB4MTAwMDAwMCApICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggYVtpICsgNF0gPDwgMTYgKSArICggYVtpICsgNV0gPDwgOCApICsgYVtpICsgNl07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2ID49IDllMTUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3J5cHRvLnJhbmRvbUJ5dGVzKDcpLmNvcHkoIGEsIGkgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMucHVzaCggdiAlIDFlMTQgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IDc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGsgLyA3O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoRVJST1JTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhaXNlKCAxNCwgJ2NyeXB0byB1bmF2YWlsYWJsZScsIGNyeXB0byApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVc2UgTWF0aC5yYW5kb206IENSWVBUTyBpcyBmYWxzZSBvciBjcnlwdG8gaXMgdW5hdmFpbGFibGUgYW5kIEVSUk9SUyBpcyBmYWxzZS5cclxuICAgICAgICAgICAgICAgIGlmICghaSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBrOyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHJhbmRvbTUzYml0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdiA8IDllMTUgKSBjW2krK10gPSB2ICUgMWUxNDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgayA9IGNbLS1pXTtcclxuICAgICAgICAgICAgICAgIGRwICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdHJhaWxpbmcgZGlnaXRzIHRvIHplcm9zIGFjY29yZGluZyB0byBkcC5cclxuICAgICAgICAgICAgICAgIGlmICggayAmJiBkcCApIHtcclxuICAgICAgICAgICAgICAgICAgICB2ID0gUE9XU19URU5bTE9HX0JBU0UgLSBkcF07XHJcbiAgICAgICAgICAgICAgICAgICAgY1tpXSA9IG1hdGhmbG9vciggayAvIHYgKSAqIHY7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvLlxyXG4gICAgICAgICAgICAgICAgZm9yICggOyBjW2ldID09PSAwOyBjLnBvcCgpLCBpLS0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgICAgICAgICAgaWYgKCBpIDwgMCApIHtcclxuICAgICAgICAgICAgICAgICAgICBjID0gWyBlID0gMCBdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8gYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBlID0gLTEgOyBjWzBdID09PSAwOyBjLnNoaWZ0KCksIGUgLT0gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb3VudCB0aGUgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIGMgdG8gZGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MsIGFuZC4uLlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAxLCB2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRqdXN0IHRoZSBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGkgPCBMT0dfQkFTRSApIGUgLT0gTE9HX0JBU0UgLSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJhbmQuZSA9IGU7XHJcbiAgICAgICAgICAgICAgICByYW5kLmMgPSBjO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSkoKTtcclxuXHJcblxyXG4gICAgICAgIC8vIFBSSVZBVEUgRlVOQ1RJT05TXHJcblxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZUluIHRvIGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZU91dC5cclxuICAgICAgICBmdW5jdGlvbiBjb252ZXJ0QmFzZSggc3RyLCBiYXNlT3V0LCBiYXNlSW4sIHNpZ24gKSB7XHJcbiAgICAgICAgICAgIHZhciBkLCBlLCBrLCByLCB4LCB4YywgeSxcclxuICAgICAgICAgICAgICAgIGkgPSBzdHIuaW5kZXhPZiggJy4nICksXHJcbiAgICAgICAgICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgICAgICAgICAgcm0gPSBST1VORElOR19NT0RFO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBiYXNlSW4gPCAzNyApIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gTm9uLWludGVnZXIuXHJcbiAgICAgICAgICAgIGlmICggaSA+PSAwICkge1xyXG4gICAgICAgICAgICAgICAgayA9IFBPV19QUkVDSVNJT047XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVW5saW1pdGVkIHByZWNpc2lvbi5cclxuICAgICAgICAgICAgICAgIFBPV19QUkVDSVNJT04gPSAwO1xyXG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoICcuJywgJycgKTtcclxuICAgICAgICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKGJhc2VJbik7XHJcbiAgICAgICAgICAgICAgICB4ID0geS5wb3coIHN0ci5sZW5ndGggLSBpICk7XHJcbiAgICAgICAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHN0ciBhcyBpZiBhbiBpbnRlZ2VyLCB0aGVuIHJlc3RvcmUgdGhlIGZyYWN0aW9uIHBhcnQgYnkgZGl2aWRpbmcgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyByZXN1bHQgYnkgaXRzIGJhc2UgcmFpc2VkIHRvIGEgcG93ZXIuXHJcbiAgICAgICAgICAgICAgICB5LmMgPSB0b0Jhc2VPdXQoIHRvRml4ZWRQb2ludCggY29lZmZUb1N0cmluZyggeC5jICksIHguZSApLCAxMCwgYmFzZU91dCApO1xyXG4gICAgICAgICAgICAgICAgeS5lID0geS5jLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgbnVtYmVyIGFzIGludGVnZXIuXHJcbiAgICAgICAgICAgIHhjID0gdG9CYXNlT3V0KCBzdHIsIGJhc2VJbiwgYmFzZU91dCApO1xyXG4gICAgICAgICAgICBlID0gayA9IHhjLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgZm9yICggOyB4Y1stLWtdID09IDA7IHhjLnBvcCgpICk7XHJcbiAgICAgICAgICAgIGlmICggIXhjWzBdICkgcmV0dXJuICcwJztcclxuXHJcbiAgICAgICAgICAgIGlmICggaSA8IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAtLWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4LmMgPSB4YztcclxuICAgICAgICAgICAgICAgIHguZSA9IGU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc2lnbiBpcyBuZWVkZWQgZm9yIGNvcnJlY3Qgcm91bmRpbmcuXHJcbiAgICAgICAgICAgICAgICB4LnMgPSBzaWduO1xyXG4gICAgICAgICAgICAgICAgeCA9IGRpdiggeCwgeSwgZHAsIHJtLCBiYXNlT3V0ICk7XHJcbiAgICAgICAgICAgICAgICB4YyA9IHguYztcclxuICAgICAgICAgICAgICAgIHIgPSB4LnI7XHJcbiAgICAgICAgICAgICAgICBlID0geC5lO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBkID0gZSArIGRwICsgMTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSByb3VuZGluZyBkaWdpdCwgaS5lLiB0aGUgZGlnaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgICAgICBpID0geGNbZF07XHJcbiAgICAgICAgICAgIGsgPSBiYXNlT3V0IC8gMjtcclxuICAgICAgICAgICAgciA9IHIgfHwgZCA8IDAgfHwgeGNbZCArIDFdICE9IG51bGw7XHJcblxyXG4gICAgICAgICAgICByID0gcm0gPCA0ID8gKCBpICE9IG51bGwgfHwgciApICYmICggcm0gPT0gMCB8fCBybSA9PSAoIHgucyA8IDAgPyAzIDogMiApIClcclxuICAgICAgICAgICAgICAgICAgICAgICA6IGkgPiBrIHx8IGkgPT0gayAmJiggcm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiYgeGNbZCAtIDFdICYgMSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgcm0gPT0gKCB4LnMgPCAwID8gOCA6IDcgKSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBkIDwgMSB8fCAheGNbMF0gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMV4tZHAgb3IgMC5cclxuICAgICAgICAgICAgICAgIHN0ciA9IHIgPyB0b0ZpeGVkUG9pbnQoICcxJywgLWRwICkgOiAnMCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4Yy5sZW5ndGggPSBkO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJvdW5kaW5nIHVwIG1heSBtZWFuIHRoZSBwcmV2aW91cyBkaWdpdCBoYXMgdG8gYmUgcm91bmRlZCB1cCBhbmQgc28gb24uXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggLS1iYXNlT3V0OyArK3hjWy0tZF0gPiBiYXNlT3V0OyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGNbZF0gPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhZCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhjLnVuc2hpZnQoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAgICAgZm9yICggayA9IHhjLmxlbmd0aDsgIXhjWy0ta107ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRS5nLiBbNCwgMTEsIDE1XSBiZWNvbWVzIDRiZi5cclxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwLCBzdHIgPSAnJzsgaSA8PSBrOyBzdHIgKz0gQUxQSEFCRVQuY2hhckF0KCB4Y1tpKytdICkgKTtcclxuICAgICAgICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludCggc3RyLCBlICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBjYWxsZXIgd2lsbCBhZGQgdGhlIHNpZ24uXHJcbiAgICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8gUGVyZm9ybSBkaXZpc2lvbiBpbiB0aGUgc3BlY2lmaWVkIGJhc2UuIENhbGxlZCBieSBkaXYgYW5kIGNvbnZlcnRCYXNlLlxyXG4gICAgICAgIGRpdiA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBBc3N1bWUgbm9uLXplcm8geCBhbmQgay5cclxuICAgICAgICAgICAgZnVuY3Rpb24gbXVsdGlwbHkoIHgsIGssIGJhc2UgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSwgdGVtcCwgeGxvLCB4aGksXHJcbiAgICAgICAgICAgICAgICAgICAgY2FycnkgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGkgPSB4Lmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBrbG8gPSBrICUgU1FSVF9CQVNFLFxyXG4gICAgICAgICAgICAgICAgICAgIGtoaSA9IGsgLyBTUVJUX0JBU0UgfCAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHggPSB4LnNsaWNlKCk7IGktLTsgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeGxvID0geFtpXSAlIFNRUlRfQkFTRTtcclxuICAgICAgICAgICAgICAgICAgICB4aGkgPSB4W2ldIC8gU1FSVF9CQVNFIHwgMDtcclxuICAgICAgICAgICAgICAgICAgICBtID0ga2hpICogeGxvICsgeGhpICoga2xvO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXAgPSBrbG8gKiB4bG8gKyAoICggbSAlIFNRUlRfQkFTRSApICogU1FSVF9CQVNFICkgKyBjYXJyeTtcclxuICAgICAgICAgICAgICAgICAgICBjYXJyeSA9ICggdGVtcCAvIGJhc2UgfCAwICkgKyAoIG0gLyBTUVJUX0JBU0UgfCAwICkgKyBraGkgKiB4aGk7XHJcbiAgICAgICAgICAgICAgICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjYXJyeSkgeC51bnNoaWZ0KGNhcnJ5KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gY29tcGFyZSggYSwgYiwgYUwsIGJMICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGksIGNtcDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGFMICE9IGJMICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNtcCA9IGFMID4gYkwgPyAxIDogLTE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gY21wID0gMDsgaSA8IGFMOyBpKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGFbaV0gIT0gYltpXSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtcCA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdWJ0cmFjdCggYSwgYiwgYUwsIGJhc2UgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgYiBmcm9tIGEuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGFMLS07ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFbYUxdIC09IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICBhW2FMXSA9IGkgKiBiYXNlICsgYVthTF0gLSBiW2FMXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAgIGZvciAoIDsgIWFbMF0gJiYgYS5sZW5ndGggPiAxOyBhLnNoaWZ0KCkgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8geDogZGl2aWRlbmQsIHk6IGRpdmlzb3IuXHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHgsIHksIGRwLCBybSwgYmFzZSApIHtcclxuICAgICAgICAgICAgICAgIHZhciBjbXAsIGUsIGksIG1vcmUsIG4sIHByb2QsIHByb2RMLCBxLCBxYywgcmVtLCByZW1MLCByZW0wLCB4aSwgeEwsIHljMCxcclxuICAgICAgICAgICAgICAgICAgICB5TCwgeXosXHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IHgucyA9PSB5LnMgPyAxIDogLTEsXHJcbiAgICAgICAgICAgICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICAgICAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRWl0aGVyIE5hTiwgSW5maW5pdHkgb3IgMD9cclxuICAgICAgICAgICAgICAgIGlmICggIXhjIHx8ICF4Y1swXSB8fCAheWMgfHwgIXljWzBdICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBOYU4sIG9yIGJvdGggSW5maW5pdHkgb3IgMC5cclxuICAgICAgICAgICAgICAgICAgICAgICF4LnMgfHwgIXkucyB8fCAoIHhjID8geWMgJiYgeGNbMF0gPT0geWNbMF0gOiAheWMgKSA/IE5hTiA6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIHggaXMgwrEwIG9yIHkgaXMgwrFJbmZpbml0eSwgb3IgcmV0dXJuIMKxSW5maW5pdHkgYXMgeSBpcyDCsTAuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhjICYmIHhjWzBdID09IDAgfHwgIXljID8gcyAqIDAgOiBzIC8gMFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcSA9IG5ldyBCaWdOdW1iZXIocyk7XHJcbiAgICAgICAgICAgICAgICBxYyA9IHEuYyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZSA9IHguZSAtIHkuZTtcclxuICAgICAgICAgICAgICAgIHMgPSBkcCArIGUgKyAxO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggIWJhc2UgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgICAgICAgICAgICAgICAgZSA9IGJpdEZsb29yKCB4LmUgLyBMT0dfQkFTRSApIC0gYml0Rmxvb3IoIHkuZSAvIExPR19CQVNFICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IHMgLyBMT0dfQkFTRSB8IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVzdWx0IGV4cG9uZW50IG1heSBiZSBvbmUgbGVzcyB0aGVuIHRoZSBjdXJyZW50IHZhbHVlIG9mIGUuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgY29lZmZpY2llbnRzIG9mIHRoZSBCaWdOdW1iZXJzIGZyb20gY29udmVydEJhc2UgbWF5IGhhdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgeWNbaV0gPT0gKCB4Y1tpXSB8fCAwICk7IGkrKyApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCB5Y1tpXSA+ICggeGNbaV0gfHwgMCApICkgZS0tO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggcyA8IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcWMucHVzaCgxKTtcclxuICAgICAgICAgICAgICAgICAgICBtb3JlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcyArPSAyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWxpc2UgeGMgYW5kIHljIHNvIGhpZ2hlc3Qgb3JkZXIgZGlnaXQgb2YgeWMgaXMgPj0gYmFzZSAvIDIuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBtYXRoZmxvb3IoIGJhc2UgLyAoIHljWzBdICsgMSApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBoYW5kbGUgb2RkIGJhc2VzIHdoZXJlIHljWzBdID09ICggYmFzZSAvIDIgKSAtIDEuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKCBuID4gMSB8fCBuKysgPT0gMSAmJiB5Y1swXSA8IGJhc2UgLyAyICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggbiA+IDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHljID0gbXVsdGlwbHkoIHljLCBuLCBiYXNlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhjID0gbXVsdGlwbHkoIHhjLCBuLCBiYXNlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHhpID0geUw7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtID0geGMuc2xpY2UoIDAsIHlMICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB6ZXJvcyB0byBtYWtlIHJlbWFpbmRlciBhcyBsb25nIGFzIGRpdmlzb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyByZW1MIDwgeUw7IHJlbVtyZW1MKytdID0gMCApO1xyXG4gICAgICAgICAgICAgICAgICAgIHl6ID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB5ei51bnNoaWZ0KDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHljMCA9IHljWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggeWNbMV0gPj0gYmFzZSAvIDIgKSB5YzArKztcclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gcHJldmVudCB0cmlhbCBkaWdpdCBuID4gYmFzZSwgd2hlbiB1c2luZyBiYXNlIDMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpZiAoIGJhc2UgPT0gMyAmJiB5YzAgPT0gMSApIHljMCA9IDEgKyAxZS0xNTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbXAgPSBjb21wYXJlKCB5YywgcmVtLCB5TCwgcmVtTCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjbXAgPCAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0cmlhbCBkaWdpdCwgbi5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW0wID0gcmVtWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB5TCAhPSByZW1MICkgcmVtMCA9IHJlbTAgKiBiYXNlICsgKCByZW1bMV0gfHwgMCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG4gaXMgaG93IG1hbnkgdGltZXMgdGhlIGRpdmlzb3IgZ29lcyBpbnRvIHRoZSBjdXJyZW50IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBtYXRoZmxvb3IoIHJlbTAgLyB5YzAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgQWxnb3JpdGhtOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDEuIHByb2R1Y3QgPSBkaXZpc29yICogdHJpYWwgZGlnaXQgKG4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgMi4gaWYgcHJvZHVjdCA+IHJlbWFpbmRlcjogcHJvZHVjdCAtPSBkaXZpc29yLCBuLS1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAzLiByZW1haW5kZXIgLT0gcHJvZHVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDQuIGlmIHByb2R1Y3Qgd2FzIDwgcmVtYWluZGVyIGF0IDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICA1LiBjb21wYXJlIG5ldyByZW1haW5kZXIgYW5kIGRpdmlzb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIDYuIElmIHJlbWFpbmRlciA+IGRpdmlzb3I6IHJlbWFpbmRlciAtPSBkaXZpc29yLCBuKytcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG4gPiAxICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuIG1heSBiZSA+IGJhc2Ugb25seSB3aGVuIGJhc2UgaXMgMy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobiA+PSBiYXNlKSBuID0gYmFzZSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yICogdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZCA9IG11bHRpcGx5KCB5YywgbiwgYmFzZSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3QgPiByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpYWwgZGlnaXQgbiB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGhpZ2ggYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCBpcyBub3Qga25vd24gdG8gaGF2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZXIgYmVlbiBtb3JlIHRoYW4gMSB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGNvbXBhcmUoIHByb2QsIHJlbSwgcHJvZEwsIHJlbUwgKSA9PSAxICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLS07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VidHJhY3QoIHByb2QsIHlMIDwgcHJvZEwgPyB5eiA6IHljLCBwcm9kTCwgYmFzZSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbXAgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG4gaXMgMCBvciAxLCBjbXAgaXMgLTEuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAwLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNvbXBhcmUgeWMgYW5kIHJlbSBhZ2FpbiBiZWxvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBjaGFuZ2UgY21wIHRvIDEgdG8gYXZvaWQgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAxLCBsZWF2ZSBjbXAgYXMgLTEsIHNvIHljIGFuZCByZW0gYXJlIGNvbXBhcmVkIGFnYWluLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbiA9PSAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGl2aXNvciA8IHJlbWFpbmRlciwgc28gbiBtdXN0IGJlIGF0IGxlYXN0IDEuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtcCA9IG4gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcHJvZEwgPCByZW1MICkgcHJvZC51bnNoaWZ0KDApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0cmFjdCggcmVtLCBwcm9kLCByZW1MLCBiYXNlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNtcCA9PSAtMSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCBuZXcgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCBuZXcgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyaWFsIGRpZ2l0IG4gdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGxvdyBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIHZlcnkgcmFyZWx5IDIgdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGNvbXBhcmUoIHljLCByZW0sIHlMLCByZW1MICkgPCAxICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuKys7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0cmFjdCggcmVtLCB5TCA8IHJlbUwgPyB5eiA6IHljLCByZW1MLCBiYXNlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggY21wID09PSAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbisrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtID0gWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IC8vIGVsc2UgY21wID09PSAxIGFuZCBuIHdpbGwgYmUgMFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXh0IGRpZ2l0LCBuLCB0byB0aGUgcmVzdWx0IGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxY1tpKytdID0gbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJlbVswXSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbVtyZW1MKytdID0geGNbeGldIHx8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW0gPSBbIHhjW3hpXSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtTCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICggKCB4aSsrIDwgeEwgfHwgcmVtWzBdICE9IG51bGwgKSAmJiBzLS0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbW9yZSA9IHJlbVswXSAhPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm8/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhcWNbMF0gKSBxYy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggYmFzZSA9PSBCQVNFICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUbyBjYWxjdWxhdGUgcS5lLCBmaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgcWNbMF0uXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDEsIHMgPSBxY1swXTsgcyA+PSAxMDsgcyAvPSAxMCwgaSsrICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcm91bmQoIHEsIGRwICsgKCBxLmUgPSBpICsgZSAqIExPR19CQVNFIC0gMSApICsgMSwgcm0sIG1vcmUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYWxsZXIgaXMgY29udmVydEJhc2UuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHEuZSA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcS5yID0gK21vcmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSkoKTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyIG4gaW4gZml4ZWQtcG9pbnQgb3IgZXhwb25lbnRpYWxcclxuICAgICAgICAgKiBub3RhdGlvbiByb3VuZGVkIHRvIHRoZSBzcGVjaWZpZWQgZGVjaW1hbCBwbGFjZXMgb3Igc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogbiBpcyBhIEJpZ051bWJlci5cclxuICAgICAgICAgKiBpIGlzIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBkaWdpdCByZXF1aXJlZCAoaS5lLiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cCkuXHJcbiAgICAgICAgICogcm0gaXMgdGhlIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgICAgICogY2FsbGVyIGlzIGNhbGxlciBpZDogdG9FeHBvbmVudGlhbCAxOSwgdG9GaXhlZCAyMCwgdG9Gb3JtYXQgMjEsIHRvUHJlY2lzaW9uIDI0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGZvcm1hdCggbiwgaSwgcm0sIGNhbGxlciApIHtcclxuICAgICAgICAgICAgdmFyIGMwLCBlLCBuZSwgbGVuLCBzdHI7XHJcblxyXG4gICAgICAgICAgICBybSA9IHJtICE9IG51bGwgJiYgaXNWYWxpZEludCggcm0sIDAsIDgsIGNhbGxlciwgcm91bmRpbmdNb2RlIClcclxuICAgICAgICAgICAgICA/IHJtIHwgMCA6IFJPVU5ESU5HX01PREU7XHJcblxyXG4gICAgICAgICAgICBpZiAoICFuLmMgKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjMCA9IG4uY1swXTtcclxuICAgICAgICAgICAgbmUgPSBuLmU7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGkgPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcoIG4uYyApO1xyXG4gICAgICAgICAgICAgICAgc3RyID0gY2FsbGVyID09IDE5IHx8IGNhbGxlciA9PSAyNCAmJiBuZSA8PSBUT19FWFBfTkVHXHJcbiAgICAgICAgICAgICAgICAgID8gdG9FeHBvbmVudGlhbCggc3RyLCBuZSApXHJcbiAgICAgICAgICAgICAgICAgIDogdG9GaXhlZFBvaW50KCBzdHIsIG5lICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuID0gcm91bmQoIG5ldyBCaWdOdW1iZXIobiksIGksIHJtICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbi5lIG1heSBoYXZlIGNoYW5nZWQgaWYgdGhlIHZhbHVlIHdhcyByb3VuZGVkIHVwLlxyXG4gICAgICAgICAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgICAgICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKCBuLmMgKTtcclxuICAgICAgICAgICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdG9QcmVjaXNpb24gcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyXHJcbiAgICAgICAgICAgICAgICAvLyBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbi5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFeHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICAgICAgICAgIGlmICggY2FsbGVyID09IDE5IHx8IGNhbGxlciA9PSAyNCAmJiAoIGkgPD0gZSB8fCBlIDw9IFRPX0VYUF9ORUcgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgbGVuIDwgaTsgc3RyICs9ICcwJywgbGVuKysgKTtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSB0b0V4cG9uZW50aWFsKCBzdHIsIGUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaXhlZC1wb2ludCBub3RhdGlvbi5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaSAtPSBuZTtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoIHN0ciwgZSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlICsgMSA+IGxlbiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAtLWkgPiAwICkgZm9yICggc3RyICs9ICcuJzsgaS0tOyBzdHIgKz0gJzAnICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBlIC0gbGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGkgPiAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlICsgMSA9PSBsZW4gKSBzdHIgKz0gJy4nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpLS07IHN0ciArPSAnMCcgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG4ucyA8IDAgJiYgYzAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIEJpZ051bWJlci5tYXggYW5kIEJpZ051bWJlci5taW4uXHJcbiAgICAgICAgZnVuY3Rpb24gbWF4T3JNaW4oIGFyZ3MsIG1ldGhvZCApIHtcclxuICAgICAgICAgICAgdmFyIG0sIG4sXHJcbiAgICAgICAgICAgICAgICBpID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmICggaXNBcnJheSggYXJnc1swXSApICkgYXJncyA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgIG0gPSBuZXcgQmlnTnVtYmVyKCBhcmdzWzBdICk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCA7ICsraSA8IGFyZ3MubGVuZ3RoOyApIHtcclxuICAgICAgICAgICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKCBhcmdzW2ldICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgYW55IG51bWJlciBpcyBOYU4sIHJldHVybiBOYU4uXHJcbiAgICAgICAgICAgICAgICBpZiAoICFuLnMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBtZXRob2QuY2FsbCggbSwgbiApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSBuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIG4gaXMgYW4gaW50ZWdlciBpbiByYW5nZSwgb3RoZXJ3aXNlIHRocm93LlxyXG4gICAgICAgICAqIFVzZSBmb3IgYXJndW1lbnQgdmFsaWRhdGlvbiB3aGVuIEVSUk9SUyBpcyB0cnVlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGludFZhbGlkYXRvcldpdGhFcnJvcnMoIG4sIG1pbiwgbWF4LCBjYWxsZXIsIG5hbWUgKSB7XHJcbiAgICAgICAgICAgIGlmICggbiA8IG1pbiB8fCBuID4gbWF4IHx8IG4gIT0gdHJ1bmNhdGUobikgKSB7XHJcbiAgICAgICAgICAgICAgICByYWlzZSggY2FsbGVyLCAoIG5hbWUgfHwgJ2RlY2ltYWwgcGxhY2VzJyApICtcclxuICAgICAgICAgICAgICAgICAgKCBuIDwgbWluIHx8IG4gPiBtYXggPyAnIG91dCBvZiByYW5nZScgOiAnIG5vdCBhbiBpbnRlZ2VyJyApLCBuICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogU3RyaXAgdHJhaWxpbmcgemVyb3MsIGNhbGN1bGF0ZSBiYXNlIDEwIGV4cG9uZW50IGFuZCBjaGVjayBhZ2FpbnN0IE1JTl9FWFAgYW5kIE1BWF9FWFAuXHJcbiAgICAgICAgICogQ2FsbGVkIGJ5IG1pbnVzLCBwbHVzIGFuZCB0aW1lcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBub3JtYWxpc2UoIG4sIGMsIGUgKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMSxcclxuICAgICAgICAgICAgICAgIGogPSBjLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICAgIGZvciAoIDsgIWNbLS1qXTsgYy5wb3AoKSApO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50LiBGaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgICAgICAgZm9yICggaiA9IGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyApO1xyXG5cclxuICAgICAgICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgICAgICAgIGlmICggKCBlID0gaSArIGUgKiBMT0dfQkFTRSAtIDEgKSA+IE1BWF9FWFAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgICAgICAgICBuLmMgPSBuLmUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBlIDwgTUlOX0VYUCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgICAgICAgbi5jID0gWyBuLmUgPSAwIF07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuLmUgPSBlO1xyXG4gICAgICAgICAgICAgICAgbi5jID0gYztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG47XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIHZhbHVlcyB0aGF0IGZhaWwgdGhlIHZhbGlkaXR5IHRlc3QgaW4gQmlnTnVtYmVyLlxyXG4gICAgICAgIHBhcnNlTnVtZXJpYyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaSxcclxuICAgICAgICAgICAgICAgIGRvdEFmdGVyID0gL14oW14uXSspXFwuJC8sXHJcbiAgICAgICAgICAgICAgICBkb3RCZWZvcmUgPSAvXlxcLihbXi5dKykkLyxcclxuICAgICAgICAgICAgICAgIGlzSW5maW5pdHlPck5hTiA9IC9eLT8oSW5maW5pdHl8TmFOKSQvLFxyXG4gICAgICAgICAgICAgICAgd2hpdGVzcGFjZU9yUGx1cyA9IC9eXFxzKlxcKyg/PVtcXHcuXSl8Xlxccyt8XFxzKyQvZztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHgsIHN0ciwgbnVtLCBiICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJhc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IG51bSA/IHN0ciA6IHN0ci5yZXBsYWNlKCB3aGl0ZXNwYWNlT3JQbHVzLCAnJyApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5vIGV4Y2VwdGlvbiBvbiDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAgICAgICAgICAgIGlmICggaXNJbmZpbml0eU9yTmFOLnRlc3QocykgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5zID0gaXNOYU4ocykgPyBudWxsIDogcyA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIW51bSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoIGJhc2VQcmVmaXgsIGZ1bmN0aW9uICggbSwgcDEsIHAyICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSA9ICggcDIgPSBwMi50b0xvd2VyQ2FzZSgpICkgPT0gJ3gnID8gMTYgOiBwMiA9PSAnYicgPyAyIDogODtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhYiB8fCBiID09IGJhc2UgPyBwMSA6IG07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UgPSBiO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEUuZy4gJzEuJyB0byAnMScsICcuMScgdG8gJzAuMSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoIGRvdEFmdGVyLCAnJDEnICkucmVwbGFjZSggZG90QmVmb3JlLCAnMC4kMScgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzdHIgIT0gcyApIHJldHVybiBuZXcgQmlnTnVtYmVyKCBzLCBiYXNlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAnbmV3IEJpZ051bWJlcigpIG5vdCBhIG51bWJlcjoge259J1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICduZXcgQmlnTnVtYmVyKCkgbm90IGEgYmFzZSB7Yn0gbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEVSUk9SUykgcmFpc2UoIGlkLCAnbm90IGEnICsgKCBiID8gJyBiYXNlICcgKyBiIDogJycgKSArICcgbnVtYmVyJywgc3RyICk7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5zID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkoKTtcclxuXHJcblxyXG4gICAgICAgIC8vIFRocm93IGEgQmlnTnVtYmVyIEVycm9yLlxyXG4gICAgICAgIGZ1bmN0aW9uIHJhaXNlKCBjYWxsZXIsIG1zZywgdmFsICkge1xyXG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoIFtcclxuICAgICAgICAgICAgICAgICduZXcgQmlnTnVtYmVyJywgICAgIC8vIDBcclxuICAgICAgICAgICAgICAgICdjbXAnLCAgICAgICAgICAgICAgIC8vIDFcclxuICAgICAgICAgICAgICAgICdjb25maWcnLCAgICAgICAgICAgIC8vIDJcclxuICAgICAgICAgICAgICAgICdkaXYnLCAgICAgICAgICAgICAgIC8vIDNcclxuICAgICAgICAgICAgICAgICdkaXZUb0ludCcsICAgICAgICAgIC8vIDRcclxuICAgICAgICAgICAgICAgICdlcScsICAgICAgICAgICAgICAgIC8vIDVcclxuICAgICAgICAgICAgICAgICdndCcsICAgICAgICAgICAgICAgIC8vIDZcclxuICAgICAgICAgICAgICAgICdndGUnLCAgICAgICAgICAgICAgIC8vIDdcclxuICAgICAgICAgICAgICAgICdsdCcsICAgICAgICAgICAgICAgIC8vIDhcclxuICAgICAgICAgICAgICAgICdsdGUnLCAgICAgICAgICAgICAgIC8vIDlcclxuICAgICAgICAgICAgICAgICdtaW51cycsICAgICAgICAgICAgIC8vIDEwXHJcbiAgICAgICAgICAgICAgICAnbW9kJywgICAgICAgICAgICAgICAvLyAxMVxyXG4gICAgICAgICAgICAgICAgJ3BsdXMnLCAgICAgICAgICAgICAgLy8gMTJcclxuICAgICAgICAgICAgICAgICdwcmVjaXNpb24nLCAgICAgICAgIC8vIDEzXHJcbiAgICAgICAgICAgICAgICAncmFuZG9tJywgICAgICAgICAgICAvLyAxNFxyXG4gICAgICAgICAgICAgICAgJ3JvdW5kJywgICAgICAgICAgICAgLy8gMTVcclxuICAgICAgICAgICAgICAgICdzaGlmdCcsICAgICAgICAgICAgIC8vIDE2XHJcbiAgICAgICAgICAgICAgICAndGltZXMnLCAgICAgICAgICAgICAvLyAxN1xyXG4gICAgICAgICAgICAgICAgJ3RvRGlnaXRzJywgICAgICAgICAgLy8gMThcclxuICAgICAgICAgICAgICAgICd0b0V4cG9uZW50aWFsJywgICAgIC8vIDE5XHJcbiAgICAgICAgICAgICAgICAndG9GaXhlZCcsICAgICAgICAgICAvLyAyMFxyXG4gICAgICAgICAgICAgICAgJ3RvRm9ybWF0JywgICAgICAgICAgLy8gMjFcclxuICAgICAgICAgICAgICAgICd0b0ZyYWN0aW9uJywgICAgICAgIC8vIDIyXHJcbiAgICAgICAgICAgICAgICAncG93JywgICAgICAgICAgICAgICAvLyAyM1xyXG4gICAgICAgICAgICAgICAgJ3RvUHJlY2lzaW9uJywgICAgICAgLy8gMjRcclxuICAgICAgICAgICAgICAgICd0b1N0cmluZycsICAgICAgICAgIC8vIDI1XHJcbiAgICAgICAgICAgICAgICAnQmlnTnVtYmVyJyAgICAgICAgICAvLyAyNlxyXG4gICAgICAgICAgICBdW2NhbGxlcl0gKyAnKCkgJyArIG1zZyArICc6ICcgKyB2YWwgKTtcclxuXHJcbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSAnQmlnTnVtYmVyIEVycm9yJztcclxuICAgICAgICAgICAgaWQgPSAwO1xyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJvdW5kIHggdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0uIENoZWNrIGZvciBvdmVyL3VuZGVyLWZsb3cuXHJcbiAgICAgICAgICogSWYgciBpcyB0cnV0aHksIGl0IGlzIGtub3duIHRoYXQgdGhlcmUgYXJlIG1vcmUgZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiByb3VuZCggeCwgc2QsIHJtLCByICkge1xyXG4gICAgICAgICAgICB2YXIgZCwgaSwgaiwgaywgbiwgbmksIHJkLFxyXG4gICAgICAgICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICAgICAgICBwb3dzMTAgPSBQT1dTX1RFTjtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHggaXMgbm90IEluZmluaXR5IG9yIE5hTi4uLlxyXG4gICAgICAgICAgICBpZiAoeGMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyByZCBpcyB0aGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyBhIGJhc2UgMWUxNCBudW1iZXIsIHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCBvZiBhcnJheSB4LmMgY29udGFpbmluZyByZC5cclxuICAgICAgICAgICAgICAgIC8vIG5pIGlzIHRoZSBpbmRleCBvZiBuIHdpdGhpbiB4LmMuXHJcbiAgICAgICAgICAgICAgICAvLyBkIGlzIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgICAgICAgICAvLyBpIGlzIHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiBpbmNsdWRpbmcgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAgIC8vIGogaXMgdGhlIGFjdHVhbCBpbmRleCBvZiByZCB3aXRoaW4gbiAoaWYgPCAwLCByZCBpcyBhIGxlYWRpbmcgemVybykuXHJcbiAgICAgICAgICAgICAgICBvdXQ6IHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGQgPSAxLCBrID0geGNbMF07IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyApO1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBzZCAtIGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaSA8IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGogPSBzZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IHhjWyBuaSA9IDAgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZCA9IG4gLyBwb3dzMTBbIGQgLSBqIC0gMSBdICUgMTAgfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5pID0gbWF0aGNlaWwoICggaSArIDEgKSAvIExPR19CQVNFICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5pID49IHhjLmxlbmd0aCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkZWQgYnkgc3FydC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IHhjLmxlbmd0aCA8PSBuaTsgeGMucHVzaCgwKSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSByZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IGsgPSB4Y1tuaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBkID0gMTsgayA+PSAxMDsgayAvPSAxMCwgZCsrICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiwgYWRqdXN0ZWQgZm9yIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2YgbiBpcyBnaXZlbiBieSBMT0dfQkFTRSAtIGQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJkID0gaiA8IDAgPyAwIDogbiAvIHBvd3MxMFsgZCAtIGogLSAxIF0gJSAxMCB8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHIgPSByIHx8IHNkIDwgMCB8fFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBcmUgdGhlcmUgYW55IG5vbi16ZXJvIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQ/XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGV4cHJlc3Npb24gIG4gJSBwb3dzMTBbIGQgLSBqIC0gMSBdICByZXR1cm5zIGFsbCBkaWdpdHMgb2YgbiB0byB0aGUgcmlnaHRcclxuICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgZGlnaXQgYXQgaiwgZS5nLiBpZiBuIGlzIDkwODcxNCBhbmQgaiBpcyAyLCB0aGUgZXhwcmVzc2lvbiBnaXZlcyA3MTQuXHJcbiAgICAgICAgICAgICAgICAgICAgICB4Y1tuaSArIDFdICE9IG51bGwgfHwgKCBqIDwgMCA/IG4gOiBuICUgcG93czEwWyBkIC0gaiAtIDEgXSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByID0gcm0gPCA0XHJcbiAgICAgICAgICAgICAgICAgICAgICA/ICggcmQgfHwgciApICYmICggcm0gPT0gMCB8fCBybSA9PSAoIHgucyA8IDAgPyAzIDogMiApIClcclxuICAgICAgICAgICAgICAgICAgICAgIDogcmQgPiA1IHx8IHJkID09IDUgJiYgKCBybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKCAoIGkgPiAwID8gaiA+IDAgPyBuIC8gcG93czEwWyBkIC0gaiBdIDogMCA6IHhjW25pIC0gMV0gKSAlIDEwICkgJiAxIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcm0gPT0gKCB4LnMgPCAwID8gOCA6IDcgKSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNkIDwgMSB8fCAheGNbMF0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhjLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgc2QgdG8gZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZCAtPSB4LmUgKyAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEsIDAuMSwgMC4wMSwgMC4wMDEsIDAuMDAwMSBldGMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4Y1swXSA9IHBvd3MxMFsgc2QgJSBMT0dfQkFTRSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5lID0gLXNkIHx8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhjWzBdID0geC5lID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZXhjZXNzIGRpZ2l0cy5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGkgPT0gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGMubGVuZ3RoID0gbmk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuaS0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgayA9IHBvd3MxMFsgTE9HX0JBU0UgLSBpIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFLmcuIDU2NzAwIGJlY29tZXMgNTYwMDAgaWYgNyBpcyB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGogPiAwIG1lYW5zIGkgPiBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4Y1tuaV0gPSBqID4gMCA/IG1hdGhmbG9vciggbiAvIHBvd3MxMFsgZCAtIGogXSAlIHBvd3MxMFtqXSApICogayA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICAgICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggOyA7ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkaWdpdCB0byBiZSByb3VuZGVkIHVwIGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5pID09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGkgd2lsbCBiZSB0aGUgbGVuZ3RoIG9mIHhjWzBdIGJlZm9yZSBrIGlzIGFkZGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAxLCBqID0geGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSB4Y1swXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGsgPSAxOyBqID49IDEwOyBqIC89IDEwLCBrKysgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgaSAhPSBrIHRoZSBsZW5ndGggaGFzIGluY3JlYXNlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGkgIT0gayApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5lKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggeGNbMF0gPT0gQkFTRSApIHhjWzBdID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4Y1tuaV0gKz0gaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHhjW25pXSAhPSBCQVNFICkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGNbbmktLV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IHhjLmxlbmd0aDsgeGNbLS1pXSA9PT0gMDsgeGMucG9wKCkgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBPdmVyZmxvdz8gSW5maW5pdHkuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHguZSA+IE1BWF9FWFAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVbmRlcmZsb3c/IFplcm8uXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB4LmUgPCBNSU5fRVhQICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHguYyA9IFsgeC5lID0gMCBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBQUk9UT1RZUEUvSU5TVEFOQ0UgTUVUSE9EU1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICAgICAgICBpZiAoIHgucyA8IDAgKSB4LnMgPSAxO1xyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIGEgd2hvbGVcclxuICAgICAgICAgKiBudW1iZXIgaW4gdGhlIGRpcmVjdGlvbiBvZiBJbmZpbml0eS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmNlaWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByb3VuZCggbmV3IEJpZ051bWJlcih0aGlzKSwgdGhpcy5lICsgMSwgMiApO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVyblxyXG4gICAgICAgICAqIDEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICAgICAqIC0xIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAgICAgKiAwIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZSxcclxuICAgICAgICAgKiBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuY29tcGFyZWRUbyA9IFAuY21wID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgICAgICBpZCA9IDE7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlKCB0aGlzLCBuZXcgQmlnTnVtYmVyKCB5LCBiICkgKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlXHJcbiAgICAgICAgICogb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5kZWNpbWFsUGxhY2VzID0gUC5kcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG4sIHYsXHJcbiAgICAgICAgICAgICAgICBjID0gdGhpcy5jO1xyXG5cclxuICAgICAgICAgICAgaWYgKCAhYyApIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBuID0gKCAoIHYgPSBjLmxlbmd0aCAtIDEgKSAtIGJpdEZsb29yKCB0aGlzLmUgLyBMT0dfQkFTRSApICkgKiBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgbnVtYmVyLlxyXG4gICAgICAgICAgICBpZiAoIHYgPSBjW3ZdICkgZm9yICggOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tICk7XHJcbiAgICAgICAgICAgIGlmICggbiA8IDAgKSBuID0gMDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqICBuIC8gMCA9IElcclxuICAgICAgICAgKiAgbiAvIE4gPSBOXHJcbiAgICAgICAgICogIG4gLyBJID0gMFxyXG4gICAgICAgICAqICAwIC8gbiA9IDBcclxuICAgICAgICAgKiAgMCAvIDAgPSBOXHJcbiAgICAgICAgICogIDAgLyBOID0gTlxyXG4gICAgICAgICAqICAwIC8gSSA9IDBcclxuICAgICAgICAgKiAgTiAvIG4gPSBOXHJcbiAgICAgICAgICogIE4gLyAwID0gTlxyXG4gICAgICAgICAqICBOIC8gTiA9IE5cclxuICAgICAgICAgKiAgTiAvIEkgPSBOXHJcbiAgICAgICAgICogIEkgLyBuID0gSVxyXG4gICAgICAgICAqICBJIC8gMCA9IElcclxuICAgICAgICAgKiAgSSAvIE4gPSBOXHJcbiAgICAgICAgICogIEkgLyBJID0gTlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2ZcclxuICAgICAgICAgKiBCaWdOdW1iZXIoeSwgYiksIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbiAoIHksIGIgKSB7XHJcbiAgICAgICAgICAgIGlkID0gMztcclxuICAgICAgICAgICAgcmV0dXJuIGRpdiggdGhpcywgbmV3IEJpZ051bWJlciggeSwgYiApLCBERUNJTUFMX1BMQUNFUywgUk9VTkRJTkdfTU9ERSApO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGludGVnZXIgcGFydCBvZiBkaXZpZGluZyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICAgICAqIEJpZ051bWJlciBieSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuZGl2aWRlZFRvSW50ZWdlckJ5ID0gUC5kaXZUb0ludCA9IGZ1bmN0aW9uICggeSwgYiApIHtcclxuICAgICAgICAgICAgaWQgPSA0O1xyXG4gICAgICAgICAgICByZXR1cm4gZGl2KCB0aGlzLCBuZXcgQmlnTnVtYmVyKCB5LCBiICksIDAsIDEgKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAgICAgKiBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmVxdWFscyA9IFAuZXEgPSBmdW5jdGlvbiAoIHksIGIgKSB7XHJcbiAgICAgICAgICAgIGlkID0gNTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUoIHRoaXMsIG5ldyBCaWdOdW1iZXIoIHksIGIgKSApID09PSAwO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSB3aG9sZVxyXG4gICAgICAgICAqIG51bWJlciBpbiB0aGUgZGlyZWN0aW9uIG9mIC1JbmZpbml0eS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmZsb29yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcm91bmQoIG5ldyBCaWdOdW1iZXIodGhpcyksIHRoaXMuZSArIDEsIDMgKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgICAgICogb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5ncmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbiAoIHksIGIgKSB7XHJcbiAgICAgICAgICAgIGlkID0gNjtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUoIHRoaXMsIG5ldyBCaWdOdW1iZXIoIHksIGIgKSApID4gMDtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5ncmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgICAgICBpZCA9IDc7XHJcbiAgICAgICAgICAgIHJldHVybiAoIGIgPSBjb21wYXJlKCB0aGlzLCBuZXcgQmlnTnVtYmVyKCB5LCBiICkgKSApID09PSAxIHx8IGIgPT09IDA7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhIGZpbml0ZSBudW1iZXIsIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuaXNGaW5pdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuYztcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYW4gaW50ZWdlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmlzSW50ZWdlciA9IFAuaXNJbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuYyAmJiBiaXRGbG9vciggdGhpcy5lIC8gTE9HX0JBU0UgKSA+IHRoaXMuYy5sZW5ndGggLSAyO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBOYU4sIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuaXNOYU4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5zO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5pc05lZ2F0aXZlID0gUC5pc05lZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucyA8IDA7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIDAgb3IgLTAsIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmMgJiYgdGhpcy5jWzBdID09IDA7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICAgICAqIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAubGVzc1RoYW4gPSBQLmx0ID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgICAgICBpZCA9IDg7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlKCB0aGlzLCBuZXcgQmlnTnVtYmVyKCB5LCBiICkgKSA8IDA7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAubGVzc1RoYW5PckVxdWFsVG8gPSBQLmx0ZSA9IGZ1bmN0aW9uICggeSwgYiApIHtcclxuICAgICAgICAgICAgaWQgPSA5O1xyXG4gICAgICAgICAgICByZXR1cm4gKCBiID0gY29tcGFyZSggdGhpcywgbmV3IEJpZ051bWJlciggeSwgYiApICkgKSA9PT0gLTEgfHwgYiA9PT0gMDtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiAgbiAtIDAgPSBuXHJcbiAgICAgICAgICogIG4gLSBOID0gTlxyXG4gICAgICAgICAqICBuIC0gSSA9IC1JXHJcbiAgICAgICAgICogIDAgLSBuID0gLW5cclxuICAgICAgICAgKiAgMCAtIDAgPSAwXHJcbiAgICAgICAgICogIDAgLSBOID0gTlxyXG4gICAgICAgICAqICAwIC0gSSA9IC1JXHJcbiAgICAgICAgICogIE4gLSBuID0gTlxyXG4gICAgICAgICAqICBOIC0gMCA9IE5cclxuICAgICAgICAgKiAgTiAtIE4gPSBOXHJcbiAgICAgICAgICogIE4gLSBJID0gTlxyXG4gICAgICAgICAqICBJIC0gbiA9IElcclxuICAgICAgICAgKiAgSSAtIDAgPSBJXHJcbiAgICAgICAgICogIEkgLSBOID0gTlxyXG4gICAgICAgICAqICBJIC0gSSA9IE5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1pbnVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLm1pbnVzID0gUC5zdWIgPSBmdW5jdGlvbiAoIHksIGIgKSB7XHJcbiAgICAgICAgICAgIHZhciBpLCBqLCB0LCB4TFR5LFxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgICAgICAgaWQgPSAxMDtcclxuICAgICAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoIHksIGIgKTtcclxuICAgICAgICAgICAgYiA9IHkucztcclxuXHJcbiAgICAgICAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgICAgICAgIGlmICggIWEgfHwgIWIgKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICAgICAgICBpZiAoIGEgIT0gYiApIHtcclxuICAgICAgICAgICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHgucGx1cyh5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgICAgICAgIGlmICggIXhlIHx8ICF5ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICAgICAgICAgICAgICBpZiAoICF4YyB8fCAheWMgKSByZXR1cm4geGMgPyAoIHkucyA9IC1iLCB5ICkgOiBuZXcgQmlnTnVtYmVyKCB5YyA/IHggOiBOYU4gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICAgICAgICAgIGlmICggIXhjWzBdIHx8ICF5Y1swXSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHljWzBdID8gKCB5LnMgPSAtYiwgeSApIDogbmV3IEJpZ051bWJlciggeGNbMF0gPyB4IDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJRUVFIDc1NCAoMjAwOCkgNi4zOiBuIC0gbiA9IC0wIHdoZW4gcm91bmRpbmcgdG8gLUluZmluaXR5XHJcbiAgICAgICAgICAgICAgICAgICAgICBST1VORElOR19NT0RFID09IDMgPyAtMCA6IDAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgICAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICAgICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgICAgICAgIGlmICggYSA9IHhlIC0geWUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB4TFR5ID0gYSA8IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgICAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdC5yZXZlcnNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCBiID0gYTsgYi0tOyB0LnB1c2goMCkgKTtcclxuICAgICAgICAgICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEV4cG9uZW50cyBlcXVhbC4gQ2hlY2sgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICBqID0gKCB4TFR5ID0gKCBhID0geGMubGVuZ3RoICkgPCAoIGIgPSB5Yy5sZW5ndGggKSApID8gYSA6IGI7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggYSA9IGIgPSAwOyBiIDwgajsgYisrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHhjW2JdICE9IHljW2JdICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4TFR5ID0geGNbYl0gPCB5Y1tiXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyB4IDwgeT8gUG9pbnQgeGMgdG8gdGhlIGFycmF5IG9mIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICAgICAgICBpZiAoeExUeSkgdCA9IHhjLCB4YyA9IHljLCB5YyA9IHQsIHkucyA9IC15LnM7XHJcblxyXG4gICAgICAgICAgICBiID0gKCBqID0geWMubGVuZ3RoICkgLSAoIGkgPSB4Yy5sZW5ndGggKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLlxyXG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIGFkZCB6ZXJvcyB0byB5YyBpZiBzaG9ydGVyIGFzIHN1YnRyYWN0IG9ubHkgbmVlZHMgdG8gc3RhcnQgYXQgeWMubGVuZ3RoLlxyXG4gICAgICAgICAgICBpZiAoIGIgPiAwICkgZm9yICggOyBiLS07IHhjW2krK10gPSAwICk7XHJcbiAgICAgICAgICAgIGIgPSBCQVNFIC0gMTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgICAgICAgICAgIGZvciAoIDsgaiA+IGE7ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggeGNbLS1qXSA8IHljW2pdICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSBqOyBpICYmICF4Y1stLWldOyB4Y1tpXSA9IGIgKTtcclxuICAgICAgICAgICAgICAgICAgICAtLXhjW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHhjW2pdICs9IEJBU0U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgeGNbal0gLT0geWNbal07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICAgIGZvciAoIDsgeGNbMF0gPT0gMDsgeGMuc2hpZnQoKSwgLS15ZSApO1xyXG5cclxuICAgICAgICAgICAgLy8gWmVybz9cclxuICAgICAgICAgICAgaWYgKCAheGNbMF0gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRm9sbG93aW5nIElFRUUgNzU0ICgyMDA4KSA2LjMsXHJcbiAgICAgICAgICAgICAgICAvLyBuIC0gbiA9ICswICBidXQgIG4gLSBuID0gLTAgIHdoZW4gcm91bmRpbmcgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgICAgICAgICAgICB5LnMgPSBST1VORElOR19NT0RFID09IDMgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgICAgICB5LmMgPSBbIHkuZSA9IDAgXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB5O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciBJbmZpbml0eSBhcyAreCAtICt5ICE9IEluZmluaXR5ICYmIC14IC0gLXkgIT0gSW5maW5pdHlcclxuICAgICAgICAgICAgLy8gZm9yIGZpbml0ZSB4IGFuZCB5LlxyXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXNlKCB5LCB4YywgeWUgKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiAgIG4gJSAwID0gIE5cclxuICAgICAgICAgKiAgIG4gJSBOID0gIE5cclxuICAgICAgICAgKiAgIG4gJSBJID0gIG5cclxuICAgICAgICAgKiAgIDAgJSBuID0gIDBcclxuICAgICAgICAgKiAgLTAgJSBuID0gLTBcclxuICAgICAgICAgKiAgIDAgJSAwID0gIE5cclxuICAgICAgICAgKiAgIDAgJSBOID0gIE5cclxuICAgICAgICAgKiAgIDAgJSBJID0gIDBcclxuICAgICAgICAgKiAgIE4gJSBuID0gIE5cclxuICAgICAgICAgKiAgIE4gJSAwID0gIE5cclxuICAgICAgICAgKiAgIE4gJSBOID0gIE5cclxuICAgICAgICAgKiAgIE4gJSBJID0gIE5cclxuICAgICAgICAgKiAgIEkgJSBuID0gIE5cclxuICAgICAgICAgKiAgIEkgJSAwID0gIE5cclxuICAgICAgICAgKiAgIEkgJSBOID0gIE5cclxuICAgICAgICAgKiAgIEkgJSBJID0gIE5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1vZHVsbyB0aGUgdmFsdWUgb2ZcclxuICAgICAgICAgKiBCaWdOdW1iZXIoeSwgYikuIFRoZSByZXN1bHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUgb2YgTU9EVUxPX01PREUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5tb2R1bG8gPSBQLm1vZCA9IGZ1bmN0aW9uICggeSwgYiApIHtcclxuICAgICAgICAgICAgdmFyIHEsIHMsXHJcbiAgICAgICAgICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIGlkID0gMTE7XHJcbiAgICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKCB5LCBiICk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgSW5maW5pdHkgb3IgTmFOLCBvciB5IGlzIE5hTiBvciB6ZXJvLlxyXG4gICAgICAgICAgICBpZiAoICF4LmMgfHwgIXkucyB8fCB5LmMgJiYgIXkuY1swXSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4geCBpZiB5IGlzIEluZmluaXR5IG9yIHggaXMgemVyby5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICggIXkuYyB8fCB4LmMgJiYgIXguY1swXSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIE1PRFVMT19NT0RFID09IDkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXHJcbiAgICAgICAgICAgICAgICAvLyByID0geCAtIHF5ICAgIHdoZXJlICAwIDw9IHIgPCBhYnMoeSlcclxuICAgICAgICAgICAgICAgIHMgPSB5LnM7XHJcbiAgICAgICAgICAgICAgICB5LnMgPSAxO1xyXG4gICAgICAgICAgICAgICAgcSA9IGRpdiggeCwgeSwgMCwgMyApO1xyXG4gICAgICAgICAgICAgICAgeS5zID0gcztcclxuICAgICAgICAgICAgICAgIHEucyAqPSBzO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcSA9IGRpdiggeCwgeSwgMCwgTU9EVUxPX01PREUgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHgubWludXMoIHEudGltZXMoeSkgKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBuZWdhdGVkLFxyXG4gICAgICAgICAqIGkuZS4gbXVsdGlwbGllZCBieSAtMS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLm5lZ2F0ZWQgPSBQLm5lZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICAgICAgICB4LnMgPSAteC5zIHx8IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqICBuICsgMCA9IG5cclxuICAgICAgICAgKiAgbiArIE4gPSBOXHJcbiAgICAgICAgICogIG4gKyBJID0gSVxyXG4gICAgICAgICAqICAwICsgbiA9IG5cclxuICAgICAgICAgKiAgMCArIDAgPSAwXHJcbiAgICAgICAgICogIDAgKyBOID0gTlxyXG4gICAgICAgICAqICAwICsgSSA9IElcclxuICAgICAgICAgKiAgTiArIG4gPSBOXHJcbiAgICAgICAgICogIE4gKyAwID0gTlxyXG4gICAgICAgICAqICBOICsgTiA9IE5cclxuICAgICAgICAgKiAgTiArIEkgPSBOXHJcbiAgICAgICAgICogIEkgKyBuID0gSVxyXG4gICAgICAgICAqICBJICsgMCA9IElcclxuICAgICAgICAgKiAgSSArIE4gPSBOXHJcbiAgICAgICAgICogIEkgKyBJID0gSVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcGx1cyB0aGUgdmFsdWUgb2ZcclxuICAgICAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5wbHVzID0gUC5hZGQgPSBmdW5jdGlvbiAoIHksIGIgKSB7XHJcbiAgICAgICAgICAgIHZhciB0LFxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgICAgICAgaWQgPSAxMjtcclxuICAgICAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoIHksIGIgKTtcclxuICAgICAgICAgICAgYiA9IHkucztcclxuXHJcbiAgICAgICAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgICAgICAgIGlmICggIWEgfHwgIWIgKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICAgICAgICAgaWYgKCBhICE9IGIgKSB7XHJcbiAgICAgICAgICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICAgICAgICAgIHJldHVybiB4Lm1pbnVzKHkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICAgICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICAgICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgICAgICAgaWYgKCAheGUgfHwgIXllICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciDCsUluZmluaXR5LlxyXG4gICAgICAgICAgICAgICAgaWYgKCAheGMgfHwgIXljICkgcmV0dXJuIG5ldyBCaWdOdW1iZXIoIGEgLyAwICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICAgICAgICAgIGlmICggIXhjWzBdIHx8ICF5Y1swXSApIHJldHVybiB5Y1swXSA/IHkgOiBuZXcgQmlnTnVtYmVyKCB4Y1swXSA/IHggOiBhICogMCApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgICAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLiBGYXN0ZXIgdG8gdXNlIHJldmVyc2UgdGhlbiBkbyB1bnNoaWZ0cy5cclxuICAgICAgICAgICAgaWYgKCBhID0geGUgLSB5ZSApIHtcclxuICAgICAgICAgICAgICAgIGlmICggYSA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgICAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgICAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGEtLTsgdC5wdXNoKDApICk7XHJcbiAgICAgICAgICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYSA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgICAgYiA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIC8vIFBvaW50IHhjIHRvIHRoZSBsb25nZXIgYXJyYXksIGFuZCBiIHRvIHRoZSBzaG9ydGVyIGxlbmd0aC5cclxuICAgICAgICAgICAgaWYgKCBhIC0gYiA8IDAgKSB0ID0geWMsIHljID0geGMsIHhjID0gdCwgYiA9IGE7XHJcblxyXG4gICAgICAgICAgICAvLyBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5Yy5sZW5ndGggLSAxIGFzIHRoZSBmdXJ0aGVyIGRpZ2l0cyBvZiB4YyBjYW4gYmUgaWdub3JlZC5cclxuICAgICAgICAgICAgZm9yICggYSA9IDA7IGI7ICkge1xyXG4gICAgICAgICAgICAgICAgYSA9ICggeGNbLS1iXSA9IHhjW2JdICsgeWNbYl0gKyBhICkgLyBCQVNFIHwgMDtcclxuICAgICAgICAgICAgICAgIHhjW2JdICU9IEJBU0U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChhKSB7XHJcbiAgICAgICAgICAgICAgICB4Yy51bnNoaWZ0KGEpO1xyXG4gICAgICAgICAgICAgICAgKyt5ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgemVybywgYXMgK3ggKyAreSAhPSAwICYmIC14ICsgLXkgIT0gMFxyXG4gICAgICAgICAgICAvLyB5ZSA9IE1BWF9FWFAgKyAxIHBvc3NpYmxlXHJcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpc2UoIHksIHhjLCB5ZSApO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBbel0ge2Jvb2xlYW58bnVtYmVyfSBXaGV0aGVyIHRvIGNvdW50IGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvczogdHJ1ZSwgZmFsc2UsIDEgb3IgMC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLnByZWNpc2lvbiA9IFAuc2QgPSBmdW5jdGlvbiAoeikge1xyXG4gICAgICAgICAgICB2YXIgbiwgdixcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgYyA9IHguYztcclxuXHJcbiAgICAgICAgICAgIC8vICdwcmVjaXNpb24oKSBhcmd1bWVudCBub3QgYSBib29sZWFuIG9yIGJpbmFyeSBkaWdpdDoge3p9J1xyXG4gICAgICAgICAgICBpZiAoIHogIT0gbnVsbCAmJiB6ICE9PSAhIXogJiYgeiAhPT0gMSAmJiB6ICE9PSAwICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKEVSUk9SUykgcmFpc2UoIDEzLCAnYXJndW1lbnQnICsgbm90Qm9vbCwgeiApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCB6ICE9ICEheiApIHogPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoICFjICkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIHYgPSBjLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIG4gPSB2ICogTE9HX0JBU0UgKyAxO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB2ID0gY1t2XSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCA7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgbisrICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggeiAmJiB4LmUgKyAxID4gbiApIG4gPSB4LmUgKyAxO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG47XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2ZcclxuICAgICAgICAgKiBkcCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciB0byAwIGFuZCBST1VORElOR19NT0RFIHJlc3BlY3RpdmVseSBpZlxyXG4gICAgICAgICAqIG9taXR0ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogJ3JvdW5kKCkgZGVjaW1hbCBwbGFjZXMgb3V0IG9mIHJhbmdlOiB7ZHB9J1xyXG4gICAgICAgICAqICdyb3VuZCgpIGRlY2ltYWwgcGxhY2VzIG5vdCBhbiBpbnRlZ2VyOiB7ZHB9J1xyXG4gICAgICAgICAqICdyb3VuZCgpIHJvdW5kaW5nIG1vZGUgbm90IGFuIGludGVnZXI6IHtybX0nXHJcbiAgICAgICAgICogJ3JvdW5kKCkgcm91bmRpbmcgbW9kZSBvdXQgb2YgcmFuZ2U6IHtybX0nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5yb3VuZCA9IGZ1bmN0aW9uICggZHAsIHJtICkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGRwID09IG51bGwgfHwgaXNWYWxpZEludCggZHAsIDAsIE1BWCwgMTUgKSApIHtcclxuICAgICAgICAgICAgICAgIHJvdW5kKCBuLCB+fmRwICsgdGhpcy5lICsgMSwgcm0gPT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAgICAgICAhaXNWYWxpZEludCggcm0sIDAsIDgsIDE1LCByb3VuZGluZ01vZGUgKSA/IFJPVU5ESU5HX01PREUgOiBybSB8IDAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG47XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgc2hpZnRlZCBieSBrIHBsYWNlc1xyXG4gICAgICAgICAqIChwb3dlcnMgb2YgMTApLiBTaGlmdCB0byB0aGUgcmlnaHQgaWYgbiA+IDAsIGFuZCB0byB0aGUgbGVmdCBpZiBuIDwgMC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGsge251bWJlcn0gSW50ZWdlciwgLU1BWF9TQUZFX0lOVEVHRVIgdG8gTUFYX1NBRkVfSU5URUdFUiBpbmNsdXNpdmUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBJZiBrIGlzIG91dCBvZiByYW5nZSBhbmQgRVJST1JTIGlzIGZhbHNlLCB0aGUgcmVzdWx0IHdpbGwgYmUgwrEwIGlmIGsgPCAwLCBvciDCsUluZmluaXR5XHJcbiAgICAgICAgICogb3RoZXJ3aXNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogJ3NoaWZ0KCkgYXJndW1lbnQgbm90IGFuIGludGVnZXI6IHtrfSdcclxuICAgICAgICAgKiAnc2hpZnQoKSBhcmd1bWVudCBvdXQgb2YgcmFuZ2U6IHtrfSdcclxuICAgICAgICAgKi9cclxuICAgICAgICBQLnNoaWZ0ID0gZnVuY3Rpb24gKGspIHtcclxuICAgICAgICAgICAgdmFyIG4gPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gaXNWYWxpZEludCggaywgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIsIDE2LCAnYXJndW1lbnQnIClcclxuXHJcbiAgICAgICAgICAgICAgLy8gayA8IDFlKzIxLCBvciB0cnVuY2F0ZShrKSB3aWxsIHByb2R1Y2UgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgICAgICAgPyBuLnRpbWVzKCAnMWUnICsgdHJ1bmNhdGUoaykgKVxyXG4gICAgICAgICAgICAgIDogbmV3IEJpZ051bWJlciggbi5jICYmIG4uY1swXSAmJiAoIGsgPCAtTUFYX1NBRkVfSU5URUdFUiB8fCBrID4gTUFYX1NBRkVfSU5URUdFUiApXHJcbiAgICAgICAgICAgICAgICA/IG4ucyAqICggayA8IDAgPyAwIDogMSAvIDAgKVxyXG4gICAgICAgICAgICAgICAgOiBuICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogIHNxcnQoLW4pID0gIE5cclxuICAgICAgICAgKiAgc3FydCggTikgPSAgTlxyXG4gICAgICAgICAqICBzcXJ0KC1JKSA9ICBOXHJcbiAgICAgICAgICogIHNxcnQoIEkpID0gIElcclxuICAgICAgICAgKiAgc3FydCggMCkgPSAgMFxyXG4gICAgICAgICAqICBzcXJ0KC0wKSA9IC0wXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsXHJcbiAgICAgICAgICogcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5zcXVhcmVSb290ID0gUC5zcXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbSwgbiwgciwgcmVwLCB0LFxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBjID0geC5jLFxyXG4gICAgICAgICAgICAgICAgcyA9IHgucyxcclxuICAgICAgICAgICAgICAgIGUgPSB4LmUsXHJcbiAgICAgICAgICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTICsgNCxcclxuICAgICAgICAgICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKCcwLjUnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE5lZ2F0aXZlL05hTi9JbmZpbml0eS96ZXJvP1xyXG4gICAgICAgICAgICBpZiAoIHMgIT09IDEgfHwgIWMgfHwgIWNbMF0gKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlciggIXMgfHwgcyA8IDAgJiYgKCAhYyB8fCBjWzBdICkgPyBOYU4gOiBjID8geCA6IDEgLyAwICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEluaXRpYWwgZXN0aW1hdGUuXHJcbiAgICAgICAgICAgIHMgPSBNYXRoLnNxcnQoICt4ICk7XHJcblxyXG4gICAgICAgICAgICAvLyBNYXRoLnNxcnQgdW5kZXJmbG93L292ZXJmbG93P1xyXG4gICAgICAgICAgICAvLyBQYXNzIHggdG8gTWF0aC5zcXJ0IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxyXG4gICAgICAgICAgICBpZiAoIHMgPT0gMCB8fCBzID09IDEgLyAwICkge1xyXG4gICAgICAgICAgICAgICAgbiA9IGNvZWZmVG9TdHJpbmcoYyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoICggbi5sZW5ndGggKyBlICkgJSAyID09IDAgKSBuICs9ICcwJztcclxuICAgICAgICAgICAgICAgIHMgPSBNYXRoLnNxcnQobik7XHJcbiAgICAgICAgICAgICAgICBlID0gYml0Rmxvb3IoICggZSArIDEgKSAvIDIgKSAtICggZSA8IDAgfHwgZSAlIDIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHMgPT0gMSAvIDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9ICcxZScgKyBlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IG4uc2xpY2UoIDAsIG4uaW5kZXhPZignZScpICsgMSApICsgZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByID0gbmV3IEJpZ051bWJlcihuKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKCBzICsgJycgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHplcm8uXHJcbiAgICAgICAgICAgIC8vIHIgY291bGQgYmUgemVybyBpZiBNSU5fRVhQIGlzIGNoYW5nZWQgYWZ0ZXIgdGhlIHRoaXMgdmFsdWUgd2FzIGNyZWF0ZWQuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgd291bGQgY2F1c2UgYSBkaXZpc2lvbiBieSB6ZXJvICh4L3QpIGFuZCBoZW5jZSBJbmZpbml0eSBiZWxvdywgd2hpY2ggd291bGQgY2F1c2VcclxuICAgICAgICAgICAgLy8gY29lZmZUb1N0cmluZyB0byB0aHJvdy5cclxuICAgICAgICAgICAgaWYgKCByLmNbMF0gKSB7XHJcbiAgICAgICAgICAgICAgICBlID0gci5lO1xyXG4gICAgICAgICAgICAgICAgcyA9IGUgKyBkcDtcclxuICAgICAgICAgICAgICAgIGlmICggcyA8IDMgKSBzID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOZXd0b24tUmFwaHNvbiBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgICAgICBmb3IgKCA7IDsgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IHI7XHJcbiAgICAgICAgICAgICAgICAgICAgciA9IGhhbGYudGltZXMoIHQucGx1cyggZGl2KCB4LCB0LCBkcCwgMSApICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb2VmZlRvU3RyaW5nKCB0LmMgICApLnNsaWNlKCAwLCBzICkgPT09ICggbiA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBjb2VmZlRvU3RyaW5nKCByLmMgKSApLnNsaWNlKCAwLCBzICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZXhwb25lbnQgb2YgciBtYXkgaGVyZSBiZSBvbmUgbGVzcyB0aGFuIHRoZSBmaW5hbCByZXN1bHQgZXhwb25lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGUuZyAwLjAwMDk5OTkgKGUtNCkgLS0+IDAuMDAxIChlLTMpLCBzbyBhZGp1c3QgcyBzbyB0aGUgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFyZSBpbmRleGVkIGNvcnJlY3RseS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByLmUgPCBlICkgLS1zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gbi5zbGljZSggcyAtIDMsIHMgKyAxICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgNHRoIHJvdW5kaW5nIGRpZ2l0IG1heSBiZSBpbiBlcnJvciBieSAtMSBzbyBpZiB0aGUgNCByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJlIDk5OTkgb3IgNDk5OSAoaS5lLiBhcHByb2FjaGluZyBhIHJvdW5kaW5nIGJvdW5kYXJ5KSBjb250aW51ZSB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBvbmx5LCBjaGVjayB0byBzZWUgaWYgcm91bmRpbmcgdXAgZ2l2ZXMgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBleGFjdCByZXN1bHQgYXMgdGhlIG5pbmVzIG1heSBpbmZpbml0ZWx5IHJlcGVhdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIXJlcCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3VuZCggdCwgdC5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAwICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdC50aW1lcyh0KS5lcSh4KSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcCArPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiByb3VuZGluZyBkaWdpdHMgYXJlIG51bGwsIDB7MCw0fSBvciA1MHswLDN9LCBjaGVjayBmb3IgZXhhY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdC4gSWYgbm90LCB0aGVuIHRoZXJlIGFyZSBmdXJ0aGVyIGRpZ2l0cyBhbmQgbSB3aWxsIGJlIHRydXRoeS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSAnNScgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3VuZCggciwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAxICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLmVxKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcm91bmQoIHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMSwgUk9VTkRJTkdfTU9ERSwgbSApO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqICBuICogMCA9IDBcclxuICAgICAgICAgKiAgbiAqIE4gPSBOXHJcbiAgICAgICAgICogIG4gKiBJID0gSVxyXG4gICAgICAgICAqICAwICogbiA9IDBcclxuICAgICAgICAgKiAgMCAqIDAgPSAwXHJcbiAgICAgICAgICogIDAgKiBOID0gTlxyXG4gICAgICAgICAqICAwICogSSA9IE5cclxuICAgICAgICAgKiAgTiAqIG4gPSBOXHJcbiAgICAgICAgICogIE4gKiAwID0gTlxyXG4gICAgICAgICAqICBOICogTiA9IE5cclxuICAgICAgICAgKiAgTiAqIEkgPSBOXHJcbiAgICAgICAgICogIEkgKiBuID0gSVxyXG4gICAgICAgICAqICBJICogMCA9IE5cclxuICAgICAgICAgKiAgSSAqIE4gPSBOXHJcbiAgICAgICAgICogIEkgKiBJID0gSVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgdGltZXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudGltZXMgPSBQLm11bCA9IGZ1bmN0aW9uICggeSwgYiApIHtcclxuICAgICAgICAgICAgdmFyIGMsIGUsIGksIGosIGssIG0sIHhjTCwgeGxvLCB4aGksIHljTCwgeWxvLCB5aGksIHpjLFxyXG4gICAgICAgICAgICAgICAgYmFzZSwgc3FydEJhc2UsXHJcbiAgICAgICAgICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgICAgICAgeWMgPSAoIGlkID0gMTcsIHkgPSBuZXcgQmlnTnVtYmVyKCB5LCBiICkgKS5jO1xyXG5cclxuICAgICAgICAgICAgLy8gRWl0aGVyIE5hTiwgwrFJbmZpbml0eSBvciDCsTA/XHJcbiAgICAgICAgICAgIGlmICggIXhjIHx8ICF5YyB8fCAheGNbMF0gfHwgIXljWzBdICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTiwgb3Igb25lIGlzIDAgYW5kIHRoZSBvdGhlciBpcyBJbmZpbml0eS5cclxuICAgICAgICAgICAgICAgIGlmICggIXgucyB8fCAheS5zIHx8IHhjICYmICF4Y1swXSAmJiAheWMgfHwgeWMgJiYgIXljWzBdICYmICF4YyApIHtcclxuICAgICAgICAgICAgICAgICAgICB5LmMgPSB5LmUgPSB5LnMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB5LnMgKj0geC5zO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgaXMgwrFJbmZpbml0eS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoICF4YyB8fCAheWMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkuYyA9IHkuZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgZWl0aGVyIGlzIMKxMC5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5LmMgPSBbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkuZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB5O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBlID0gYml0Rmxvb3IoIHguZSAvIExPR19CQVNFICkgKyBiaXRGbG9vciggeS5lIC8gTE9HX0JBU0UgKTtcclxuICAgICAgICAgICAgeS5zICo9IHgucztcclxuICAgICAgICAgICAgeGNMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgICB5Y0wgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAvLyBFbnN1cmUgeGMgcG9pbnRzIHRvIGxvbmdlciBhcnJheSBhbmQgeGNMIHRvIGl0cyBsZW5ndGguXHJcbiAgICAgICAgICAgIGlmICggeGNMIDwgeWNMICkgemMgPSB4YywgeGMgPSB5YywgeWMgPSB6YywgaSA9IHhjTCwgeGNMID0geWNMLCB5Y0wgPSBpO1xyXG5cclxuICAgICAgICAgICAgLy8gSW5pdGlhbGlzZSB0aGUgcmVzdWx0IGFycmF5IHdpdGggemVyb3MuXHJcbiAgICAgICAgICAgIGZvciAoIGkgPSB4Y0wgKyB5Y0wsIHpjID0gW107IGktLTsgemMucHVzaCgwKSApO1xyXG5cclxuICAgICAgICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgICAgICAgIHNxcnRCYXNlID0gU1FSVF9CQVNFO1xyXG5cclxuICAgICAgICAgICAgZm9yICggaSA9IHljTDsgLS1pID49IDA7ICkge1xyXG4gICAgICAgICAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgICAgICAgICB5bG8gPSB5Y1tpXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgICAgICAgICAgeWhpID0geWNbaV0gLyBzcXJ0QmFzZSB8IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggayA9IHhjTCwgaiA9IGkgKyBrOyBqID4gaTsgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeGxvID0geGNbLS1rXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHhoaSA9IHhjW2tdIC8gc3FydEJhc2UgfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSB5aGkgKiB4bG8gKyB4aGkgKiB5bG87XHJcbiAgICAgICAgICAgICAgICAgICAgeGxvID0geWxvICogeGxvICsgKCAoIG0gJSBzcXJ0QmFzZSApICogc3FydEJhc2UgKSArIHpjW2pdICsgYztcclxuICAgICAgICAgICAgICAgICAgICBjID0gKCB4bG8gLyBiYXNlIHwgMCApICsgKCBtIC8gc3FydEJhc2UgfCAwICkgKyB5aGkgKiB4aGk7XHJcbiAgICAgICAgICAgICAgICAgICAgemNbai0tXSA9IHhsbyAlIGJhc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgemNbal0gPSBjO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYykge1xyXG4gICAgICAgICAgICAgICAgKytlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgemMuc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGlzZSggeSwgemMsIGUgKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZlxyXG4gICAgICAgICAqIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICd0b0RpZ2l0cygpIHByZWNpc2lvbiBvdXQgb2YgcmFuZ2U6IHtzZH0nXHJcbiAgICAgICAgICogJ3RvRGlnaXRzKCkgcHJlY2lzaW9uIG5vdCBhbiBpbnRlZ2VyOiB7c2R9J1xyXG4gICAgICAgICAqICd0b0RpZ2l0cygpIHJvdW5kaW5nIG1vZGUgbm90IGFuIGludGVnZXI6IHtybX0nXHJcbiAgICAgICAgICogJ3RvRGlnaXRzKCkgcm91bmRpbmcgbW9kZSBvdXQgb2YgcmFuZ2U6IHtybX0nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC50b0RpZ2l0cyA9IGZ1bmN0aW9uICggc2QsIHJtICkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgICAgICAgIHNkID0gc2QgPT0gbnVsbCB8fCAhaXNWYWxpZEludCggc2QsIDEsIE1BWCwgMTgsICdwcmVjaXNpb24nICkgPyBudWxsIDogc2QgfCAwO1xyXG4gICAgICAgICAgICBybSA9IHJtID09IG51bGwgfHwgIWlzVmFsaWRJbnQoIHJtLCAwLCA4LCAxOCwgcm91bmRpbmdNb2RlICkgPyBST1VORElOR19NT0RFIDogcm0gfCAwO1xyXG4gICAgICAgICAgICByZXR1cm4gc2QgPyByb3VuZCggbiwgc2QsIHJtICkgOiBuO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uIGFuZFxyXG4gICAgICAgICAqIHJvdW5kZWQgdXNpbmcgUk9VTkRJTkdfTU9ERSB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAndG9FeHBvbmVudGlhbCgpIGRlY2ltYWwgcGxhY2VzIG5vdCBhbiBpbnRlZ2VyOiB7ZHB9J1xyXG4gICAgICAgICAqICd0b0V4cG9uZW50aWFsKCkgZGVjaW1hbCBwbGFjZXMgb3V0IG9mIHJhbmdlOiB7ZHB9J1xyXG4gICAgICAgICAqICd0b0V4cG9uZW50aWFsKCkgcm91bmRpbmcgbW9kZSBub3QgYW4gaW50ZWdlcjoge3JtfSdcclxuICAgICAgICAgKiAndG9FeHBvbmVudGlhbCgpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uICggZHAsIHJtICkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0KCB0aGlzLFxyXG4gICAgICAgICAgICAgIGRwICE9IG51bGwgJiYgaXNWYWxpZEludCggZHAsIDAsIE1BWCwgMTkgKSA/IH5+ZHAgKyAxIDogbnVsbCwgcm0sIDE5ICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRpbmdcclxuICAgICAgICAgKiB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBOb3RlOiBhcyB3aXRoIEphdmFTY3JpcHQncyBudW1iZXIgdHlwZSwgKC0wKS50b0ZpeGVkKDApIGlzICcwJyxcclxuICAgICAgICAgKiBidXQgZS5nLiAoLTAuMDAwMDEpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAndG9GaXhlZCgpIGRlY2ltYWwgcGxhY2VzIG5vdCBhbiBpbnRlZ2VyOiB7ZHB9J1xyXG4gICAgICAgICAqICd0b0ZpeGVkKCkgZGVjaW1hbCBwbGFjZXMgb3V0IG9mIHJhbmdlOiB7ZHB9J1xyXG4gICAgICAgICAqICd0b0ZpeGVkKCkgcm91bmRpbmcgbW9kZSBub3QgYW4gaW50ZWdlcjoge3JtfSdcclxuICAgICAgICAgKiAndG9GaXhlZCgpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudG9GaXhlZCA9IGZ1bmN0aW9uICggZHAsIHJtICkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0KCB0aGlzLCBkcCAhPSBudWxsICYmIGlzVmFsaWRJbnQoIGRwLCAwLCBNQVgsIDIwIClcclxuICAgICAgICAgICAgICA/IH5+ZHAgKyB0aGlzLmUgKyAxIDogbnVsbCwgcm0sIDIwICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRlZFxyXG4gICAgICAgICAqIHVzaW5nIHJtIG9yIFJPVU5ESU5HX01PREUgdG8gZHAgZGVjaW1hbCBwbGFjZXMsIGFuZCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICogb2YgdGhlIEZPUk1BVCBvYmplY3QgKHNlZSBCaWdOdW1iZXIuY29uZmlnKS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEZPUk1BVCA9IHtcclxuICAgICAgICAgKiAgICAgIGRlY2ltYWxTZXBhcmF0b3IgOiAnLicsXHJcbiAgICAgICAgICogICAgICBncm91cFNlcGFyYXRvciA6ICcsJyxcclxuICAgICAgICAgKiAgICAgIGdyb3VwU2l6ZSA6IDMsXHJcbiAgICAgICAgICogICAgICBzZWNvbmRhcnlHcm91cFNpemUgOiAwLFxyXG4gICAgICAgICAqICAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvciA6ICdcXHhBMCcsICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICAgICAqICAgICAgZnJhY3Rpb25Hcm91cFNpemUgOiAwXHJcbiAgICAgICAgICogfTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAndG9Gb3JtYXQoKSBkZWNpbWFsIHBsYWNlcyBub3QgYW4gaW50ZWdlcjoge2RwfSdcclxuICAgICAgICAgKiAndG9Gb3JtYXQoKSBkZWNpbWFsIHBsYWNlcyBvdXQgb2YgcmFuZ2U6IHtkcH0nXHJcbiAgICAgICAgICogJ3RvRm9ybWF0KCkgcm91bmRpbmcgbW9kZSBub3QgYW4gaW50ZWdlcjoge3JtfSdcclxuICAgICAgICAgKiAndG9Gb3JtYXQoKSByb3VuZGluZyBtb2RlIG91dCBvZiByYW5nZToge3JtfSdcclxuICAgICAgICAgKi9cclxuICAgICAgICBQLnRvRm9ybWF0ID0gZnVuY3Rpb24gKCBkcCwgcm0gKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHIgPSBmb3JtYXQoIHRoaXMsIGRwICE9IG51bGwgJiYgaXNWYWxpZEludCggZHAsIDAsIE1BWCwgMjEgKVxyXG4gICAgICAgICAgICAgID8gfn5kcCArIHRoaXMuZSArIDEgOiBudWxsLCBybSwgMjEgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggdGhpcy5jICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICAgICAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcuJyksXHJcbiAgICAgICAgICAgICAgICAgICAgZzEgPSArRk9STUFULmdyb3VwU2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICBnMiA9ICtGT1JNQVQuc2Vjb25kYXJ5R3JvdXBTaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwU2VwYXJhdG9yID0gRk9STUFULmdyb3VwU2VwYXJhdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGludFBhcnQgPSBhcnJbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgZnJhY3Rpb25QYXJ0ID0gYXJyWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzTmVnID0gdGhpcy5zIDwgMCxcclxuICAgICAgICAgICAgICAgICAgICBpbnREaWdpdHMgPSBpc05lZyA/IGludFBhcnQuc2xpY2UoMSkgOiBpbnRQYXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IGludERpZ2l0cy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGcyKSBpID0gZzEsIGcxID0gZzIsIGcyID0gaSwgbGVuIC09IGk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBnMSA+IDAgJiYgbGVuID4gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICBpID0gbGVuICUgZzEgfHwgZzE7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50UGFydCA9IGludERpZ2l0cy5zdWJzdHIoIDAsIGkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpICs9IGcxICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnN1YnN0ciggaSwgZzEgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggZzIgPiAwICkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zbGljZShpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOZWcpIGludFBhcnQgPSAnLScgKyBpbnRQYXJ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHN0ciA9IGZyYWN0aW9uUGFydFxyXG4gICAgICAgICAgICAgICAgICA/IGludFBhcnQgKyBGT1JNQVQuZGVjaW1hbFNlcGFyYXRvciArICggKCBnMiA9ICtGT1JNQVQuZnJhY3Rpb25Hcm91cFNpemUgKVxyXG4gICAgICAgICAgICAgICAgICAgID8gZnJhY3Rpb25QYXJ0LnJlcGxhY2UoIG5ldyBSZWdFeHAoICdcXFxcZHsnICsgZzIgKyAnfVxcXFxCJywgJ2cnICksXHJcbiAgICAgICAgICAgICAgICAgICAgICAnJCYnICsgRk9STUFULmZyYWN0aW9uR3JvdXBTZXBhcmF0b3IgKVxyXG4gICAgICAgICAgICAgICAgICAgIDogZnJhY3Rpb25QYXJ0IClcclxuICAgICAgICAgICAgICAgICAgOiBpbnRQYXJ0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIHN0cmluZyBhcnJheSByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGFzIGEgc2ltcGxlIGZyYWN0aW9uIHdpdGhcclxuICAgICAgICAgKiBhbiBpbnRlZ2VyIG51bWVyYXRvciBhbmQgYW4gaW50ZWdlciBkZW5vbWluYXRvci4gVGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgYSBwb3NpdGl2ZVxyXG4gICAgICAgICAqIG5vbi16ZXJvIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc3BlY2lmaWVkIG1heGltdW0gZGVub21pbmF0b3IuIElmIGEgbWF4aW11bVxyXG4gICAgICAgICAqIGRlbm9taW5hdG9yIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBkZW5vbWluYXRvciB3aWxsIGJlIHRoZSBsb3dlc3QgdmFsdWUgbmVjZXNzYXJ5IHRvXHJcbiAgICAgICAgICogcmVwcmVzZW50IHRoZSBudW1iZXIgZXhhY3RseS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFttZF0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBJbnRlZ2VyID49IDEgYW5kIDwgSW5maW5pdHkuIFRoZSBtYXhpbXVtIGRlbm9taW5hdG9yLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogJ3RvRnJhY3Rpb24oKSBtYXggZGVub21pbmF0b3Igbm90IGFuIGludGVnZXI6IHttZH0nXHJcbiAgICAgICAgICogJ3RvRnJhY3Rpb24oKSBtYXggZGVub21pbmF0b3Igb3V0IG9mIHJhbmdlOiB7bWR9J1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudG9GcmFjdGlvbiA9IGZ1bmN0aW9uIChtZCkge1xyXG4gICAgICAgICAgICB2YXIgYXJyLCBkMCwgZDIsIGUsIGV4cCwgbiwgbjAsIHEsIHMsXHJcbiAgICAgICAgICAgICAgICBrID0gRVJST1JTLFxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICAgICAgICAgIGQgPSBuZXcgQmlnTnVtYmVyKE9ORSksXHJcbiAgICAgICAgICAgICAgICBuMSA9IGQwID0gbmV3IEJpZ051bWJlcihPTkUpLFxyXG4gICAgICAgICAgICAgICAgZDEgPSBuMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggbWQgIT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgIEVSUk9SUyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobWQpO1xyXG4gICAgICAgICAgICAgICAgRVJST1JTID0gaztcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoICEoIGsgPSBuLmlzSW50KCkgKSB8fCBuLmx0KE9ORSkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChFUlJPUlMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2UoIDIyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdtYXggZGVub21pbmF0b3IgJyArICggayA/ICdvdXQgb2YgcmFuZ2UnIDogJ25vdCBhbiBpbnRlZ2VyJyApLCBtZCApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRVJST1JTIGlzIGZhbHNlOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG1kIGlzIGEgZmluaXRlIG5vbi1pbnRlZ2VyID49IDEsIHJvdW5kIGl0IHRvIGFuIGludGVnZXIgYW5kIHVzZSBpdC5cclxuICAgICAgICAgICAgICAgICAgICBtZCA9ICFrICYmIG4uYyAmJiByb3VuZCggbiwgbi5lICsgMSwgMSApLmd0ZShPTkUpID8gbiA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggIXhjICkgcmV0dXJuIHgudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgcyA9IGNvZWZmVG9TdHJpbmcoeGMpO1xyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGluaXRpYWwgZGVub21pbmF0b3IuXHJcbiAgICAgICAgICAgIC8vIGQgaXMgYSBwb3dlciBvZiAxMCBhbmQgdGhlIG1pbmltdW0gbWF4IGRlbm9taW5hdG9yIHRoYXQgc3BlY2lmaWVzIHRoZSB2YWx1ZSBleGFjdGx5LlxyXG4gICAgICAgICAgICBlID0gZC5lID0gcy5sZW5ndGggLSB4LmUgLSAxO1xyXG4gICAgICAgICAgICBkLmNbMF0gPSBQT1dTX1RFTlsgKCBleHAgPSBlICUgTE9HX0JBU0UgKSA8IDAgPyBMT0dfQkFTRSArIGV4cCA6IGV4cCBdO1xyXG4gICAgICAgICAgICBtZCA9ICFtZCB8fCBuLmNtcChkKSA+IDAgPyAoIGUgPiAwID8gZCA6IG4xICkgOiBuO1xyXG5cclxuICAgICAgICAgICAgZXhwID0gTUFYX0VYUDtcclxuICAgICAgICAgICAgTUFYX0VYUCA9IDEgLyAwO1xyXG4gICAgICAgICAgICBuID0gbmV3IEJpZ051bWJlcihzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIG4wID0gZDEgPSAwXHJcbiAgICAgICAgICAgIG4wLmNbMF0gPSAwO1xyXG5cclxuICAgICAgICAgICAgZm9yICggOyA7ICkgIHtcclxuICAgICAgICAgICAgICAgIHEgPSBkaXYoIG4sIGQsIDAsIDEgKTtcclxuICAgICAgICAgICAgICAgIGQyID0gZDAucGx1cyggcS50aW1lcyhkMSkgKTtcclxuICAgICAgICAgICAgICAgIGlmICggZDIuY21wKG1kKSA9PSAxICkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkMCA9IGQxO1xyXG4gICAgICAgICAgICAgICAgZDEgPSBkMjtcclxuICAgICAgICAgICAgICAgIG4xID0gbjAucGx1cyggcS50aW1lcyggZDIgPSBuMSApICk7XHJcbiAgICAgICAgICAgICAgICBuMCA9IGQyO1xyXG4gICAgICAgICAgICAgICAgZCA9IG4ubWludXMoIHEudGltZXMoIGQyID0gZCApICk7XHJcbiAgICAgICAgICAgICAgICBuID0gZDI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGQyID0gZGl2KCBtZC5taW51cyhkMCksIGQxLCAwLCAxICk7XHJcbiAgICAgICAgICAgIG4wID0gbjAucGx1cyggZDIudGltZXMobjEpICk7XHJcbiAgICAgICAgICAgIGQwID0gZDAucGx1cyggZDIudGltZXMoZDEpICk7XHJcbiAgICAgICAgICAgIG4wLnMgPSBuMS5zID0geC5zO1xyXG4gICAgICAgICAgICBlICo9IDI7XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggZnJhY3Rpb24gaXMgY2xvc2VyIHRvIHgsIG4wL2QwIG9yIG4xL2QxXHJcbiAgICAgICAgICAgIGFyciA9IGRpdiggbjEsIGQxLCBlLCBST1VORElOR19NT0RFICkubWludXMoeCkuYWJzKCkuY21wKFxyXG4gICAgICAgICAgICAgICAgICBkaXYoIG4wLCBkMCwgZSwgUk9VTkRJTkdfTU9ERSApLm1pbnVzKHgpLmFicygpICkgPCAxXHJcbiAgICAgICAgICAgICAgICAgICAgPyBbIG4xLnRvU3RyaW5nKCksIGQxLnRvU3RyaW5nKCkgXVxyXG4gICAgICAgICAgICAgICAgICAgIDogWyBuMC50b1N0cmluZygpLCBkMC50b1N0cmluZygpIF07XHJcblxyXG4gICAgICAgICAgICBNQVhfRVhQID0gZXhwO1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgY29udmVydGVkIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgeCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAvLyBFbnN1cmUgemVybyBoYXMgY29ycmVjdCBzaWduLlxyXG4gICAgICAgICAgICByZXR1cm4gK3ggfHwgKCB4LnMgPyB4LnMgKiAwIDogTmFOICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByYWlzZWQgdG8gdGhlIHBvd2VyIG4uXHJcbiAgICAgICAgICogSWYgbiBpcyBuZWdhdGl2ZSByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgICAgICogSWYgUE9XX1BSRUNJU0lPTiBpcyBub3QgMCwgcm91bmQgdG8gUE9XX1BSRUNJU0lPTiB1c2luZyBST1VORElOR19NT0RFLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogbiB7bnVtYmVyfSBJbnRlZ2VyLCAtOTAwNzE5OTI1NDc0MDk5MiB0byA5MDA3MTk5MjU0NzQwOTkyIGluY2x1c2l2ZS5cclxuICAgICAgICAgKiAoUGVyZm9ybXMgNTQgbG9vcCBpdGVyYXRpb25zIGZvciBuIG9mIDkwMDcxOTkyNTQ3NDA5OTIuKVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogJ3BvdygpIGV4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiB7bn0nXHJcbiAgICAgICAgICogJ3BvdygpIGV4cG9uZW50IG91dCBvZiByYW5nZToge259J1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudG9Qb3dlciA9IFAucG93ID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgdmFyIGssIHksXHJcbiAgICAgICAgICAgICAgICBpID0gbWF0aGZsb29yKCBuIDwgMCA/IC1uIDogK24gKSxcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgLy8gUGFzcyDCsUluZmluaXR5IHRvIE1hdGgucG93IGlmIGV4cG9uZW50IGlzIG91dCBvZiByYW5nZS5cclxuICAgICAgICAgICAgaWYgKCAhaXNWYWxpZEludCggbiwgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIsIDIzLCAnZXhwb25lbnQnICkgJiZcclxuICAgICAgICAgICAgICAoICFpc0Zpbml0ZShuKSB8fCBpID4gTUFYX1NBRkVfSU5URUdFUiAmJiAoIG4gLz0gMCApIHx8XHJcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KG4pICE9IG4gJiYgISggbiA9IE5hTiApICkgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlciggTWF0aC5wb3coICt4LCBuICkgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVHJ1bmNhdGluZyBlYWNoIGNvZWZmaWNpZW50IGFycmF5IHRvIGEgbGVuZ3RoIG9mIGsgYWZ0ZXIgZWFjaCBtdWx0aXBsaWNhdGlvbiBlcXVhdGVzXHJcbiAgICAgICAgICAgIC8vIHRvIHRydW5jYXRpbmcgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIFBPV19QUkVDSVNJT04gKyBbMjgsIDQxXSwgaS5lLiB0aGVyZSB3aWxsIGJlIGFcclxuICAgICAgICAgICAgLy8gbWluaW11bSBvZiAyOCBndWFyZCBkaWdpdHMgcmV0YWluZWQuIChVc2luZyArIDEuNSB3b3VsZCBnaXZlIFs5LCAyMV0gZ3VhcmQgZGlnaXRzLilcclxuICAgICAgICAgICAgayA9IFBPV19QUkVDSVNJT04gPyBtYXRoY2VpbCggUE9XX1BSRUNJU0lPTiAvIExPR19CQVNFICsgMiApIDogMDtcclxuICAgICAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIDsgOyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGkgJSAyICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSB5LnRpbWVzKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXkuYyApIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggayAmJiB5LmMubGVuZ3RoID4gayApIHkuYy5sZW5ndGggPSBrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGkgPSBtYXRoZmxvb3IoIGkgLyAyICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoICFpICkgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgeCA9IHgudGltZXMoeCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGsgJiYgeC5jICYmIHguYy5sZW5ndGggPiBrICkgeC5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggbiA8IDAgKSB5ID0gT05FLmRpdih5KTtcclxuICAgICAgICAgICAgcmV0dXJuIGsgPyByb3VuZCggeSwgUE9XX1BSRUNJU0lPTiwgUk9VTkRJTkdfTU9ERSApIDogeTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICAgICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0gb3IgUk9VTkRJTkdfTU9ERS4gSWYgc2QgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzXHJcbiAgICAgICAgICogbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiwgdGhlbiB1c2VcclxuICAgICAgICAgKiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogJ3RvUHJlY2lzaW9uKCkgcHJlY2lzaW9uIG5vdCBhbiBpbnRlZ2VyOiB7c2R9J1xyXG4gICAgICAgICAqICd0b1ByZWNpc2lvbigpIHByZWNpc2lvbiBvdXQgb2YgcmFuZ2U6IHtzZH0nXHJcbiAgICAgICAgICogJ3RvUHJlY2lzaW9uKCkgcm91bmRpbmcgbW9kZSBub3QgYW4gaW50ZWdlcjoge3JtfSdcclxuICAgICAgICAgKiAndG9QcmVjaXNpb24oKSByb3VuZGluZyBtb2RlIG91dCBvZiByYW5nZToge3JtfSdcclxuICAgICAgICAgKi9cclxuICAgICAgICBQLnRvUHJlY2lzaW9uID0gZnVuY3Rpb24gKCBzZCwgcm0gKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQoIHRoaXMsIHNkICE9IG51bGwgJiYgaXNWYWxpZEludCggc2QsIDEsIE1BWCwgMjQsICdwcmVjaXNpb24nIClcclxuICAgICAgICAgICAgICA/IHNkIHwgMCA6IG51bGwsIHJtLCAyNCApO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGJhc2UgYiwgb3IgYmFzZSAxMCBpZiBiIGlzXHJcbiAgICAgICAgICogb21pdHRlZC4gSWYgYSBiYXNlIGlzIHNwZWNpZmllZCwgaW5jbHVkaW5nIGJhc2UgMTAsIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmRcclxuICAgICAgICAgKiBST1VORElOR19NT0RFLiBJZiBhIGJhc2UgaXMgbm90IHNwZWNpZmllZCwgYW5kIHRoaXMgQmlnTnVtYmVyIGhhcyBhIHBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICAgICAgICogdGhhdCBpcyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gVE9fRVhQX1BPUywgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW5cclxuICAgICAgICAgKiBUT19FWFBfTkVHLCByZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBbYl0ge251bWJlcn0gSW50ZWdlciwgMiB0byA2NCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAndG9TdHJpbmcoKSBiYXNlIG5vdCBhbiBpbnRlZ2VyOiB7Yn0nXHJcbiAgICAgICAgICogJ3RvU3RyaW5nKCkgYmFzZSBvdXQgb2YgcmFuZ2U6IHtifSdcclxuICAgICAgICAgKi9cclxuICAgICAgICBQLnRvU3RyaW5nID0gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgdmFyIHN0cixcclxuICAgICAgICAgICAgICAgIG4gPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgcyA9IG4ucyxcclxuICAgICAgICAgICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICAgICAgICAvLyBJbmZpbml0eSBvciBOYU4/XHJcbiAgICAgICAgICAgIGlmICggZSA9PT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9ICdJbmZpbml0eSc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzIDwgMCApIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJ05hTic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKCBuLmMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGIgPT0gbnVsbCB8fCAhaXNWYWxpZEludCggYiwgMiwgNjQsIDI1LCAnYmFzZScgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgICAgICAgICAgICAgICA/IHRvRXhwb25lbnRpYWwoIHN0ciwgZSApXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IHRvRml4ZWRQb2ludCggc3RyLCBlICk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKCB0b0ZpeGVkUG9pbnQoIHN0ciwgZSApLCBiIHwgMCwgMTAsIHMgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHMgPCAwICYmIG4uY1swXSApIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciB0cnVuY2F0ZWQgdG8gYSB3aG9sZVxyXG4gICAgICAgICAqIG51bWJlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLnRydW5jYXRlZCA9IFAudHJ1bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByb3VuZCggbmV3IEJpZ051bWJlcih0aGlzKSwgdGhpcy5lICsgMSwgMSApO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYXMgdG9TdHJpbmcsIGJ1dCBkbyBub3QgYWNjZXB0IGEgYmFzZSBhcmd1bWVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLnZhbHVlT2YgPSBQLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLy8gQWxpYXNlcyBmb3IgQmlnRGVjaW1hbCBtZXRob2RzLlxyXG4gICAgICAgIC8vUC5hZGQgPSBQLnBsdXM7ICAgICAgICAgLy8gUC5hZGQgaW5jbHVkZWQgYWJvdmVcclxuICAgICAgICAvL1Auc3VidHJhY3QgPSBQLm1pbnVzOyAgIC8vIFAuc3ViIGluY2x1ZGVkIGFib3ZlXHJcbiAgICAgICAgLy9QLm11bHRpcGx5ID0gUC50aW1lczsgICAvLyBQLm11bCBpbmNsdWRlZCBhYm92ZVxyXG4gICAgICAgIC8vUC5kaXZpZGUgPSBQLmRpdjtcclxuICAgICAgICAvL1AucmVtYWluZGVyID0gUC5tb2Q7XHJcbiAgICAgICAgLy9QLmNvbXBhcmVUbyA9IFAuY21wO1xyXG4gICAgICAgIC8vUC5uZWdhdGUgPSBQLm5lZztcclxuXHJcblxyXG4gICAgICAgIGlmICggY29uZmlnT2JqICE9IG51bGwgKSBCaWdOdW1iZXIuY29uZmlnKGNvbmZpZ09iaik7XHJcblxyXG4gICAgICAgIHJldHVybiBCaWdOdW1iZXI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIFBSSVZBVEUgSEVMUEVSIEZVTkNUSU9OU1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBiaXRGbG9vcihuKSB7XHJcbiAgICAgICAgdmFyIGkgPSBuIHwgMDtcclxuICAgICAgICByZXR1cm4gbiA+IDAgfHwgbiA9PT0gaSA/IGkgOiBpIC0gMTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gUmV0dXJuIGEgY29lZmZpY2llbnQgYXJyYXkgYXMgYSBzdHJpbmcgb2YgYmFzZSAxMCBkaWdpdHMuXHJcbiAgICBmdW5jdGlvbiBjb2VmZlRvU3RyaW5nKGEpIHtcclxuICAgICAgICB2YXIgcywgeixcclxuICAgICAgICAgICAgaSA9IDEsXHJcbiAgICAgICAgICAgIGogPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgciA9IGFbMF0gKyAnJztcclxuXHJcbiAgICAgICAgZm9yICggOyBpIDwgajsgKSB7XHJcbiAgICAgICAgICAgIHMgPSBhW2krK10gKyAnJztcclxuICAgICAgICAgICAgeiA9IExPR19CQVNFIC0gcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoIDsgei0tOyBzID0gJzAnICsgcyApO1xyXG4gICAgICAgICAgICByICs9IHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICggaiA9IHIubGVuZ3RoOyByLmNoYXJDb2RlQXQoLS1qKSA9PT0gNDg7ICk7XHJcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoIDAsIGogKyAxIHx8IDEgKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQ29tcGFyZSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVycyB4IGFuZCB5LlxyXG4gICAgZnVuY3Rpb24gY29tcGFyZSggeCwgeSApIHtcclxuICAgICAgICB2YXIgYSwgYixcclxuICAgICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICAgIHljID0geS5jLFxyXG4gICAgICAgICAgICBpID0geC5zLFxyXG4gICAgICAgICAgICBqID0geS5zLFxyXG4gICAgICAgICAgICBrID0geC5lLFxyXG4gICAgICAgICAgICBsID0geS5lO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICAgIGlmICggIWkgfHwgIWogKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgYSA9IHhjICYmICF4Y1swXTtcclxuICAgICAgICBiID0geWMgJiYgIXljWzBdO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICBpZiAoIGEgfHwgYiApIHJldHVybiBhID8gYiA/IDAgOiAtaiA6IGk7XHJcblxyXG4gICAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgICBpZiAoIGkgIT0gaiApIHJldHVybiBpO1xyXG5cclxuICAgICAgICBhID0gaSA8IDA7XHJcbiAgICAgICAgYiA9IGsgPT0gbDtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgICAgIGlmICggIXhjIHx8ICF5YyApIHJldHVybiBiID8gMCA6ICF4YyBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgICAgIC8vIENvbXBhcmUgZXhwb25lbnRzLlxyXG4gICAgICAgIGlmICggIWIgKSByZXR1cm4gayA+IGwgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgICAgICBqID0gKCBrID0geGMubGVuZ3RoICkgPCAoIGwgPSB5Yy5sZW5ndGggKSA/IGsgOiBsO1xyXG5cclxuICAgICAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgajsgaSsrICkgaWYgKCB4Y1tpXSAhPSB5Y1tpXSApIHJldHVybiB4Y1tpXSA+IHljW2ldIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAgICAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gICAgICAgIHJldHVybiBrID09IGwgPyAwIDogayA+IGwgXiBhID8gMSA6IC0xO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgbiBpcyBhIHZhbGlkIG51bWJlciBpbiByYW5nZSwgb3RoZXJ3aXNlIGZhbHNlLlxyXG4gICAgICogVXNlIGZvciBhcmd1bWVudCB2YWxpZGF0aW9uIHdoZW4gRVJST1JTIGlzIGZhbHNlLlxyXG4gICAgICogTm90ZTogcGFyc2VJbnQoJzFlKzEnKSA9PSAxIGJ1dCBwYXJzZUZsb2F0KCcxZSsxJykgPT0gMTAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGludFZhbGlkYXRvck5vRXJyb3JzKCBuLCBtaW4sIG1heCApIHtcclxuICAgICAgICByZXR1cm4gKCBuID0gdHJ1bmNhdGUobikgKSA+PSBtaW4gJiYgbiA8PSBtYXg7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBDb252ZXJ0IHN0cmluZyBvZiBiYXNlSW4gdG8gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBiYXNlT3V0LlxyXG4gICAgICogRWcuIGNvbnZlcnRCYXNlKCcyNTUnLCAxMCwgMTYpIHJldHVybnMgWzE1LCAxNV0uXHJcbiAgICAgKiBFZy4gY29udmVydEJhc2UoJ2ZmJywgMTYsIDEwKSByZXR1cm5zIFsyLCA1LCA1XS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdG9CYXNlT3V0KCBzdHIsIGJhc2VJbiwgYmFzZU91dCApIHtcclxuICAgICAgICB2YXIgaixcclxuICAgICAgICAgICAgYXJyID0gWzBdLFxyXG4gICAgICAgICAgICBhcnJMLFxyXG4gICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yICggOyBpIDwgbGVuOyApIHtcclxuICAgICAgICAgICAgZm9yICggYXJyTCA9IGFyci5sZW5ndGg7IGFyckwtLTsgYXJyW2FyckxdICo9IGJhc2VJbiApO1xyXG4gICAgICAgICAgICBhcnJbIGogPSAwIF0gKz0gQUxQSEFCRVQuaW5kZXhPZiggc3RyLmNoYXJBdCggaSsrICkgKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIDsgaiA8IGFyci5sZW5ndGg7IGorKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGFycltqXSA+IGJhc2VPdXQgLSAxICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggYXJyW2ogKyAxXSA9PSBudWxsICkgYXJyW2ogKyAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IHwgMDtcclxuICAgICAgICAgICAgICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHRvRXhwb25lbnRpYWwoIHN0ciwgZSApIHtcclxuICAgICAgICByZXR1cm4gKCBzdHIubGVuZ3RoID4gMSA/IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSkgOiBzdHIgKSArXHJcbiAgICAgICAgICAoIGUgPCAwID8gJ2UnIDogJ2UrJyApICsgZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdG9GaXhlZFBvaW50KCBzdHIsIGUgKSB7XHJcbiAgICAgICAgdmFyIGxlbiwgejtcclxuXHJcbiAgICAgICAgLy8gTmVnYXRpdmUgZXhwb25lbnQ/XHJcbiAgICAgICAgaWYgKCBlIDwgMCApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFByZXBlbmQgemVyb3MuXHJcbiAgICAgICAgICAgIGZvciAoIHogPSAnMC4nOyArK2U7IHogKz0gJzAnICk7XHJcbiAgICAgICAgICAgIHN0ciA9IHogKyBzdHI7XHJcblxyXG4gICAgICAgIC8vIFBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcy5cclxuICAgICAgICAgICAgaWYgKCArK2UgPiBsZW4gKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKCB6ID0gJzAnLCBlIC09IGxlbjsgLS1lOyB6ICs9ICcwJyApO1xyXG4gICAgICAgICAgICAgICAgc3RyICs9IHo7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGUgPCBsZW4gKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoIDAsIGUgKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGUobikge1xyXG4gICAgICAgIG4gPSBwYXJzZUZsb2F0KG4pO1xyXG4gICAgICAgIHJldHVybiBuIDwgMCA/IG1hdGhjZWlsKG4pIDogbWF0aGZsb29yKG4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBFWFBPUlRcclxuXHJcblxyXG4gICAgQmlnTnVtYmVyID0gYW5vdGhlcigpO1xyXG5cclxuICAgIC8vIEFNRC5cclxuICAgIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XHJcbiAgICAgICAgZGVmaW5lKCBmdW5jdGlvbiAoKSB7IHJldHVybiBCaWdOdW1iZXI7IH0gKTtcclxuXHJcbiAgICAvLyBOb2RlIGFuZCBvdGhlciBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLlxyXG4gICAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEJpZ051bWJlcjtcclxuICAgICAgICBpZiAoICFjcnlwdG8gKSB0cnkgeyBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTsgfSBjYXRjaCAoZSkge31cclxuXHJcbiAgICAvLyBCcm93c2VyLlxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBnbG9iYWwuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG4gICAgfVxyXG59KSh0aGlzKTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbXlzcWwvfi9iaWdudW1iZXIuanMvYmlnbnVtYmVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMuQ2hhbmdlVXNlciA9IHJlcXVpcmUoJy4vQ2hhbmdlVXNlcicpO1xuZXhwb3J0cy5IYW5kc2hha2UgPSByZXF1aXJlKCcuL0hhbmRzaGFrZScpO1xuZXhwb3J0cy5QaW5nID0gcmVxdWlyZSgnLi9QaW5nJyk7XG5leHBvcnRzLlF1ZXJ5ID0gcmVxdWlyZSgnLi9RdWVyeScpO1xuZXhwb3J0cy5RdWl0ID0gcmVxdWlyZSgnLi9RdWl0Jyk7XG5leHBvcnRzLlNlcXVlbmNlID0gcmVxdWlyZSgnLi9TZXF1ZW5jZScpO1xuZXhwb3J0cy5TdGF0aXN0aWNzID0gcmVxdWlyZSgnLi9TdGF0aXN0aWNzJyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9saWIvcHJvdG9jb2wvc2VxdWVuY2VzL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBTZXF1ZW5jZSA9IHJlcXVpcmUoJy4vU2VxdWVuY2UnKTtcbnZhciBVdGlsICAgICA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBQYWNrZXRzICA9IHJlcXVpcmUoJy4uL3BhY2tldHMnKTtcbnZhciBBdXRoICAgICA9IHJlcXVpcmUoJy4uL0F1dGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFuZ2VVc2VyO1xuVXRpbC5pbmhlcml0cyhDaGFuZ2VVc2VyLCBTZXF1ZW5jZSk7XG5mdW5jdGlvbiBDaGFuZ2VVc2VyKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIFNlcXVlbmNlLmNhbGwodGhpcywgb3B0aW9ucywgY2FsbGJhY2spO1xuXG4gIHRoaXMuX3VzZXIgICAgICAgICAgPSBvcHRpb25zLnVzZXI7XG4gIHRoaXMuX3Bhc3N3b3JkICAgICAgPSBvcHRpb25zLnBhc3N3b3JkO1xuICB0aGlzLl9kYXRhYmFzZSAgICAgID0gb3B0aW9ucy5kYXRhYmFzZTtcbiAgdGhpcy5fY2hhcnNldE51bWJlciA9IG9wdGlvbnMuY2hhcnNldE51bWJlcjtcbiAgdGhpcy5fY3VycmVudENvbmZpZyA9IG9wdGlvbnMuY3VycmVudENvbmZpZztcbn1cblxuQ2hhbmdlVXNlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihoYW5kc2hha2VJbml0aWFsaXphdGlvblBhY2tldCkge1xuICB2YXIgc2NyYW1ibGVCdWZmID0gaGFuZHNoYWtlSW5pdGlhbGl6YXRpb25QYWNrZXQuc2NyYW1ibGVCdWZmKCk7XG4gIHNjcmFtYmxlQnVmZiAgICAgPSBBdXRoLnRva2VuKHRoaXMuX3Bhc3N3b3JkLCBzY3JhbWJsZUJ1ZmYpO1xuXG4gIHZhciBwYWNrZXQgPSBuZXcgUGFja2V0cy5Db21DaGFuZ2VVc2VyUGFja2V0KHtcbiAgICB1c2VyICAgICAgICAgIDogdGhpcy5fdXNlcixcbiAgICBzY3JhbWJsZUJ1ZmYgIDogc2NyYW1ibGVCdWZmLFxuICAgIGRhdGFiYXNlICAgICAgOiB0aGlzLl9kYXRhYmFzZSxcbiAgICBjaGFyc2V0TnVtYmVyIDogdGhpcy5fY2hhcnNldE51bWJlcixcbiAgfSk7XG5cbiAgdGhpcy5fY3VycmVudENvbmZpZy51c2VyICAgICAgICAgID0gdGhpcy5fdXNlcjtcbiAgdGhpcy5fY3VycmVudENvbmZpZy5wYXNzd29yZCAgICAgID0gdGhpcy5fcGFzc3dvcmQ7XG4gIHRoaXMuX2N1cnJlbnRDb25maWcuZGF0YWJhc2UgICAgICA9IHRoaXMuX2RhdGFiYXNlO1xuICB0aGlzLl9jdXJyZW50Q29uZmlnLmNoYXJzZXROdW1iZXIgPSB0aGlzLl9jaGFyc2V0TnVtYmVyO1xuXG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbkNoYW5nZVVzZXIucHJvdG90eXBlWydFcnJvclBhY2tldCddID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHZhciBlcnIgPSB0aGlzLl9wYWNrZXRUb0Vycm9yKHBhY2tldCk7XG4gIGVyci5mYXRhbCA9IHRydWU7XG4gIHRoaXMuZW5kKGVycik7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbXlzcWwvbGliL3Byb3RvY29sL3NlcXVlbmNlcy9DaGFuZ2VVc2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBVdGlsICAgICAgICAgICA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBFdmVudEVtaXR0ZXIgICA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBQYWNrZXRzICAgICAgICA9IHJlcXVpcmUoJy4uL3BhY2tldHMnKTtcbnZhciBFcnJvckNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9lcnJvcnMnKTtcblxudmFyIGxpc3RlbmVyQ291bnQgPSBFdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudFxuICB8fCBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKXsgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXF1ZW5jZTtcblV0aWwuaW5oZXJpdHMoU2VxdWVuY2UsIEV2ZW50RW1pdHRlcik7XG5mdW5jdGlvbiBTZXF1ZW5jZShvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgdGhpcy5fY2FsbFNpdGUgPSBudWxsO1xuICB0aGlzLl9lbmRlZCAgICA9IGZhbHNlO1xuICB0aGlzLl90aW1lb3V0ICA9IG9wdGlvbnMudGltZW91dDtcblxuICAvLyBGb3IgVGltZXJzXG4gIHRoaXMuX2lkbGVOZXh0ICAgID0gbnVsbDtcbiAgdGhpcy5faWRsZVByZXYgICAgPSBudWxsO1xuICB0aGlzLl9pZGxlU3RhcnQgICA9IG51bGw7XG4gIHRoaXMuX2lkbGVUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICB0aGlzLl9yZXBlYXQgICAgICA9IG51bGw7XG59XG5cblNlcXVlbmNlLmRldGVybWluZVBhY2tldCA9IGZ1bmN0aW9uKGJ5dGUpIHtcbiAgc3dpdGNoIChieXRlKSB7XG4gICAgY2FzZSAweDAwOiByZXR1cm4gUGFja2V0cy5Pa1BhY2tldDtcbiAgICBjYXNlIDB4ZmU6IHJldHVybiBQYWNrZXRzLkVvZlBhY2tldDtcbiAgICBjYXNlIDB4ZmY6IHJldHVybiBQYWNrZXRzLkVycm9yUGFja2V0O1xuICB9XG59O1xuXG5TZXF1ZW5jZS5wcm90b3R5cGUuaGFzRXJyb3JIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBCb29sZWFuKHRoaXMuX2NhbGxiYWNrKSB8fCBsaXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID4gMTtcbn07XG5cblNlcXVlbmNlLnByb3RvdHlwZS5fcGFja2V0VG9FcnJvciA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICB2YXIgY29kZSA9IEVycm9yQ29uc3RhbnRzW3BhY2tldC5lcnJub10gfHwgJ1VOS05PV05fQ09ERV9QTEVBU0VfUkVQT1JUJztcbiAgdmFyIGVyciAgPSBuZXcgRXJyb3IoY29kZSArICc6ICcgKyBwYWNrZXQubWVzc2FnZSk7XG4gIGVyci5jb2RlID0gY29kZTtcbiAgZXJyLmVycm5vID0gcGFja2V0LmVycm5vO1xuICBlcnIuc3FsU3RhdGUgPSBwYWNrZXQuc3FsU3RhdGU7XG5cbiAgcmV0dXJuIGVycjtcbn07XG5cblNlcXVlbmNlLnByb3RvdHlwZS5fYWRkTG9uZ1N0YWNrVHJhY2UgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKCF0aGlzLl9jYWxsU2l0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkZWxpbWl0ZXIgPSAnXFxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuJyA7XG5cbiAgaWYgKGVyci5zdGFjay5pbmRleE9mKGRlbGltaXRlcikgPiAtMSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVyci5zdGFjayArPSBkZWxpbWl0ZXIgKyB0aGlzLl9jYWxsU2l0ZS5zdGFjay5yZXBsYWNlKC8uK1xcbi8sICcnKTtcbn07XG5cblNlcXVlbmNlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKHRoaXMuX2VuZGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fZW5kZWQgPSB0cnVlO1xuXG4gIGlmIChlcnIpIHtcbiAgICB0aGlzLl9hZGRMb25nU3RhY2tUcmFjZShlcnIpO1xuICB9XG5cbiAgLy8gV2l0aG91dCB0aGlzIHdlIGFyZSBsZWFraW5nIG1lbW9yeS4gVGhpcyBwcm9ibGVtIHdhcyBpbnRyb2R1Y2VkIGluXG4gIC8vIDgxODk5MjUzNzRlN2NlMzgxOWJiZTg4YjY0YzdiMTVhYmFjOTZiMTYuIEkgc3VzcGVjdCB0aGF0IHRoZSBlcnJvciBvYmplY3RcbiAgLy8gY2F1c2VzIGEgY3ljbGljIHJlZmVyZW5jZSB0aGF0IHRoZSBHQyBkb2VzIG5vdCBkZXRlY3QgcHJvcGVybHksIGJ1dCBJIHdhc1xuICAvLyB1bmFibGUgdG8gcHJvZHVjZSBhIHN0YW5kYWxvbmUgdmVyc2lvbiBvZiB0aGlzIGxlYWsuIFRoaXMgd291bGQgYmUgYSBncmVhdFxuICAvLyBjaGFsbGVuZ2UgZm9yIHNvbWVib2R5IGludGVyZXN0ZWQgaW4gZGlmZmljdWx0IHByb2JsZW1zIDogKSFcbiAgdGhpcy5fY2FsbFNpdGUgPSBudWxsO1xuXG4gIC8vIHRyeS4uLmZpbmFsbHkgZm9yIGV4Y2VwdGlvbiBzYWZldHlcbiAgdHJ5IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLl9jYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9jYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmVtaXQoJ2VuZCcpO1xuICAgIH1cbiAgfVxufTtcblxuU2VxdWVuY2UucHJvdG90eXBlWydPa1BhY2tldCddID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHRoaXMuZW5kKG51bGwsIHBhY2tldCk7XG59O1xuXG5TZXF1ZW5jZS5wcm90b3R5cGVbJ0Vycm9yUGFja2V0J10gPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgdGhpcy5lbmQodGhpcy5fcGFja2V0VG9FcnJvcihwYWNrZXQpKTtcbn07XG5cbi8vIEltcGxlbWVudGVkIGJ5IGNoaWxkIGNsYXNzZXNcblNlcXVlbmNlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge307XG5cblNlcXVlbmNlLnByb3RvdHlwZS5fb25UaW1lb3V0ID0gZnVuY3Rpb24gX29uVGltZW91dCgpIHtcbiAgdGhpcy5lbWl0KCd0aW1lb3V0Jyk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbXlzcWwvbGliL3Byb3RvY29sL3NlcXVlbmNlcy9TZXF1ZW5jZS5qc1xuICoqIG1vZHVsZSBpZCA9IDMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJ1dGlsXCJcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJldmVudHNcIlxuICoqIG1vZHVsZSBpZCA9IDM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLkNsaWVudEF1dGhlbnRpY2F0aW9uUGFja2V0ID0gcmVxdWlyZSgnLi9DbGllbnRBdXRoZW50aWNhdGlvblBhY2tldCcpO1xuZXhwb3J0cy5Db21DaGFuZ2VVc2VyUGFja2V0ID0gcmVxdWlyZSgnLi9Db21DaGFuZ2VVc2VyUGFja2V0Jyk7XG5leHBvcnRzLkNvbVBpbmdQYWNrZXQgPSByZXF1aXJlKCcuL0NvbVBpbmdQYWNrZXQnKTtcbmV4cG9ydHMuQ29tUXVlcnlQYWNrZXQgPSByZXF1aXJlKCcuL0NvbVF1ZXJ5UGFja2V0Jyk7XG5leHBvcnRzLkNvbVF1aXRQYWNrZXQgPSByZXF1aXJlKCcuL0NvbVF1aXRQYWNrZXQnKTtcbmV4cG9ydHMuQ29tU3RhdGlzdGljc1BhY2tldCA9IHJlcXVpcmUoJy4vQ29tU3RhdGlzdGljc1BhY2tldCcpO1xuZXhwb3J0cy5FbXB0eVBhY2tldCA9IHJlcXVpcmUoJy4vRW1wdHlQYWNrZXQnKTtcbmV4cG9ydHMuRW9mUGFja2V0ID0gcmVxdWlyZSgnLi9Fb2ZQYWNrZXQnKTtcbmV4cG9ydHMuRXJyb3JQYWNrZXQgPSByZXF1aXJlKCcuL0Vycm9yUGFja2V0Jyk7XG5leHBvcnRzLkZpZWxkID0gcmVxdWlyZSgnLi9GaWVsZCcpO1xuZXhwb3J0cy5GaWVsZFBhY2tldCA9IHJlcXVpcmUoJy4vRmllbGRQYWNrZXQnKTtcbmV4cG9ydHMuSGFuZHNoYWtlSW5pdGlhbGl6YXRpb25QYWNrZXQgPSByZXF1aXJlKCcuL0hhbmRzaGFrZUluaXRpYWxpemF0aW9uUGFja2V0Jyk7XG5leHBvcnRzLkxvY2FsRGF0YUZpbGVQYWNrZXQgPSByZXF1aXJlKCcuL0xvY2FsRGF0YUZpbGVQYWNrZXQnKTtcbmV4cG9ydHMuT2tQYWNrZXQgPSByZXF1aXJlKCcuL09rUGFja2V0Jyk7XG5leHBvcnRzLk9sZFBhc3N3b3JkUGFja2V0ID0gcmVxdWlyZSgnLi9PbGRQYXNzd29yZFBhY2tldCcpO1xuZXhwb3J0cy5SZXN1bHRTZXRIZWFkZXJQYWNrZXQgPSByZXF1aXJlKCcuL1Jlc3VsdFNldEhlYWRlclBhY2tldCcpO1xuZXhwb3J0cy5Sb3dEYXRhUGFja2V0ID0gcmVxdWlyZSgnLi9Sb3dEYXRhUGFja2V0Jyk7XG5leHBvcnRzLlNTTFJlcXVlc3RQYWNrZXQgPSByZXF1aXJlKCcuL1NTTFJlcXVlc3RQYWNrZXQnKTtcbmV4cG9ydHMuU3RhdGlzdGljc1BhY2tldCA9IHJlcXVpcmUoJy4vU3RhdGlzdGljc1BhY2tldCcpO1xuZXhwb3J0cy5Vc2VPbGRQYXNzd29yZFBhY2tldCA9IHJlcXVpcmUoJy4vVXNlT2xkUGFzc3dvcmRQYWNrZXQnKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL2xpYi9wcm90b2NvbC9wYWNrZXRzL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gQ2xpZW50QXV0aGVudGljYXRpb25QYWNrZXQ7XG5mdW5jdGlvbiBDbGllbnRBdXRoZW50aWNhdGlvblBhY2tldChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMuY2xpZW50RmxhZ3MgICA9IG9wdGlvbnMuY2xpZW50RmxhZ3M7XG4gIHRoaXMubWF4UGFja2V0U2l6ZSA9IG9wdGlvbnMubWF4UGFja2V0U2l6ZTtcbiAgdGhpcy5jaGFyc2V0TnVtYmVyID0gb3B0aW9ucy5jaGFyc2V0TnVtYmVyO1xuICB0aGlzLmZpbGxlciAgICAgICAgPSB1bmRlZmluZWQ7XG4gIHRoaXMudXNlciAgICAgICAgICA9IG9wdGlvbnMudXNlcjtcbiAgdGhpcy5zY3JhbWJsZUJ1ZmYgID0gb3B0aW9ucy5zY3JhbWJsZUJ1ZmY7XG4gIHRoaXMuZGF0YWJhc2UgICAgICA9IG9wdGlvbnMuZGF0YWJhc2U7XG4gIHRoaXMucHJvdG9jb2w0MSAgICA9IG9wdGlvbnMucHJvdG9jb2w0MTtcbn1cblxuQ2xpZW50QXV0aGVudGljYXRpb25QYWNrZXQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24ocGFyc2VyKSB7XG4gIGlmICh0aGlzLnByb3RvY29sNDEpIHtcbiAgICB0aGlzLmNsaWVudEZsYWdzICAgPSBwYXJzZXIucGFyc2VVbnNpZ25lZE51bWJlcig0KTtcbiAgICB0aGlzLm1heFBhY2tldFNpemUgPSBwYXJzZXIucGFyc2VVbnNpZ25lZE51bWJlcig0KTtcbiAgICB0aGlzLmNoYXJzZXROdW1iZXIgPSBwYXJzZXIucGFyc2VVbnNpZ25lZE51bWJlcigxKTtcbiAgICB0aGlzLmZpbGxlciAgICAgICAgPSBwYXJzZXIucGFyc2VGaWxsZXIoMjMpO1xuICAgIHRoaXMudXNlciAgICAgICAgICA9IHBhcnNlci5wYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKCk7XG4gICAgdGhpcy5zY3JhbWJsZUJ1ZmYgID0gcGFyc2VyLnBhcnNlTGVuZ3RoQ29kZWRCdWZmZXIoKTtcbiAgICB0aGlzLmRhdGFiYXNlICAgICAgPSBwYXJzZXIucGFyc2VOdWxsVGVybWluYXRlZFN0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuY2xpZW50RmxhZ3MgICA9IHBhcnNlci5wYXJzZVVuc2lnbmVkTnVtYmVyKDIpO1xuICAgIHRoaXMubWF4UGFja2V0U2l6ZSA9IHBhcnNlci5wYXJzZVVuc2lnbmVkTnVtYmVyKDMpO1xuICAgIHRoaXMudXNlciAgICAgICAgICA9IHBhcnNlci5wYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKCk7XG4gICAgdGhpcy5zY3JhbWJsZUJ1ZmYgID0gcGFyc2VyLnBhcnNlQnVmZmVyKDgpO1xuICAgIHRoaXMuZGF0YWJhc2UgICAgICA9IHBhcnNlci5wYXJzZUxlbmd0aENvZGVkQnVmZmVyKCk7XG4gIH1cbn07XG5cbkNsaWVudEF1dGhlbnRpY2F0aW9uUGFja2V0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHdyaXRlcikge1xuICBpZiAodGhpcy5wcm90b2NvbDQxKSB7XG4gICAgd3JpdGVyLndyaXRlVW5zaWduZWROdW1iZXIoNCwgdGhpcy5jbGllbnRGbGFncyk7XG4gICAgd3JpdGVyLndyaXRlVW5zaWduZWROdW1iZXIoNCwgdGhpcy5tYXhQYWNrZXRTaXplKTtcbiAgICB3cml0ZXIud3JpdGVVbnNpZ25lZE51bWJlcigxLCB0aGlzLmNoYXJzZXROdW1iZXIpO1xuICAgIHdyaXRlci53cml0ZUZpbGxlcigyMyk7XG4gICAgd3JpdGVyLndyaXRlTnVsbFRlcm1pbmF0ZWRTdHJpbmcodGhpcy51c2VyKTtcbiAgICB3cml0ZXIud3JpdGVMZW5ndGhDb2RlZEJ1ZmZlcih0aGlzLnNjcmFtYmxlQnVmZik7XG4gICAgd3JpdGVyLndyaXRlTnVsbFRlcm1pbmF0ZWRTdHJpbmcodGhpcy5kYXRhYmFzZSk7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVyLndyaXRlVW5zaWduZWROdW1iZXIoMiwgdGhpcy5jbGllbnRGbGFncyk7XG4gICAgd3JpdGVyLndyaXRlVW5zaWduZWROdW1iZXIoMywgdGhpcy5tYXhQYWNrZXRTaXplKTtcbiAgICB3cml0ZXIud3JpdGVOdWxsVGVybWluYXRlZFN0cmluZyh0aGlzLnVzZXIpO1xuICAgIHdyaXRlci53cml0ZUJ1ZmZlcih0aGlzLnNjcmFtYmxlQnVmZik7XG4gICAgaWYgKHRoaXMuZGF0YWJhc2UgJiYgdGhpcy5kYXRhYmFzZS5sZW5ndGgpIHtcbiAgICAgIHdyaXRlci53cml0ZUZpbGxlcigxKTtcbiAgICAgIHdyaXRlci53cml0ZUJ1ZmZlcihuZXcgQnVmZmVyKHRoaXMuZGF0YWJhc2UpKTtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9saWIvcHJvdG9jb2wvcGFja2V0cy9DbGllbnRBdXRoZW50aWNhdGlvblBhY2tldC5qc1xuICoqIG1vZHVsZSBpZCA9IDM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IENvbUNoYW5nZVVzZXJQYWNrZXQ7XG5mdW5jdGlvbiBDb21DaGFuZ2VVc2VyUGFja2V0KG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5jb21tYW5kICAgICAgID0gMHgxMTtcbiAgdGhpcy51c2VyICAgICAgICAgID0gb3B0aW9ucy51c2VyO1xuICB0aGlzLnNjcmFtYmxlQnVmZiAgPSBvcHRpb25zLnNjcmFtYmxlQnVmZjtcbiAgdGhpcy5kYXRhYmFzZSAgICAgID0gb3B0aW9ucy5kYXRhYmFzZTtcbiAgdGhpcy5jaGFyc2V0TnVtYmVyID0gb3B0aW9ucy5jaGFyc2V0TnVtYmVyO1xufVxuXG5Db21DaGFuZ2VVc2VyUGFja2V0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHBhcnNlcikge1xuICB0aGlzLmNvbW1hbmQgICAgICAgPSBwYXJzZXIucGFyc2VVbnNpZ25lZE51bWJlcigxKTtcbiAgdGhpcy51c2VyICAgICAgICAgID0gcGFyc2VyLnBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmcoKTtcbiAgdGhpcy5zY3JhbWJsZUJ1ZmYgID0gcGFyc2VyLnBhcnNlTGVuZ3RoQ29kZWRCdWZmZXIoKTtcbiAgdGhpcy5kYXRhYmFzZSAgICAgID0gcGFyc2VyLnBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmcoKTtcbiAgdGhpcy5jaGFyc2V0TnVtYmVyID0gcGFyc2VyLnBhcnNlVW5zaWduZWROdW1iZXIoMSk7XG59O1xuXG5Db21DaGFuZ2VVc2VyUGFja2V0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHdyaXRlcikge1xuICB3cml0ZXIud3JpdGVVbnNpZ25lZE51bWJlcigxLCB0aGlzLmNvbW1hbmQpO1xuICB3cml0ZXIud3JpdGVOdWxsVGVybWluYXRlZFN0cmluZyh0aGlzLnVzZXIpO1xuICB3cml0ZXIud3JpdGVMZW5ndGhDb2RlZEJ1ZmZlcih0aGlzLnNjcmFtYmxlQnVmZik7XG4gIHdyaXRlci53cml0ZU51bGxUZXJtaW5hdGVkU3RyaW5nKHRoaXMuZGF0YWJhc2UpO1xuICB3cml0ZXIud3JpdGVVbnNpZ25lZE51bWJlcigyLCB0aGlzLmNoYXJzZXROdW1iZXIpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL2xpYi9wcm90b2NvbC9wYWNrZXRzL0NvbUNoYW5nZVVzZXJQYWNrZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBDb21QaW5nUGFja2V0O1xuZnVuY3Rpb24gQ29tUGluZ1BhY2tldChzcWwpIHtcbiAgdGhpcy5jb21tYW5kID0gMHgwZTtcbn1cblxuQ29tUGluZ1BhY2tldC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih3cml0ZXIpIHtcbiAgd3JpdGVyLndyaXRlVW5zaWduZWROdW1iZXIoMSwgdGhpcy5jb21tYW5kKTtcbn07XG5cbkNvbVBpbmdQYWNrZXQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24ocGFyc2VyKSB7XG4gIHRoaXMuY29tbWFuZCA9IHBhcnNlci5wYXJzZVVuc2lnbmVkTnVtYmVyKDEpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL2xpYi9wcm90b2NvbC9wYWNrZXRzL0NvbVBpbmdQYWNrZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBDb21RdWVyeVBhY2tldDtcbmZ1bmN0aW9uIENvbVF1ZXJ5UGFja2V0KHNxbCkge1xuICB0aGlzLmNvbW1hbmQgPSAweDAzO1xuICB0aGlzLnNxbCAgICAgPSBzcWw7XG59XG5cbkNvbVF1ZXJ5UGFja2V0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHdyaXRlcikge1xuICB3cml0ZXIud3JpdGVVbnNpZ25lZE51bWJlcigxLCB0aGlzLmNvbW1hbmQpO1xuICB3cml0ZXIud3JpdGVTdHJpbmcodGhpcy5zcWwpO1xufTtcblxuQ29tUXVlcnlQYWNrZXQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24ocGFyc2VyKSB7XG4gIHRoaXMuY29tbWFuZCA9IHBhcnNlci5wYXJzZVVuc2lnbmVkTnVtYmVyKDEpO1xuICB0aGlzLnNxbCAgICAgPSBwYXJzZXIucGFyc2VQYWNrZXRUZXJtaW5hdGVkU3RyaW5nKCk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbXlzcWwvbGliL3Byb3RvY29sL3BhY2tldHMvQ29tUXVlcnlQYWNrZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBDb21RdWl0UGFja2V0O1xuZnVuY3Rpb24gQ29tUXVpdFBhY2tldChzcWwpIHtcbiAgdGhpcy5jb21tYW5kID0gMHgwMTtcbn1cblxuQ29tUXVpdFBhY2tldC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShwYXJzZXIpIHtcbiAgdGhpcy5jb21tYW5kID0gcGFyc2VyLnBhcnNlVW5zaWduZWROdW1iZXIoMSk7XG59O1xuXG5Db21RdWl0UGFja2V0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlKHdyaXRlcikge1xuICB3cml0ZXIud3JpdGVVbnNpZ25lZE51bWJlcigxLCB0aGlzLmNvbW1hbmQpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL2xpYi9wcm90b2NvbC9wYWNrZXRzL0NvbVF1aXRQYWNrZXQuanNcbiAqKiBtb2R1bGUgaWQgPSA0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBDb21TdGF0aXN0aWNzUGFja2V0O1xuZnVuY3Rpb24gQ29tU3RhdGlzdGljc1BhY2tldChzcWwpIHtcbiAgdGhpcy5jb21tYW5kID0gMHgwOTtcbn1cblxuQ29tU3RhdGlzdGljc1BhY2tldC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih3cml0ZXIpIHtcbiAgd3JpdGVyLndyaXRlVW5zaWduZWROdW1iZXIoMSwgdGhpcy5jb21tYW5kKTtcbn07XG5cbkNvbVN0YXRpc3RpY3NQYWNrZXQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24ocGFyc2VyKSB7XG4gIHRoaXMuY29tbWFuZCA9IHBhcnNlci5wYXJzZVVuc2lnbmVkTnVtYmVyKDEpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL2xpYi9wcm90b2NvbC9wYWNrZXRzL0NvbVN0YXRpc3RpY3NQYWNrZXQuanNcbiAqKiBtb2R1bGUgaWQgPSA0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBFbXB0eVBhY2tldDtcbmZ1bmN0aW9uIEVtcHR5UGFja2V0KCkge1xufVxuXG5FbXB0eVBhY2tldC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih3cml0ZXIpIHtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9saWIvcHJvdG9jb2wvcGFja2V0cy9FbXB0eVBhY2tldC5qc1xuICoqIG1vZHVsZSBpZCA9IDQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IEVvZlBhY2tldDtcbmZ1bmN0aW9uIEVvZlBhY2tldChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMuZmllbGRDb3VudCAgID0gdW5kZWZpbmVkO1xuICB0aGlzLndhcm5pbmdDb3VudCA9IG9wdGlvbnMud2FybmluZ0NvdW50O1xuICB0aGlzLnNlcnZlclN0YXR1cyA9IG9wdGlvbnMuc2VydmVyU3RhdHVzO1xuICB0aGlzLnByb3RvY29sNDEgICA9IG9wdGlvbnMucHJvdG9jb2w0MTtcbn1cblxuRW9mUGFja2V0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHBhcnNlcikge1xuICB0aGlzLmZpZWxkQ291bnQgICA9IHBhcnNlci5wYXJzZVVuc2lnbmVkTnVtYmVyKDEpO1xuICBpZiAodGhpcy5wcm90b2NvbDQxKSB7XG4gICAgdGhpcy53YXJuaW5nQ291bnQgPSBwYXJzZXIucGFyc2VVbnNpZ25lZE51bWJlcigyKTtcbiAgICB0aGlzLnNlcnZlclN0YXR1cyA9IHBhcnNlci5wYXJzZVVuc2lnbmVkTnVtYmVyKDIpO1xuICB9XG59O1xuXG5Fb2ZQYWNrZXQucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24od3JpdGVyKSB7XG4gIHdyaXRlci53cml0ZVVuc2lnbmVkTnVtYmVyKDEsIDB4ZmUpO1xuICBpZiAodGhpcy5wcm90b2NvbDQxKSB7XG4gICAgd3JpdGVyLndyaXRlVW5zaWduZWROdW1iZXIoMiwgdGhpcy53YXJuaW5nQ291bnQpO1xuICAgIHdyaXRlci53cml0ZVVuc2lnbmVkTnVtYmVyKDIsIHRoaXMuc2VydmVyU3RhdHVzKTtcbiAgfVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL2xpYi9wcm90b2NvbC9wYWNrZXRzL0VvZlBhY2tldC5qc1xuICoqIG1vZHVsZSBpZCA9IDQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IEVycm9yUGFja2V0O1xuZnVuY3Rpb24gRXJyb3JQYWNrZXQob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLmZpZWxkQ291bnQgICAgID0gb3B0aW9ucy5maWVsZENvdW50O1xuICB0aGlzLmVycm5vICAgICAgICAgID0gb3B0aW9ucy5lcnJubztcbiAgdGhpcy5zcWxTdGF0ZU1hcmtlciA9IG9wdGlvbnMuc3FsU3RhdGVNYXJrZXI7XG4gIHRoaXMuc3FsU3RhdGUgICAgICAgPSBvcHRpb25zLnNxbFN0YXRlO1xuICB0aGlzLm1lc3NhZ2UgICAgICAgID0gb3B0aW9ucy5tZXNzYWdlO1xufVxuXG5FcnJvclBhY2tldC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihwYXJzZXIpIHtcbiAgdGhpcy5maWVsZENvdW50ID0gcGFyc2VyLnBhcnNlVW5zaWduZWROdW1iZXIoMSk7XG4gIHRoaXMuZXJybm8gICAgICA9IHBhcnNlci5wYXJzZVVuc2lnbmVkTnVtYmVyKDIpO1xuXG4gIC8vIHNxbFN0YXRlTWFya2VyICgnIycgPSAweDIzKSBpbmRpY2F0ZXMgZXJyb3IgcGFja2V0IGZvcm1hdFxuICBpZiAocGFyc2VyLnBlYWsoKSA9PT0gMHgyMykge1xuICAgIHRoaXMuc3FsU3RhdGVNYXJrZXIgPSBwYXJzZXIucGFyc2VTdHJpbmcoMSk7XG4gICAgdGhpcy5zcWxTdGF0ZSAgICAgICA9IHBhcnNlci5wYXJzZVN0cmluZyg1KTtcbiAgfVxuXG4gIHRoaXMubWVzc2FnZSA9IHBhcnNlci5wYXJzZVBhY2tldFRlcm1pbmF0ZWRTdHJpbmcoKTtcbn07XG5cbkVycm9yUGFja2V0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHdyaXRlcikge1xuICB3cml0ZXIud3JpdGVVbnNpZ25lZE51bWJlcigxLCAweGZmKTtcbiAgd3JpdGVyLndyaXRlVW5zaWduZWROdW1iZXIoMiwgdGhpcy5lcnJubyk7XG5cbiAgaWYgKHRoaXMuc3FsU3RhdGVNYXJrZXIpIHtcbiAgICB3cml0ZXIud3JpdGVTdHJpbmcodGhpcy5zcWxTdGF0ZU1hcmtlcik7XG4gICAgd3JpdGVyLndyaXRlU3RyaW5nKHRoaXMuc3FsU3RhdGUpO1xuICB9XG5cbiAgd3JpdGVyLndyaXRlU3RyaW5nKHRoaXMubWVzc2FnZSk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbXlzcWwvbGliL3Byb3RvY29sL3BhY2tldHMvRXJyb3JQYWNrZXQuanNcbiAqKiBtb2R1bGUgaWQgPSA0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIFR5cGVzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL3R5cGVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmllbGQ7XG5mdW5jdGlvbiBGaWVsZChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMucGFyc2VyID0gb3B0aW9ucy5wYXJzZXI7XG4gIHRoaXMucGFja2V0ID0gb3B0aW9ucy5wYWNrZXQ7XG4gIHRoaXMuZGIgICAgID0gb3B0aW9ucy5wYWNrZXQuZGI7XG4gIHRoaXMudGFibGUgID0gb3B0aW9ucy5wYWNrZXQudGFibGU7XG4gIHRoaXMubmFtZSAgID0gb3B0aW9ucy5wYWNrZXQubmFtZTtcbiAgdGhpcy50eXBlICAgPSB0eXBlVG9TdHJpbmcob3B0aW9ucy5wYWNrZXQudHlwZSk7XG4gIHRoaXMubGVuZ3RoID0gb3B0aW9ucy5wYWNrZXQubGVuZ3RoO1xufVxuXG5GaWVsZC5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wYXJzZXIucGFyc2VMZW5ndGhDb2RlZFN0cmluZygpO1xufTtcblxuRmllbGQucHJvdG90eXBlLmJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGFyc2VyLnBhcnNlTGVuZ3RoQ29kZWRCdWZmZXIoKTtcbn07XG5cbkZpZWxkLnByb3RvdHlwZS5nZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGFyc2VyLnBhcnNlR2VvbWV0cnlWYWx1ZSgpO1xufTtcblxuZnVuY3Rpb24gdHlwZVRvU3RyaW5nKHQpIHtcbiAgZm9yICh2YXIgayBpbiBUeXBlcykge1xuICAgIGlmIChUeXBlc1trXSA9PSB0KSByZXR1cm4gaztcbiAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbXlzcWwvbGliL3Byb3RvY29sL3BhY2tldHMvRmllbGQuanNcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gTWFudWFsbHkgZXh0cmFjdGVkIGZyb20gbXlzcWwtNS41LjIzL2luY2x1ZGUvbXlzcWxfY29tLmhcbi8vIHNvbWUgbW9yZSBpbmZvIGhlcmU6IGh0dHA6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vNS41L2VuL2MtYXBpLXByZXBhcmVkLXN0YXRlbWVudC10eXBlLWNvZGVzLmh0bWxcbmV4cG9ydHMuREVDSU1BTCAgICAgPSAweDAwOyAvLyBha2EgREVDSU1BTCAoaHR0cDovL2Rldi5teXNxbC5jb20vZG9jL3JlZm1hbi81LjAvZW4vcHJlY2lzaW9uLW1hdGgtZGVjaW1hbC1jaGFuZ2VzLmh0bWwpXG5leHBvcnRzLlRJTlkgICAgICAgID0gMHgwMTsgLy8gYWthIFRJTllJTlQsIDEgYnl0ZVxuZXhwb3J0cy5TSE9SVCAgICAgICA9IDB4MDI7IC8vIGFrYSBTTUFMTElOVCwgMiBieXRlc1xuZXhwb3J0cy5MT05HICAgICAgICA9IDB4MDM7IC8vIGFrYSBJTlQsIDQgYnl0ZXNcbmV4cG9ydHMuRkxPQVQgICAgICAgPSAweDA0OyAvLyBha2EgRkxPQVQsIDQtOCBieXRlc1xuZXhwb3J0cy5ET1VCTEUgICAgICA9IDB4MDU7IC8vIGFrYSBET1VCTEUsIDggYnl0ZXNcbmV4cG9ydHMuTlVMTCAgICAgICAgPSAweDA2OyAvLyBOVUxMICh1c2VkIGZvciBwcmVwYXJlZCBzdGF0ZW1lbnRzLCBJIHRoaW5rKVxuZXhwb3J0cy5USU1FU1RBTVAgICA9IDB4MDc7IC8vIGFrYSBUSU1FU1RBTVBcbmV4cG9ydHMuTE9OR0xPTkcgICAgPSAweDA4OyAvLyBha2EgQklHSU5ULCA4IGJ5dGVzXG5leHBvcnRzLklOVDI0ICAgICAgID0gMHgwOTsgLy8gYWthIE1FRElVTUlOVCwgMyBieXRlc1xuZXhwb3J0cy5EQVRFICAgICAgICA9IDB4MGE7IC8vIGFrYSBEQVRFXG5leHBvcnRzLlRJTUUgICAgICAgID0gMHgwYjsgLy8gYWthIFRJTUVcbmV4cG9ydHMuREFURVRJTUUgICAgPSAweDBjOyAvLyBha2EgREFURVRJTUVcbmV4cG9ydHMuWUVBUiAgICAgICAgPSAweDBkOyAvLyBha2EgWUVBUiwgMSBieXRlIChkb24ndCBhc2spXG5leHBvcnRzLk5FV0RBVEUgICAgID0gMHgwZTsgLy8gYWthID9cbmV4cG9ydHMuVkFSQ0hBUiAgICAgPSAweDBmOyAvLyBha2EgVkFSQ0hBUiAoPylcbmV4cG9ydHMuQklUICAgICAgICAgPSAweDEwOyAvLyBha2EgQklULCAxLTggYnl0ZVxuZXhwb3J0cy5ORVdERUNJTUFMICA9IDB4ZjY7IC8vIGFrYSBERUNJTUFMXG5leHBvcnRzLkVOVU0gICAgICAgID0gMHhmNzsgLy8gYWthIEVOVU1cbmV4cG9ydHMuU0VUICAgICAgICAgPSAweGY4OyAvLyBha2EgU0VUXG5leHBvcnRzLlRJTllfQkxPQiAgID0gMHhmOTsgLy8gYWthIFRJTllCTE9CLCBUSU5ZVEVYVFxuZXhwb3J0cy5NRURJVU1fQkxPQiA9IDB4ZmE7IC8vIGFrYSBNRURJVU1CTE9CLCBNRURJVU1URVhUXG5leHBvcnRzLkxPTkdfQkxPQiAgID0gMHhmYjsgLy8gYWthIExPTkdCTE9HLCBMT05HVEVYVFxuZXhwb3J0cy5CTE9CICAgICAgICA9IDB4ZmM7IC8vIGFrYSBCTE9CLCBURVhUXG5leHBvcnRzLlZBUl9TVFJJTkcgID0gMHhmZDsgLy8gYWthIFZBUkNIQVIsIFZBUkJJTkFSWVxuZXhwb3J0cy5TVFJJTkcgICAgICA9IDB4ZmU7IC8vIGFrYSBDSEFSLCBCSU5BUllcbmV4cG9ydHMuR0VPTUVUUlkgICAgPSAweGZmOyAvLyBha2EgR0VPTUVUUllcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL2xpYi9wcm90b2NvbC9jb25zdGFudHMvdHlwZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBGaWVsZFBhY2tldDtcbmZ1bmN0aW9uIEZpZWxkUGFja2V0KG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5jYXRhbG9nICAgID0gb3B0aW9ucy5jYXRhbG9nO1xuICB0aGlzLmRiICAgICAgICAgPSBvcHRpb25zLmRiO1xuICB0aGlzLnRhYmxlICAgICAgPSBvcHRpb25zLnRhYmxlO1xuICB0aGlzLm9yZ1RhYmxlICAgPSBvcHRpb25zLm9yZ1RhYmxlO1xuICB0aGlzLm5hbWUgICAgICAgPSBvcHRpb25zLm5hbWU7XG4gIHRoaXMub3JnTmFtZSAgICA9IG9wdGlvbnMub3JnTmFtZTtcbiAgdGhpcy5jaGFyc2V0TnIgID0gb3B0aW9ucy5jaGFyc2V0TnI7XG4gIHRoaXMubGVuZ3RoICAgICA9IG9wdGlvbnMubGVuZ3RoO1xuICB0aGlzLnR5cGUgICAgICAgPSBvcHRpb25zLnR5cGU7XG4gIHRoaXMuZmxhZ3MgICAgICA9IG9wdGlvbnMuZmxhZ3M7XG4gIHRoaXMuZGVjaW1hbHMgICA9IG9wdGlvbnMuZGVjaW1hbHM7XG4gIHRoaXMuZGVmYXVsdCAgICA9IG9wdGlvbnMuZGVmYXVsdDtcbiAgdGhpcy56ZXJvRmlsbCAgID0gb3B0aW9ucy56ZXJvRmlsbDtcbiAgdGhpcy5wcm90b2NvbDQxID0gb3B0aW9ucy5wcm90b2NvbDQxXG59XG5cbkZpZWxkUGFja2V0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHBhcnNlcikge1xuICBpZiAodGhpcy5wcm90b2NvbDQxKSB7XG4gICAgdGhpcy5jYXRhbG9nICAgICA9IHBhcnNlci5wYXJzZUxlbmd0aENvZGVkU3RyaW5nKCk7XG4gICAgdGhpcy5kYiAgICAgICAgICA9IHBhcnNlci5wYXJzZUxlbmd0aENvZGVkU3RyaW5nKCk7XG4gICAgdGhpcy50YWJsZSAgICAgICA9IHBhcnNlci5wYXJzZUxlbmd0aENvZGVkU3RyaW5nKCk7XG4gICAgdGhpcy5vcmdUYWJsZSAgICA9IHBhcnNlci5wYXJzZUxlbmd0aENvZGVkU3RyaW5nKCk7XG4gICAgdGhpcy5uYW1lICAgICAgICA9IHBhcnNlci5wYXJzZUxlbmd0aENvZGVkU3RyaW5nKCk7XG4gICAgdGhpcy5vcmdOYW1lICAgICA9IHBhcnNlci5wYXJzZUxlbmd0aENvZGVkU3RyaW5nKCk7XG5cbiAgICBpZiAocGFyc2VyLnBhcnNlTGVuZ3RoQ29kZWROdW1iZXIoKSAhPT0gMHgwYykge1xuICAgICAgdmFyIGVyciAgPSBuZXcgVHlwZUVycm9yKCdSZWNlaXZlZCBpbnZhbGlkIGZpZWxkIGxlbmd0aCcpO1xuICAgICAgZXJyLmNvZGUgPSAnUEFSU0VSX0lOVkFMSURfRklFTERfTEVOR1RIJztcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICB0aGlzLmNoYXJzZXROciAgID0gcGFyc2VyLnBhcnNlVW5zaWduZWROdW1iZXIoMik7XG4gICAgdGhpcy5sZW5ndGggICAgICA9IHBhcnNlci5wYXJzZVVuc2lnbmVkTnVtYmVyKDQpO1xuICAgIHRoaXMudHlwZSAgICAgICAgPSBwYXJzZXIucGFyc2VVbnNpZ25lZE51bWJlcigxKTtcbiAgICB0aGlzLmZsYWdzICAgICAgID0gcGFyc2VyLnBhcnNlVW5zaWduZWROdW1iZXIoMik7XG4gICAgdGhpcy5kZWNpbWFscyAgICA9IHBhcnNlci5wYXJzZVVuc2lnbmVkTnVtYmVyKDEpO1xuXG4gICAgdmFyIGZpbGxlciAgICAgICA9IHBhcnNlci5wYXJzZUJ1ZmZlcigyKTtcbiAgICBpZiAoZmlsbGVyWzBdICE9PSAweDAgfHwgZmlsbGVyWzFdICE9PSAweDApIHtcbiAgICAgIHZhciBlcnIgID0gbmV3IFR5cGVFcnJvcignUmVjZWl2ZWQgaW52YWxpZCBmaWxsZXInKTtcbiAgICAgIGVyci5jb2RlID0gJ1BBUlNFUl9JTlZBTElEX0ZJTExFUic7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgLy8gcGFyc2VkIGZsYWdzXG4gICAgdGhpcy56ZXJvRmlsbCAgICA9ICh0aGlzLmZsYWdzICYgMHgwMDQwID8gdHJ1ZSA6IGZhbHNlKTtcblxuICAgIGlmIChwYXJzZXIucmVhY2hlZFBhY2tldEVuZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kZWZhdWx0ICAgICA9IHBhcnNlci5wYXJzZUxlbmd0aENvZGVkU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWJsZSAgICAgICA9IHBhcnNlci5wYXJzZUxlbmd0aENvZGVkU3RyaW5nKCk7XG4gICAgdGhpcy5uYW1lICAgICAgICA9IHBhcnNlci5wYXJzZUxlbmd0aENvZGVkU3RyaW5nKCk7XG4gICAgdGhpcy5sZW5ndGggICAgICA9IHBhcnNlci5wYXJzZVVuc2lnbmVkTnVtYmVyKHBhcnNlci5wYXJzZVVuc2lnbmVkTnVtYmVyKDEpKTtcbiAgICB0aGlzLnR5cGUgICAgICAgID0gcGFyc2VyLnBhcnNlVW5zaWduZWROdW1iZXIocGFyc2VyLnBhcnNlVW5zaWduZWROdW1iZXIoMSkpO1xuICB9XG59O1xuXG5GaWVsZFBhY2tldC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih3cml0ZXIpIHtcbiAgaWYgKHRoaXMucHJvdG9jb2w0MSkge1xuICAgIHdyaXRlci53cml0ZUxlbmd0aENvZGVkU3RyaW5nKHRoaXMuY2F0YWxvZyk7XG4gICAgd3JpdGVyLndyaXRlTGVuZ3RoQ29kZWRTdHJpbmcodGhpcy5kYik7XG4gICAgd3JpdGVyLndyaXRlTGVuZ3RoQ29kZWRTdHJpbmcodGhpcy50YWJsZSk7XG4gICAgd3JpdGVyLndyaXRlTGVuZ3RoQ29kZWRTdHJpbmcodGhpcy5vcmdUYWJsZSk7XG4gICAgd3JpdGVyLndyaXRlTGVuZ3RoQ29kZWRTdHJpbmcodGhpcy5uYW1lKTtcbiAgICB3cml0ZXIud3JpdGVMZW5ndGhDb2RlZFN0cmluZyh0aGlzLm9yZ05hbWUpO1xuXG4gICAgd3JpdGVyLndyaXRlTGVuZ3RoQ29kZWROdW1iZXIoMHgwYyk7XG4gICAgd3JpdGVyLndyaXRlVW5zaWduZWROdW1iZXIoMiwgdGhpcy5jaGFyc2V0TnIgfHwgMCk7XG4gICAgd3JpdGVyLndyaXRlVW5zaWduZWROdW1iZXIoNCwgdGhpcy5sZW5ndGggfHwgMCk7XG4gICAgd3JpdGVyLndyaXRlVW5zaWduZWROdW1iZXIoMSwgdGhpcy50eXBlIHx8IDApO1xuICAgIHdyaXRlci53cml0ZVVuc2lnbmVkTnVtYmVyKDIsIHRoaXMuZmxhZ3MgfHwgMCk7XG4gICAgd3JpdGVyLndyaXRlVW5zaWduZWROdW1iZXIoMSwgdGhpcy5kZWNpbWFscyB8fCAwKTtcbiAgICB3cml0ZXIud3JpdGVGaWxsZXIoMik7XG5cbiAgICBpZiAodGhpcy5kZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdyaXRlci53cml0ZUxlbmd0aENvZGVkU3RyaW5nKHRoaXMuZGVmYXVsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdyaXRlci53cml0ZUxlbmd0aENvZGVkU3RyaW5nKHRoaXMudGFibGUpO1xuICAgIHdyaXRlci53cml0ZUxlbmd0aENvZGVkU3RyaW5nKHRoaXMubmFtZSk7XG4gICAgd3JpdGVyLndyaXRlVW5zaWduZWROdW1iZXIoMSwgMHgwMSk7XG4gICAgd3JpdGVyLndyaXRlVW5zaWduZWROdW1iZXIoMSwgdGhpcy5sZW5ndGgpO1xuICAgIHdyaXRlci53cml0ZVVuc2lnbmVkTnVtYmVyKDEsIDB4MDEpO1xuICAgIHdyaXRlci53cml0ZVVuc2lnbmVkTnVtYmVyKDEsIHRoaXMudHlwZSk7XG4gIH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9saWIvcHJvdG9jb2wvcGFja2V0cy9GaWVsZFBhY2tldC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgQ2xpZW50ID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL2NsaWVudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRzaGFrZUluaXRpYWxpemF0aW9uUGFja2V0O1xuZnVuY3Rpb24gSGFuZHNoYWtlSW5pdGlhbGl6YXRpb25QYWNrZXQob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLnByb3RvY29sVmVyc2lvbiAgICAgPSBvcHRpb25zLnByb3RvY29sVmVyc2lvbjtcbiAgdGhpcy5zZXJ2ZXJWZXJzaW9uICAgICAgID0gb3B0aW9ucy5zZXJ2ZXJWZXJzaW9uO1xuICB0aGlzLnRocmVhZElkICAgICAgICAgICAgPSBvcHRpb25zLnRocmVhZElkO1xuICB0aGlzLnNjcmFtYmxlQnVmZjEgICAgICAgPSBvcHRpb25zLnNjcmFtYmxlQnVmZjE7XG4gIHRoaXMuZmlsbGVyMSAgICAgICAgICAgICA9IG9wdGlvbnMuZmlsbGVyMTtcbiAgdGhpcy5zZXJ2ZXJDYXBhYmlsaXRpZXMxID0gb3B0aW9ucy5zZXJ2ZXJDYXBhYmlsaXRpZXMxO1xuICB0aGlzLnNlcnZlckxhbmd1YWdlICAgICAgPSBvcHRpb25zLnNlcnZlckxhbmd1YWdlO1xuICB0aGlzLnNlcnZlclN0YXR1cyAgICAgICAgPSBvcHRpb25zLnNlcnZlclN0YXR1cztcbiAgdGhpcy5zZXJ2ZXJDYXBhYmlsaXRpZXMyID0gb3B0aW9ucy5zZXJ2ZXJDYXBhYmlsaXRpZXMyO1xuICB0aGlzLnNjcmFtYmxlTGVuZ3RoICAgICAgPSBvcHRpb25zLnNjcmFtYmxlTGVuZ3RoO1xuICB0aGlzLmZpbGxlcjIgICAgICAgICAgICAgPSBvcHRpb25zLmZpbGxlcjI7XG4gIHRoaXMuc2NyYW1ibGVCdWZmMiAgICAgICA9IG9wdGlvbnMuc2NyYW1ibGVCdWZmMjtcbiAgdGhpcy5maWxsZXIzICAgICAgICAgICAgID0gb3B0aW9ucy5maWxsZXIzO1xuICB0aGlzLnBsdWdpbkRhdGEgICAgICAgICAgPSBvcHRpb25zLnBsdWdpbkRhdGE7XG4gIHRoaXMucHJvdG9jb2w0MSAgICAgICAgICA9IG9wdGlvbnMucHJvdG9jb2w0MTtcblxuICBpZiAodGhpcy5wcm90b2NvbDQxKSB7XG4gICAgLy8gZm9yY2Ugc2V0IHRoZSBiaXQgaW4gc2VydmVyQ2FwYWJpbGl0aWVzMVxuICAgIHRoaXMuc2VydmVyQ2FwYWJpbGl0aWVzMSB8PSBDbGllbnQuQ0xJRU5UX1BST1RPQ09MXzQxO1xuICB9XG59XG5cbkhhbmRzaGFrZUluaXRpYWxpemF0aW9uUGFja2V0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHBhcnNlcikge1xuICB0aGlzLnByb3RvY29sVmVyc2lvbiAgICAgPSBwYXJzZXIucGFyc2VVbnNpZ25lZE51bWJlcigxKTtcbiAgdGhpcy5zZXJ2ZXJWZXJzaW9uICAgICAgID0gcGFyc2VyLnBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmcoKTtcbiAgdGhpcy50aHJlYWRJZCAgICAgICAgICAgID0gcGFyc2VyLnBhcnNlVW5zaWduZWROdW1iZXIoNCk7XG4gIHRoaXMuc2NyYW1ibGVCdWZmMSAgICAgICA9IHBhcnNlci5wYXJzZUJ1ZmZlcig4KTtcbiAgdGhpcy5maWxsZXIxICAgICAgICAgICAgID0gcGFyc2VyLnBhcnNlRmlsbGVyKDEpO1xuICB0aGlzLnNlcnZlckNhcGFiaWxpdGllczEgPSBwYXJzZXIucGFyc2VVbnNpZ25lZE51bWJlcigyKTtcbiAgdGhpcy5zZXJ2ZXJMYW5ndWFnZSAgICAgID0gcGFyc2VyLnBhcnNlVW5zaWduZWROdW1iZXIoMSk7XG4gIHRoaXMuc2VydmVyU3RhdHVzICAgICAgICA9IHBhcnNlci5wYXJzZVVuc2lnbmVkTnVtYmVyKDIpO1xuXG4gIHRoaXMucHJvdG9jb2w0MSAgICAgICAgICA9ICh0aGlzLnNlcnZlckNhcGFiaWxpdGllczEgJiAoMSA8PCA5KSkgPiAwO1xuXG4gIGlmICh0aGlzLnByb3RvY29sNDEpIHtcbiAgICB0aGlzLnNlcnZlckNhcGFiaWxpdGllczIgPSBwYXJzZXIucGFyc2VVbnNpZ25lZE51bWJlcigyKTtcbiAgICB0aGlzLnNjcmFtYmxlTGVuZ3RoICAgICAgPSBwYXJzZXIucGFyc2VVbnNpZ25lZE51bWJlcigxKTtcbiAgICB0aGlzLmZpbGxlcjIgICAgICAgICAgICAgPSBwYXJzZXIucGFyc2VGaWxsZXIoMTApO1xuICAgIC8vIHNjcmFtYmxlQnVmZjIgc2hvdWxkIGJlIDB4MDAgdGVybWluYXRlZCwgYnV0IHNwaGlueCBkb2VzIG5vdCBkbyB0aGlzXG4gICAgLy8gc28gd2UgYXNzdW1lIHNjcmFtYmxlQnVmZjIgdG8gYmUgMTIgYnl0ZSBhbmQgdHJlYXQgdGhlIG5leHQgYnl0ZSBhcyBhXG4gICAgLy8gZmlsbGVyIGJ5dGUuXG4gICAgdGhpcy5zY3JhbWJsZUJ1ZmYyICAgICAgID0gcGFyc2VyLnBhcnNlQnVmZmVyKDEyKTtcbiAgICB0aGlzLmZpbGxlcjMgICAgICAgICAgICAgPSBwYXJzZXIucGFyc2VGaWxsZXIoMSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5maWxsZXIyICAgICAgICAgICAgID0gcGFyc2VyLnBhcnNlRmlsbGVyKDEzKTtcbiAgfVxuXG4gIGlmIChwYXJzZXIucmVhY2hlZFBhY2tldEVuZCgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQWNjb3JkaW5nIHRvIHRoZSBkb2NzIHRoaXMgc2hvdWxkIGJlIDB4MDAgdGVybWluYXRlZCwgYnV0IE1hcmlhREIgZG9lc1xuICAvLyBub3QgZG8gdGhpcywgc28gd2UgYXNzdW1lIHRoaXMgc3RyaW5nIHRvIGJlIHBhY2tldCB0ZXJtaW5hdGVkLlxuICB0aGlzLnBsdWdpbkRhdGEgPSBwYXJzZXIucGFyc2VQYWNrZXRUZXJtaW5hdGVkU3RyaW5nKCk7XG5cbiAgLy8gSG93ZXZlciwgaWYgdGhlcmUgaXMgYSB0cmFpbGluZyAnXFwwJywgc3RyaXAgaXRcbiAgdmFyIGxhc3RDaGFyID0gdGhpcy5wbHVnaW5EYXRhLmxlbmd0aCAtIDE7XG4gIGlmICh0aGlzLnBsdWdpbkRhdGFbbGFzdENoYXJdID09PSAnXFwwJykge1xuICAgIHRoaXMucGx1Z2luRGF0YSA9IHRoaXMucGx1Z2luRGF0YS5zdWJzdHIoMCwgbGFzdENoYXIpO1xuICB9XG59O1xuXG5IYW5kc2hha2VJbml0aWFsaXphdGlvblBhY2tldC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih3cml0ZXIpIHtcbiAgd3JpdGVyLndyaXRlVW5zaWduZWROdW1iZXIoMSwgdGhpcy5wcm90b2NvbFZlcnNpb24pO1xuICB3cml0ZXIud3JpdGVOdWxsVGVybWluYXRlZFN0cmluZyh0aGlzLnNlcnZlclZlcnNpb24pO1xuICB3cml0ZXIud3JpdGVVbnNpZ25lZE51bWJlcig0LCB0aGlzLnRocmVhZElkKTtcbiAgd3JpdGVyLndyaXRlQnVmZmVyKHRoaXMuc2NyYW1ibGVCdWZmMSk7XG4gIHdyaXRlci53cml0ZUZpbGxlcigxKTtcbiAgd3JpdGVyLndyaXRlVW5zaWduZWROdW1iZXIoMiwgdGhpcy5zZXJ2ZXJDYXBhYmlsaXRpZXMxKTtcbiAgd3JpdGVyLndyaXRlVW5zaWduZWROdW1iZXIoMSwgdGhpcy5zZXJ2ZXJMYW5ndWFnZSk7XG4gIHdyaXRlci53cml0ZVVuc2lnbmVkTnVtYmVyKDIsIHRoaXMuc2VydmVyU3RhdHVzKTtcbiAgaWYgKHRoaXMucHJvdG9jb2w0MSkge1xuICAgIHdyaXRlci53cml0ZVVuc2lnbmVkTnVtYmVyKDIsIHRoaXMuc2VydmVyQ2FwYWJpbGl0aWVzMik7XG4gICAgd3JpdGVyLndyaXRlVW5zaWduZWROdW1iZXIoMSwgdGhpcy5zY3JhbWJsZUxlbmd0aCk7XG4gICAgd3JpdGVyLndyaXRlRmlsbGVyKDEwKTtcbiAgfVxuICB3cml0ZXIud3JpdGVOdWxsVGVybWluYXRlZEJ1ZmZlcih0aGlzLnNjcmFtYmxlQnVmZjIpO1xuXG4gIGlmICh0aGlzLnBsdWdpbkRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgIHdyaXRlci53cml0ZU51bGxUZXJtaW5hdGVkU3RyaW5nKHRoaXMucGx1Z2luRGF0YSk7XG4gIH1cbn07XG5cbkhhbmRzaGFrZUluaXRpYWxpemF0aW9uUGFja2V0LnByb3RvdHlwZS5zY3JhbWJsZUJ1ZmYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIodGhpcy5zY3JhbWJsZUJ1ZmYxLmxlbmd0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgdGhpcy5zY3JhbWJsZUJ1ZmYyICE9IFwidW5kZWZpbmVkXCIgPyB0aGlzLnNjcmFtYmxlQnVmZjIubGVuZ3RoIDogMCkpO1xuXG4gIHRoaXMuc2NyYW1ibGVCdWZmMS5jb3B5KGJ1ZmZlcik7XG4gIGlmICh0eXBlb2YgdGhpcy5zY3JhbWJsZUJ1ZmYyICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aGlzLnNjcmFtYmxlQnVmZjIuY29weShidWZmZXIsIHRoaXMuc2NyYW1ibGVCdWZmMS5sZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9saWIvcHJvdG9jb2wvcGFja2V0cy9IYW5kc2hha2VJbml0aWFsaXphdGlvblBhY2tldC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IExvY2FsRGF0YUZpbGVQYWNrZXQ7XG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhXG4gKi9cbmZ1bmN0aW9uIExvY2FsRGF0YUZpbGVQYWNrZXQoZGF0YSkge1xuICB0aGlzLmRhdGEgPSBkYXRhO1xufVxuXG5Mb2NhbERhdGFGaWxlUGFja2V0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHdyaXRlcikge1xuICB3cml0ZXIud3JpdGVCdWZmZXIodGhpcy5kYXRhKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9saWIvcHJvdG9jb2wvcGFja2V0cy9Mb2NhbERhdGFGaWxlUGFja2V0LmpzXG4gKiogbW9kdWxlIGlkID0gNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gT2tQYWNrZXQ7XG5mdW5jdGlvbiBPa1BhY2tldChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMuZmllbGRDb3VudCAgID0gdW5kZWZpbmVkO1xuICB0aGlzLmFmZmVjdGVkUm93cyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pbnNlcnRJZCAgICAgPSB1bmRlZmluZWQ7XG4gIHRoaXMuc2VydmVyU3RhdHVzID0gdW5kZWZpbmVkO1xuICB0aGlzLndhcm5pbmdDb3VudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5tZXNzYWdlICAgICAgPSB1bmRlZmluZWQ7XG4gIHRoaXMucHJvdG9jb2w0MSAgID0gb3B0aW9ucy5wcm90b2NvbDQxO1xufVxuXG5Pa1BhY2tldC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihwYXJzZXIpIHtcbiAgdGhpcy5maWVsZENvdW50ICAgPSBwYXJzZXIucGFyc2VVbnNpZ25lZE51bWJlcigxKTtcbiAgdGhpcy5hZmZlY3RlZFJvd3MgPSBwYXJzZXIucGFyc2VMZW5ndGhDb2RlZE51bWJlcigpO1xuICB0aGlzLmluc2VydElkICAgICA9IHBhcnNlci5wYXJzZUxlbmd0aENvZGVkTnVtYmVyKCk7XG4gIGlmICh0aGlzLnByb3RvY29sNDEpIHtcbiAgICB0aGlzLnNlcnZlclN0YXR1cyA9IHBhcnNlci5wYXJzZVVuc2lnbmVkTnVtYmVyKDIpO1xuICAgIHRoaXMud2FybmluZ0NvdW50ID0gcGFyc2VyLnBhcnNlVW5zaWduZWROdW1iZXIoMik7XG4gIH1cbiAgdGhpcy5tZXNzYWdlICAgICAgPSBwYXJzZXIucGFyc2VQYWNrZXRUZXJtaW5hdGVkU3RyaW5nKCk7XG4gIHRoaXMuY2hhbmdlZFJvd3MgID0gMDtcblxuICB2YXIgbSA9IHRoaXMubWVzc2FnZS5tYXRjaCgvXFxzY2hhbmdlZDpcXHMqKFxcZCspL2kpO1xuXG4gIGlmIChtICE9PSBudWxsKSB7XG4gICAgdGhpcy5jaGFuZ2VkUm93cyA9IHBhcnNlSW50KG1bMV0sIDEwKTtcbiAgfVxufTtcblxuT2tQYWNrZXQucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24od3JpdGVyKSB7XG4gIHdyaXRlci53cml0ZVVuc2lnbmVkTnVtYmVyKDEsIDB4MDApO1xuICB3cml0ZXIud3JpdGVMZW5ndGhDb2RlZE51bWJlcih0aGlzLmFmZmVjdGVkUm93cyB8fCAwKTtcbiAgd3JpdGVyLndyaXRlTGVuZ3RoQ29kZWROdW1iZXIodGhpcy5pbnNlcnRJZCB8fCAwKTtcbiAgaWYgKHRoaXMucHJvdG9jb2w0MSkge1xuICAgIHdyaXRlci53cml0ZVVuc2lnbmVkTnVtYmVyKDIsIHRoaXMuc2VydmVyU3RhdHVzIHx8IDApO1xuICAgIHdyaXRlci53cml0ZVVuc2lnbmVkTnVtYmVyKDIsIHRoaXMud2FybmluZ0NvdW50IHx8IDApO1xuICB9XG4gIHdyaXRlci53cml0ZVN0cmluZyh0aGlzLm1lc3NhZ2UpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL2xpYi9wcm90b2NvbC9wYWNrZXRzL09rUGFja2V0LmpzXG4gKiogbW9kdWxlIGlkID0gNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gT2xkUGFzc3dvcmRQYWNrZXQ7XG5mdW5jdGlvbiBPbGRQYXNzd29yZFBhY2tldChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMuc2NyYW1ibGVCdWZmID0gb3B0aW9ucy5zY3JhbWJsZUJ1ZmY7XG59XG5cbk9sZFBhc3N3b3JkUGFja2V0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHBhcnNlcikge1xuICB0aGlzLnNjcmFtYmxlQnVmZiA9IHBhcnNlci5wYXJzZU51bGxUZXJtaW5hdGVkQnVmZmVyKCk7XG59O1xuXG5PbGRQYXNzd29yZFBhY2tldC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih3cml0ZXIpIHtcbiAgd3JpdGVyLndyaXRlQnVmZmVyKHRoaXMuc2NyYW1ibGVCdWZmKTtcbiAgd3JpdGVyLndyaXRlRmlsbGVyKDEpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL2xpYi9wcm90b2NvbC9wYWNrZXRzL09sZFBhc3N3b3JkUGFja2V0LmpzXG4gKiogbW9kdWxlIGlkID0gNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gUmVzdWx0U2V0SGVhZGVyUGFja2V0O1xuZnVuY3Rpb24gUmVzdWx0U2V0SGVhZGVyUGFja2V0KG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5maWVsZENvdW50ID0gb3B0aW9ucy5maWVsZENvdW50O1xuICB0aGlzLmV4dHJhICAgICAgPSBvcHRpb25zLmV4dHJhO1xufVxuXG5SZXN1bHRTZXRIZWFkZXJQYWNrZXQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24ocGFyc2VyKSB7XG4gIHRoaXMuZmllbGRDb3VudCA9IHBhcnNlci5wYXJzZUxlbmd0aENvZGVkTnVtYmVyKCk7XG5cbiAgaWYgKHBhcnNlci5yZWFjaGVkUGFja2V0RW5kKCkpIHJldHVybjtcblxuICB0aGlzLmV4dHJhID0gKHRoaXMuZmllbGRDb3VudCA9PT0gbnVsbClcbiAgICA/IHBhcnNlci5wYXJzZVBhY2tldFRlcm1pbmF0ZWRTdHJpbmcoKVxuICAgIDogcGFyc2VyLnBhcnNlTGVuZ3RoQ29kZWROdW1iZXIoKTtcbn07XG5cblJlc3VsdFNldEhlYWRlclBhY2tldC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih3cml0ZXIpIHtcbiAgd3JpdGVyLndyaXRlTGVuZ3RoQ29kZWROdW1iZXIodGhpcy5maWVsZENvdW50KTtcblxuICBpZiAodGhpcy5leHRyYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd3JpdGVyLndyaXRlTGVuZ3RoQ29kZWROdW1iZXIodGhpcy5leHRyYSk7XG4gIH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9saWIvcHJvdG9jb2wvcGFja2V0cy9SZXN1bHRTZXRIZWFkZXJQYWNrZXQuanNcbiAqKiBtb2R1bGUgaWQgPSA1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIFR5cGVzICAgICAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvdHlwZXMnKTtcbnZhciBDaGFyc2V0cyAgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL2NoYXJzZXRzJyk7XG52YXIgRmllbGQgICAgICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vRmllbGQnKTtcbnZhciBJRUVFXzc1NF9CSU5BUllfNjRfUFJFQ0lTSU9OID0gTWF0aC5wb3coMiwgNTMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvd0RhdGFQYWNrZXQ7XG5mdW5jdGlvbiBSb3dEYXRhUGFja2V0KCkge1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUm93RGF0YVBhY2tldC5wcm90b3R5cGUsICdwYXJzZScsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgdmFsdWU6IHBhcnNlXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJvd0RhdGFQYWNrZXQucHJvdG90eXBlLCAnX3R5cGVDYXN0Jywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB2YWx1ZTogdHlwZUNhc3Rcbn0pO1xuXG5mdW5jdGlvbiBwYXJzZShwYXJzZXIsIGZpZWxkUGFja2V0cywgdHlwZUNhc3QsIG5lc3RUYWJsZXMsIGNvbm5lY3Rpb24pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2VsZi5fdHlwZUNhc3QoZmllbGRQYWNrZXQsIHBhcnNlciwgY29ubmVjdGlvbi5jb25maWcudGltZXpvbmUsIGNvbm5lY3Rpb24uY29uZmlnLnN1cHBvcnRCaWdOdW1iZXJzLCBjb25uZWN0aW9uLmNvbmZpZy5iaWdOdW1iZXJTdHJpbmdzLCBjb25uZWN0aW9uLmNvbmZpZy5kYXRlU3RyaW5ncyk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZmllbGRQYWNrZXQgPSBmaWVsZFBhY2tldHNbaV07XG4gICAgdmFyIHZhbHVlO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlQ2FzdCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHZhbHVlID0gdHlwZUNhc3QuYXBwbHkoY29ubmVjdGlvbiwgWyBuZXcgRmllbGQoeyBwYWNrZXQ6IGZpZWxkUGFja2V0LCBwYXJzZXI6IHBhcnNlciB9KSwgbmV4dCBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSAodHlwZUNhc3QpXG4gICAgICAgID8gdGhpcy5fdHlwZUNhc3QoZmllbGRQYWNrZXQsIHBhcnNlciwgY29ubmVjdGlvbi5jb25maWcudGltZXpvbmUsIGNvbm5lY3Rpb24uY29uZmlnLnN1cHBvcnRCaWdOdW1iZXJzLCBjb25uZWN0aW9uLmNvbmZpZy5iaWdOdW1iZXJTdHJpbmdzLCBjb25uZWN0aW9uLmNvbmZpZy5kYXRlU3RyaW5ncylcbiAgICAgICAgOiAoIChmaWVsZFBhY2tldC5jaGFyc2V0TnIgPT09IENoYXJzZXRzLkJJTkFSWSlcbiAgICAgICAgICA/IHBhcnNlci5wYXJzZUxlbmd0aENvZGVkQnVmZmVyKClcbiAgICAgICAgICA6IHBhcnNlci5wYXJzZUxlbmd0aENvZGVkU3RyaW5nKCkgKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5lc3RUYWJsZXMgPT0gXCJzdHJpbmdcIiAmJiBuZXN0VGFibGVzLmxlbmd0aCkge1xuICAgICAgdGhpc1tmaWVsZFBhY2tldC50YWJsZSArIG5lc3RUYWJsZXMgKyBmaWVsZFBhY2tldC5uYW1lXSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAobmVzdFRhYmxlcykge1xuICAgICAgdGhpc1tmaWVsZFBhY2tldC50YWJsZV0gPSB0aGlzW2ZpZWxkUGFja2V0LnRhYmxlXSB8fCB7fTtcbiAgICAgIHRoaXNbZmllbGRQYWNrZXQudGFibGVdW2ZpZWxkUGFja2V0Lm5hbWVdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbZmllbGRQYWNrZXQubmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdHlwZUNhc3QoZmllbGQsIHBhcnNlciwgdGltZVpvbmUsIHN1cHBvcnRCaWdOdW1iZXJzLCBiaWdOdW1iZXJTdHJpbmdzLCBkYXRlU3RyaW5ncykge1xuICB2YXIgbnVtYmVyU3RyaW5nO1xuXG4gIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgIGNhc2UgVHlwZXMuVElNRVNUQU1QOlxuICAgIGNhc2UgVHlwZXMuREFURTpcbiAgICBjYXNlIFR5cGVzLkRBVEVUSU1FOlxuICAgIGNhc2UgVHlwZXMuTkVXREFURTpcbiAgICAgIHZhciBkYXRlU3RyaW5nID0gcGFyc2VyLnBhcnNlTGVuZ3RoQ29kZWRTdHJpbmcoKTtcbiAgICAgIGlmIChkYXRlU3RyaW5ncykge1xuICAgICAgICAgIHJldHVybiBkYXRlU3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIGR0O1xuXG4gICAgICBpZiAoZGF0ZVN0cmluZyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIG9yaWdpbmFsU3RyaW5nID0gZGF0ZVN0cmluZztcbiAgICAgIGlmIChmaWVsZC50eXBlID09PSBUeXBlcy5EQVRFKSB7XG4gICAgICAgIGRhdGVTdHJpbmcgKz0gJyAwMDowMDowMCc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aW1lWm9uZSAhPT0gJ2xvY2FsJykge1xuICAgICAgICBkYXRlU3RyaW5nICs9ICcgJyArIHRpbWVab25lO1xuICAgICAgfVxuXG4gICAgICBkdCA9IG5ldyBEYXRlKGRhdGVTdHJpbmcpO1xuICAgICAgaWYgKGlzTmFOKGR0LmdldFRpbWUoKSkpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsU3RyaW5nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZHQ7XG4gICAgY2FzZSBUeXBlcy5USU5ZOlxuICAgIGNhc2UgVHlwZXMuU0hPUlQ6XG4gICAgY2FzZSBUeXBlcy5MT05HOlxuICAgIGNhc2UgVHlwZXMuSU5UMjQ6XG4gICAgY2FzZSBUeXBlcy5ZRUFSOlxuICAgIGNhc2UgVHlwZXMuRkxPQVQ6XG4gICAgY2FzZSBUeXBlcy5ET1VCTEU6XG4gICAgICBudW1iZXJTdHJpbmcgPSBwYXJzZXIucGFyc2VMZW5ndGhDb2RlZFN0cmluZygpO1xuICAgICAgcmV0dXJuIChudW1iZXJTdHJpbmcgPT09IG51bGwgfHwgKGZpZWxkLnplcm9GaWxsICYmIG51bWJlclN0cmluZ1swXSA9PSBcIjBcIikpXG4gICAgICAgID8gbnVtYmVyU3RyaW5nIDogTnVtYmVyKG51bWJlclN0cmluZyk7XG4gICAgY2FzZSBUeXBlcy5ORVdERUNJTUFMOlxuICAgIGNhc2UgVHlwZXMuTE9OR0xPTkc6XG4gICAgICBudW1iZXJTdHJpbmcgPSBwYXJzZXIucGFyc2VMZW5ndGhDb2RlZFN0cmluZygpO1xuICAgICAgcmV0dXJuIChudW1iZXJTdHJpbmcgPT09IG51bGwgfHwgKGZpZWxkLnplcm9GaWxsICYmIG51bWJlclN0cmluZ1swXSA9PSBcIjBcIikpXG4gICAgICAgID8gbnVtYmVyU3RyaW5nXG4gICAgICAgIDogKChzdXBwb3J0QmlnTnVtYmVycyAmJiAoYmlnTnVtYmVyU3RyaW5ncyB8fCAoTnVtYmVyKG51bWJlclN0cmluZykgPiBJRUVFXzc1NF9CSU5BUllfNjRfUFJFQ0lTSU9OKSkpXG4gICAgICAgICAgPyBudW1iZXJTdHJpbmdcbiAgICAgICAgICA6IE51bWJlcihudW1iZXJTdHJpbmcpKTtcbiAgICBjYXNlIFR5cGVzLkJJVDpcbiAgICAgIHJldHVybiBwYXJzZXIucGFyc2VMZW5ndGhDb2RlZEJ1ZmZlcigpO1xuICAgIGNhc2UgVHlwZXMuU1RSSU5HOlxuICAgIGNhc2UgVHlwZXMuVkFSX1NUUklORzpcbiAgICBjYXNlIFR5cGVzLlRJTllfQkxPQjpcbiAgICBjYXNlIFR5cGVzLk1FRElVTV9CTE9COlxuICAgIGNhc2UgVHlwZXMuTE9OR19CTE9COlxuICAgIGNhc2UgVHlwZXMuQkxPQjpcbiAgICAgIHJldHVybiAoZmllbGQuY2hhcnNldE5yID09PSBDaGFyc2V0cy5CSU5BUlkpXG4gICAgICAgID8gcGFyc2VyLnBhcnNlTGVuZ3RoQ29kZWRCdWZmZXIoKVxuICAgICAgICA6IHBhcnNlci5wYXJzZUxlbmd0aENvZGVkU3RyaW5nKCk7XG4gICAgY2FzZSBUeXBlcy5HRU9NRVRSWTpcbiAgICAgIHJldHVybiBwYXJzZXIucGFyc2VHZW9tZXRyeVZhbHVlKCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwYXJzZXIucGFyc2VMZW5ndGhDb2RlZFN0cmluZygpO1xuICB9XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9saWIvcHJvdG9jb2wvcGFja2V0cy9Sb3dEYXRhUGFja2V0LmpzXG4gKiogbW9kdWxlIGlkID0gNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHA6Ly9kZXYubXlzcWwuY29tL2RvYy9pbnRlcm5hbHMvZW4vc3NsLmh0bWxcbi8vIGh0dHA6Ly9kZXYubXlzcWwuY29tL2RvYy9pbnRlcm5hbHMvZW4vY29ubmVjdGlvbi1waGFzZS1wYWNrZXRzLmh0bWwjcGFja2V0LVByb3RvY29sOjpTU0xSZXF1ZXN0XG5cbnZhciBDbGllbnRDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvY2xpZW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU1NMUmVxdWVzdFBhY2tldDtcblxuZnVuY3Rpb24gU1NMUmVxdWVzdFBhY2tldChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLmNsaWVudEZsYWdzICAgPSBvcHRpb25zLmNsaWVudEZsYWdzIHwgQ2xpZW50Q29uc3RhbnRzLkNMSUVOVF9TU0w7XG4gIHRoaXMubWF4UGFja2V0U2l6ZSA9IG9wdGlvbnMubWF4UGFja2V0U2l6ZTtcbiAgdGhpcy5jaGFyc2V0TnVtYmVyID0gb3B0aW9ucy5jaGFyc2V0TnVtYmVyO1xufVxuXG5TU0xSZXF1ZXN0UGFja2V0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHBhcnNlcikge1xuICAvLyBUT0RPOiBjaGVjayBTU0xSZXF1ZXN0IHBhY2tldCB2NDEgdnMgcHJlIHY0MVxuICB0aGlzLmNsaWVudEZsYWdzICAgPSBwYXJzZXIucGFyc2VVbnNpZ25lZE51bWJlcig0KTtcbiAgdGhpcy5tYXhQYWNrZXRTaXplID0gcGFyc2VyLnBhcnNlVW5zaWduZWROdW1iZXIoNCk7XG4gIHRoaXMuY2hhcnNldE51bWJlciA9IHBhcnNlci5wYXJzZVVuc2lnbmVkTnVtYmVyKDEpO1xufTtcblxuU1NMUmVxdWVzdFBhY2tldC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih3cml0ZXIpIHtcbiAgd3JpdGVyLndyaXRlVW5zaWduZWROdW1iZXIoNCwgdGhpcy5jbGllbnRGbGFncyk7XG4gIHdyaXRlci53cml0ZVVuc2lnbmVkTnVtYmVyKDQsIHRoaXMubWF4UGFja2V0U2l6ZSk7XG4gIHdyaXRlci53cml0ZVVuc2lnbmVkTnVtYmVyKDEsIHRoaXMuY2hhcnNldE51bWJlcik7XG4gIHdyaXRlci53cml0ZUZpbGxlcigyMyk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbXlzcWwvbGliL3Byb3RvY29sL3BhY2tldHMvU1NMUmVxdWVzdFBhY2tldC5qc1xuICoqIG1vZHVsZSBpZCA9IDU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFN0YXRpc3RpY3NQYWNrZXQ7XG5mdW5jdGlvbiBTdGF0aXN0aWNzUGFja2V0KCkge1xuICB0aGlzLm1lc3NhZ2UgICAgICA9IHVuZGVmaW5lZDtcbn1cblxuU3RhdGlzdGljc1BhY2tldC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihwYXJzZXIpIHtcbiAgdGhpcy5tZXNzYWdlICAgICAgPSBwYXJzZXIucGFyc2VQYWNrZXRUZXJtaW5hdGVkU3RyaW5nKCk7XG5cbiAgdmFyIGl0ZW1zID0gdGhpcy5tZXNzYWdlLnNwbGl0KC9cXHNcXHMvKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtID0gaXRlbXNbaV0ubWF0Y2goL14oLispXFw6XFxzKyguKykkLyk7XG4gICAgaWYgKG0gIT09IG51bGwpIHtcbiAgICAgIHRoaXNbbVsxXS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccy9nLCAnXycpXSA9IE51bWJlcihtWzJdKTtcbiAgICB9XG4gIH1cbn07XG5cblN0YXRpc3RpY3NQYWNrZXQucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24od3JpdGVyKSB7XG4gIHdyaXRlci53cml0ZVN0cmluZyh0aGlzLm1lc3NhZ2UpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL2xpYi9wcm90b2NvbC9wYWNrZXRzL1N0YXRpc3RpY3NQYWNrZXQuanNcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBVc2VPbGRQYXNzd29yZFBhY2tldDtcbmZ1bmN0aW9uIFVzZU9sZFBhc3N3b3JkUGFja2V0KG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5maXJzdEJ5dGUgPSBvcHRpb25zLmZpcnN0Qnl0ZSB8fCAweGZlO1xufVxuXG5Vc2VPbGRQYXNzd29yZFBhY2tldC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihwYXJzZXIpIHtcbiAgdGhpcy5maXJzdEJ5dGUgPSBwYXJzZXIucGFyc2VVbnNpZ25lZE51bWJlcigxKTtcbn07XG5cblVzZU9sZFBhc3N3b3JkUGFja2V0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHdyaXRlcikge1xuICB3cml0ZXIud3JpdGVVbnNpZ25lZE51bWJlcigxLCB0aGlzLmZpcnN0Qnl0ZSk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbXlzcWwvbGliL3Byb3RvY29sL3BhY2tldHMvVXNlT2xkUGFzc3dvcmRQYWNrZXQuanNcbiAqKiBtb2R1bGUgaWQgPSA1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBNeVNRTCBlcnJvciBjb25zdGFudHNcbiAqXG4gKiAhISBHZW5lcmF0ZWQgYnkgZ2VuZXJhdGUtZXJyb3ItY29uc3RhbnRzLmpzLCBkbyBub3QgbW9kaWZ5IGJ5IGhhbmQgISFcbiAqL1xuXG5leHBvcnRzLkVFX0NBTlRDUkVBVEVGSUxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxO1xuZXhwb3J0cy5FRV9SRUFEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMjtcbmV4cG9ydHMuRUVfV1JJVEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDM7XG5leHBvcnRzLkVFX0JBRENMT1NFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSA0O1xuZXhwb3J0cy5FRV9PVVRPRk1FTU9SWSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gNTtcbmV4cG9ydHMuRUVfREVMRVRFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDY7XG5leHBvcnRzLkVFX0xJTksgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSA3O1xuZXhwb3J0cy5FRV9FT0ZFUlIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gOTtcbmV4cG9ydHMuRUVfQ0FOVExPQ0sgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwO1xuZXhwb3J0cy5FRV9DQU5UVU5MT0NLICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE7XG5leHBvcnRzLkVFX0RJUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjtcbmV4cG9ydHMuRUVfU1RBVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzO1xuZXhwb3J0cy5FRV9DQU5UX0NIU0laRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ7XG5leHBvcnRzLkVFX0NBTlRfT1BFTl9TVFJFQU0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTtcbmV4cG9ydHMuRUVfR0VUV0QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2O1xuZXhwb3J0cy5FRV9TRVRXRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTc7XG5leHBvcnRzLkVFX0xJTktfV0FSTklORyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODtcbmV4cG9ydHMuRUVfT1BFTl9XQVJOSU5HICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE5O1xuZXhwb3J0cy5FRV9ESVNLX0ZVTEwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMjA7XG5leHBvcnRzLkVFX0NBTlRfTUtESVIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAyMTtcbmV4cG9ydHMuRUVfVU5LTk9XTl9DSEFSU0VUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDIyO1xuZXhwb3J0cy5FRV9PVVRfT0ZfRklMRVJFU09VUkNFUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMjM7XG5leHBvcnRzLkVFX0NBTlRfUkVBRExJTksgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAyNDtcbmV4cG9ydHMuRUVfQ0FOVF9TWU1MSU5LICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDI1O1xuZXhwb3J0cy5FRV9SRUFMUEFUSCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMjY7XG5leHBvcnRzLkVFX1NZTkMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAyNztcbmV4cG9ydHMuRUVfVU5LTk9XTl9DT0xMQVRJT04gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDI4O1xuZXhwb3J0cy5FRV9GSUxFTk9URk9VTkQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMjk7XG5leHBvcnRzLkVFX0ZJTEVfTk9UX0NMT1NFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAzMDtcbmV4cG9ydHMuRUVfQ0hBTkdFX09XTkVSU0hJUCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDMxO1xuZXhwb3J0cy5FRV9DSEFOR0VfUEVSTUlTU0lPTlMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMzI7XG5leHBvcnRzLkVFX0NBTlRfU0VFSyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAzMztcbmV4cG9ydHMuSEFfRVJSX0tFWV9OT1RfRk9VTkQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyMDtcbmV4cG9ydHMuSEFfRVJSX0ZPVU5EX0RVUFBfS0VZICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyMTtcbmV4cG9ydHMuSEFfRVJSX0lOVEVSTkFMX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyMjtcbmV4cG9ydHMuSEFfRVJSX1JFQ09SRF9DSEFOR0VEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyMztcbmV4cG9ydHMuSEFfRVJSX1dST05HX0lOREVYICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyNDtcbmV4cG9ydHMuSEFfRVJSX0NSQVNIRUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyNjtcbmV4cG9ydHMuSEFfRVJSX1dST05HX0lOX1JFQ09SRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyNztcbmV4cG9ydHMuSEFfRVJSX09VVF9PRl9NRU0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyODtcbmV4cG9ydHMuSEFfRVJSX05PVF9BX1RBQkxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzMDtcbmV4cG9ydHMuSEFfRVJSX1dST05HX0NPTU1BTkQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzMTtcbmV4cG9ydHMuSEFfRVJSX09MRF9GSUxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzMjtcbmV4cG9ydHMuSEFfRVJSX05PX0FDVElWRV9SRUNPUkQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzMztcbmV4cG9ydHMuSEFfRVJSX1JFQ09SRF9ERUxFVEVEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzNDtcbmV4cG9ydHMuSEFfRVJSX1JFQ09SRF9GSUxFX0ZVTEwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzNTtcbmV4cG9ydHMuSEFfRVJSX0lOREVYX0ZJTEVfRlVMTCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzNjtcbmV4cG9ydHMuSEFfRVJSX0VORF9PRl9GSUxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzNztcbmV4cG9ydHMuSEFfRVJSX1VOU1VQUE9SVEVEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzODtcbmV4cG9ydHMuSEFfRVJSX1RPX0JJR19ST1cgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzOTtcbmV4cG9ydHMuSEFfV1JPTkdfQ1JFQVRFX09QVElPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0MDtcbmV4cG9ydHMuSEFfRVJSX0ZPVU5EX0RVUFBfVU5JUVVFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0MTtcbmV4cG9ydHMuSEFfRVJSX1VOS05PV05fQ0hBUlNFVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0MjtcbmV4cG9ydHMuSEFfRVJSX1dST05HX01SR19UQUJMRV9ERUYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0MztcbmV4cG9ydHMuSEFfRVJSX0NSQVNIRURfT05fUkVQQUlSICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0NDtcbmV4cG9ydHMuSEFfRVJSX0NSQVNIRURfT05fVVNBR0UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0NTtcbmV4cG9ydHMuSEFfRVJSX0xPQ0tfV0FJVF9USU1FT1VUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0NjtcbmV4cG9ydHMuSEFfRVJSX0xPQ0tfVEFCTEVfRlVMTCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0NztcbmV4cG9ydHMuSEFfRVJSX1JFQURfT05MWV9UUkFOU0FDVElPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0ODtcbmV4cG9ydHMuSEFfRVJSX0xPQ0tfREVBRExPQ0sgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0OTtcbmV4cG9ydHMuSEFfRVJSX0NBTk5PVF9BRERfRk9SRUlHTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1MDtcbmV4cG9ydHMuSEFfRVJSX05PX1JFRkVSRU5DRURfUk9XICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1MTtcbmV4cG9ydHMuSEFfRVJSX1JPV19JU19SRUZFUkVOQ0VEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1MjtcbmV4cG9ydHMuSEFfRVJSX05PX1NBVkVQT0lOVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1MztcbmV4cG9ydHMuSEFfRVJSX05PTl9VTklRVUVfQkxPQ0tfU0laRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1NDtcbmV4cG9ydHMuSEFfRVJSX05PX1NVQ0hfVEFCTEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1NTtcbmV4cG9ydHMuSEFfRVJSX1RBQkxFX0VYSVNUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1NjtcbmV4cG9ydHMuSEFfRVJSX05PX0NPTk5FQ1RJT04gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1NztcbmV4cG9ydHMuSEFfRVJSX05VTExfSU5fU1BBVElBTCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1ODtcbmV4cG9ydHMuSEFfRVJSX1RBQkxFX0RFRl9DSEFOR0VEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1OTtcbmV4cG9ydHMuSEFfRVJSX05PX1BBUlRJVElPTl9GT1VORCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2MDtcbmV4cG9ydHMuSEFfRVJSX1JCUl9MT0dHSU5HX0ZBSUxFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2MTtcbmV4cG9ydHMuSEFfRVJSX0RST1BfSU5ERVhfRksgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2MjtcbmV4cG9ydHMuSEFfRVJSX0ZPUkVJR05fRFVQTElDQVRFX0tFWSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2MztcbmV4cG9ydHMuSEFfRVJSX1RBQkxFX05FRURTX1VQR1JBREUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2NDtcbmV4cG9ydHMuSEFfRVJSX1RBQkxFX1JFQURPTkxZICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2NTtcbmV4cG9ydHMuSEFfRVJSX0FVVE9JTkNfUkVBRF9GQUlMRUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2NjtcbmV4cG9ydHMuSEFfRVJSX0FVVE9JTkNfRVJBTkdFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2NztcbmV4cG9ydHMuSEFfRVJSX0dFTkVSSUMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2ODtcbmV4cG9ydHMuSEFfRVJSX1JFQ09SRF9JU19USEVfU0FNRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2OTtcbmV4cG9ydHMuSEFfRVJSX0xPR0dJTkdfSU1QT1NTSUJMRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3MDtcbmV4cG9ydHMuSEFfRVJSX0NPUlJVUFRfRVZFTlQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3MTtcbmV4cG9ydHMuSEFfRVJSX05FV19GSUxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3MjtcbmV4cG9ydHMuSEFfRVJSX1JPV1NfRVZFTlRfQVBQTFkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3MztcbmV4cG9ydHMuSEFfRVJSX0lOSVRJQUxJWkFUSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3NDtcbmV4cG9ydHMuSEFfRVJSX0ZJTEVfVE9PX1NIT1JUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3NTtcbmV4cG9ydHMuSEFfRVJSX1dST05HX0NSQyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3NjtcbmV4cG9ydHMuSEFfRVJSX1RPT19NQU5ZX0NPTkNVUlJFTlRfVFJYUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3NztcbmV4cG9ydHMuSEFfRVJSX05PVF9JTl9MT0NLX1BBUlRJVElPTlMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3ODtcbmV4cG9ydHMuSEFfRVJSX0lOREVYX0NPTF9UT09fTE9ORyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3OTtcbmV4cG9ydHMuSEFfRVJSX0lOREVYX0NPUlJVUFQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4MDtcbmV4cG9ydHMuSEFfRVJSX1VORE9fUkVDX1RPT19CSUcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4MTtcbmV4cG9ydHMuSEFfRlRTX0lOVkFMSURfRE9DSUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4MjtcbmV4cG9ydHMuSEFfRVJSX1RBQkxFX0lOX0ZLX0NIRUNLICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4MztcbmV4cG9ydHMuSEFfRVJSX1RBQkxFU1BBQ0VfRVhJU1RTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4NDtcbmV4cG9ydHMuSEFfRVJSX1RPT19NQU5ZX0ZJRUxEUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4NTtcbmV4cG9ydHMuSEFfRVJSX1JPV19JTl9XUk9OR19QQVJUSVRJT04gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4NjtcbmV4cG9ydHMuSEFfRVJSX0lOTk9EQl9SRUFEX09OTFkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4NztcbmV4cG9ydHMuSEFfRVJSX0ZUU19FWENFRURfUkVTVUxUX0NBQ0hFX0xJTUlUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4ODtcbmV4cG9ydHMuSEFfRVJSX1RFTVBfRklMRV9XUklURV9GQUlMVVJFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4OTtcbmV4cG9ydHMuSEFfRVJSX0lOTk9EQl9GT1JDRURfUkVDT1ZFUlkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE5MDtcbmV4cG9ydHMuSEFfRVJSX0ZUU19UT09fTUFOWV9XT1JEU19JTl9QSFJBU0UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE5MTtcbmV4cG9ydHMuRVJfSEFTSENISyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwMDA7XG5leHBvcnRzLkVSX05JU0FNQ0hLICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDAxO1xuZXhwb3J0cy5FUl9OTyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTAwMjtcbmV4cG9ydHMuRVJfWUVTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwMDM7XG5leHBvcnRzLkVSX0NBTlRfQ1JFQVRFX0ZJTEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDA0O1xuZXhwb3J0cy5FUl9DQU5UX0NSRUFURV9UQUJMRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTAwNTtcbmV4cG9ydHMuRVJfQ0FOVF9DUkVBVEVfREIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwMDY7XG5leHBvcnRzLkVSX0RCX0NSRUFURV9FWElTVFMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDA3O1xuZXhwb3J0cy5FUl9EQl9EUk9QX0VYSVNUUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTAwODtcbmV4cG9ydHMuRVJfREJfRFJPUF9ERUxFVEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwMDk7XG5leHBvcnRzLkVSX0RCX0RST1BfUk1ESVIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDEwO1xuZXhwb3J0cy5FUl9DQU5UX0RFTEVURV9GSUxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTAxMTtcbmV4cG9ydHMuRVJfQ0FOVF9GSU5EX1NZU1RFTV9SRUMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwMTI7XG5leHBvcnRzLkVSX0NBTlRfR0VUX1NUQVQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDEzO1xuZXhwb3J0cy5FUl9DQU5UX0dFVF9XRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTAxNDtcbmV4cG9ydHMuRVJfQ0FOVF9MT0NLICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwMTU7XG5leHBvcnRzLkVSX0NBTlRfT1BFTl9GSUxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDE2O1xuZXhwb3J0cy5FUl9GSUxFX05PVF9GT1VORCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTAxNztcbmV4cG9ydHMuRVJfQ0FOVF9SRUFEX0RJUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwMTg7XG5leHBvcnRzLkVSX0NBTlRfU0VUX1dEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDE5O1xuZXhwb3J0cy5FUl9DSEVDS1JFQUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTAyMDtcbmV4cG9ydHMuRVJfRElTS19GVUxMICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwMjE7XG5leHBvcnRzLkVSX0RVUF9LRVkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDIyO1xuZXhwb3J0cy5FUl9FUlJPUl9PTl9DTE9TRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTAyMztcbmV4cG9ydHMuRVJfRVJST1JfT05fUkVBRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwMjQ7XG5leHBvcnRzLkVSX0VSUk9SX09OX1JFTkFNRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDI1O1xuZXhwb3J0cy5FUl9FUlJPUl9PTl9XUklURSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTAyNjtcbmV4cG9ydHMuRVJfRklMRV9VU0VEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwMjc7XG5leHBvcnRzLkVSX0ZJTFNPUlRfQUJPUlQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDI4O1xuZXhwb3J0cy5FUl9GT1JNX05PVF9GT1VORCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTAyOTtcbmV4cG9ydHMuRVJfR0VUX0VSUk5PICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwMzA7XG5leHBvcnRzLkVSX0lMTEVHQUxfSEEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDMxO1xuZXhwb3J0cy5FUl9LRVlfTk9UX0ZPVU5EICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTAzMjtcbmV4cG9ydHMuRVJfTk9UX0ZPUk1fRklMRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwMzM7XG5leHBvcnRzLkVSX05PVF9LRVlGSUxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDM0O1xuZXhwb3J0cy5FUl9PTERfS0VZRklMRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTAzNTtcbmV4cG9ydHMuRVJfT1BFTl9BU19SRUFET05MWSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwMzY7XG5leHBvcnRzLkVSX09VVE9GTUVNT1JZICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDM3O1xuZXhwb3J0cy5FUl9PVVRfT0ZfU09SVE1FTU9SWSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTAzODtcbmV4cG9ydHMuRVJfVU5FWFBFQ1RFRF9FT0YgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwMzk7XG5leHBvcnRzLkVSX0NPTl9DT1VOVF9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDQwO1xuZXhwb3J0cy5FUl9PVVRfT0ZfUkVTT1VSQ0VTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTA0MTtcbmV4cG9ydHMuRVJfQkFEX0hPU1RfRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwNDI7XG5leHBvcnRzLkVSX0hBTkRTSEFLRV9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDQzO1xuZXhwb3J0cy5FUl9EQkFDQ0VTU19ERU5JRURfRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTA0NDtcbmV4cG9ydHMuRVJfQUNDRVNTX0RFTklFRF9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwNDU7XG5leHBvcnRzLkVSX05PX0RCX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDQ2O1xuZXhwb3J0cy5FUl9VTktOT1dOX0NPTV9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTA0NztcbmV4cG9ydHMuRVJfQkFEX05VTExfRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwNDg7XG5leHBvcnRzLkVSX0JBRF9EQl9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDQ5O1xuZXhwb3J0cy5FUl9UQUJMRV9FWElTVFNfRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTA1MDtcbmV4cG9ydHMuRVJfQkFEX1RBQkxFX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwNTE7XG5leHBvcnRzLkVSX05PTl9VTklRX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDUyO1xuZXhwb3J0cy5FUl9TRVJWRVJfU0hVVERPV04gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTA1MztcbmV4cG9ydHMuRVJfQkFEX0ZJRUxEX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwNTQ7XG5leHBvcnRzLkVSX1dST05HX0ZJRUxEX1dJVEhfR1JPVVAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDU1O1xuZXhwb3J0cy5FUl9XUk9OR19HUk9VUF9GSUVMRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTA1NjtcbmV4cG9ydHMuRVJfV1JPTkdfU1VNX1NFTEVDVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwNTc7XG5leHBvcnRzLkVSX1dST05HX1ZBTFVFX0NPVU5UICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDU4O1xuZXhwb3J0cy5FUl9UT09fTE9OR19JREVOVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTA1OTtcbmV4cG9ydHMuRVJfRFVQX0ZJRUxETkFNRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwNjA7XG5leHBvcnRzLkVSX0RVUF9LRVlOQU1FICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDYxO1xuZXhwb3J0cy5FUl9EVVBfRU5UUlkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTA2MjtcbmV4cG9ydHMuRVJfV1JPTkdfRklFTERfU1BFQyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwNjM7XG5leHBvcnRzLkVSX1BBUlNFX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDY0O1xuZXhwb3J0cy5FUl9FTVBUWV9RVUVSWSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTA2NTtcbmV4cG9ydHMuRVJfTk9OVU5JUV9UQUJMRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwNjY7XG5leHBvcnRzLkVSX0lOVkFMSURfREVGQVVMVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDY3O1xuZXhwb3J0cy5FUl9NVUxUSVBMRV9QUklfS0VZICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTA2ODtcbmV4cG9ydHMuRVJfVE9PX01BTllfS0VZUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwNjk7XG5leHBvcnRzLkVSX1RPT19NQU5ZX0tFWV9QQVJUUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDcwO1xuZXhwb3J0cy5FUl9UT09fTE9OR19LRVkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTA3MTtcbmV4cG9ydHMuRVJfS0VZX0NPTFVNTl9ET0VTX05PVF9FWElUUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwNzI7XG5leHBvcnRzLkVSX0JMT0JfVVNFRF9BU19LRVkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDczO1xuZXhwb3J0cy5FUl9UT09fQklHX0ZJRUxETEVOR1RIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTA3NDtcbmV4cG9ydHMuRVJfV1JPTkdfQVVUT19LRVkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwNzU7XG5leHBvcnRzLkVSX1JFQURZICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDc2O1xuZXhwb3J0cy5FUl9OT1JNQUxfU0hVVERPV04gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTA3NztcbmV4cG9ydHMuRVJfR09UX1NJR05BTCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwNzg7XG5leHBvcnRzLkVSX1NIVVRET1dOX0NPTVBMRVRFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDc5O1xuZXhwb3J0cy5FUl9GT1JDSU5HX0NMT1NFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTA4MDtcbmV4cG9ydHMuRVJfSVBTT0NLX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwODE7XG5leHBvcnRzLkVSX05PX1NVQ0hfSU5ERVggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDgyO1xuZXhwb3J0cy5FUl9XUk9OR19GSUVMRF9URVJNSU5BVE9SUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTA4MztcbmV4cG9ydHMuRVJfQkxPQlNfQU5EX05PX1RFUk1JTkFURUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwODQ7XG5leHBvcnRzLkVSX1RFWFRGSUxFX05PVF9SRUFEQUJMRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDg1O1xuZXhwb3J0cy5FUl9GSUxFX0VYSVNUU19FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTA4NjtcbmV4cG9ydHMuRVJfTE9BRF9JTkZPICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwODc7XG5leHBvcnRzLkVSX0FMVEVSX0lORk8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDg4O1xuZXhwb3J0cy5FUl9XUk9OR19TVUJfS0VZICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTA4OTtcbmV4cG9ydHMuRVJfQ0FOVF9SRU1PVkVfQUxMX0ZJRUxEUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwOTA7XG5leHBvcnRzLkVSX0NBTlRfRFJPUF9GSUVMRF9PUl9LRVkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDkxO1xuZXhwb3J0cy5FUl9JTlNFUlRfSU5GTyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTA5MjtcbmV4cG9ydHMuRVJfVVBEQVRFX1RBQkxFX1VTRUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwOTM7XG5leHBvcnRzLkVSX05PX1NVQ0hfVEhSRUFEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDk0O1xuZXhwb3J0cy5FUl9LSUxMX0RFTklFRF9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTA5NTtcbmV4cG9ydHMuRVJfTk9fVEFCTEVTX1VTRUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwOTY7XG5leHBvcnRzLkVSX1RPT19CSUdfU0VUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMDk3O1xuZXhwb3J0cy5FUl9OT19VTklRVUVfTE9HRklMRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTA5ODtcbmV4cG9ydHMuRVJfVEFCTEVfTk9UX0xPQ0tFRF9GT1JfV1JJVEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEwOTk7XG5leHBvcnRzLkVSX1RBQkxFX05PVF9MT0NLRUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTAwO1xuZXhwb3J0cy5FUl9CTE9CX0NBTlRfSEFWRV9ERUZBVUxUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTEwMTtcbmV4cG9ydHMuRVJfV1JPTkdfREJfTkFNRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExMDI7XG5leHBvcnRzLkVSX1dST05HX1RBQkxFX05BTUUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTAzO1xuZXhwb3J0cy5FUl9UT09fQklHX1NFTEVDVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTEwNDtcbmV4cG9ydHMuRVJfVU5LTk9XTl9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExMDU7XG5leHBvcnRzLkVSX1VOS05PV05fUFJPQ0VEVVJFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTA2O1xuZXhwb3J0cy5FUl9XUk9OR19QQVJBTUNPVU5UX1RPX1BST0NFRFVSRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTEwNztcbmV4cG9ydHMuRVJfV1JPTkdfUEFSQU1FVEVSU19UT19QUk9DRURVUkUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExMDg7XG5leHBvcnRzLkVSX1VOS05PV05fVEFCTEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTA5O1xuZXhwb3J0cy5FUl9GSUVMRF9TUEVDSUZJRURfVFdJQ0UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTExMDtcbmV4cG9ydHMuRVJfSU5WQUxJRF9HUk9VUF9GVU5DX1VTRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExMTE7XG5leHBvcnRzLkVSX1VOU1VQUE9SVEVEX0VYVEVOU0lPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTEyO1xuZXhwb3J0cy5FUl9UQUJMRV9NVVNUX0hBVkVfQ09MVU1OUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTExMztcbmV4cG9ydHMuRVJfUkVDT1JEX0ZJTEVfRlVMTCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExMTQ7XG5leHBvcnRzLkVSX1VOS05PV05fQ0hBUkFDVEVSX1NFVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTE1O1xuZXhwb3J0cy5FUl9UT09fTUFOWV9UQUJMRVMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTExNjtcbmV4cG9ydHMuRVJfVE9PX01BTllfRklFTERTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExMTc7XG5leHBvcnRzLkVSX1RPT19CSUdfUk9XU0laRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTE4O1xuZXhwb3J0cy5FUl9TVEFDS19PVkVSUlVOICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTExOTtcbmV4cG9ydHMuRVJfV1JPTkdfT1VURVJfSk9JTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExMjA7XG5leHBvcnRzLkVSX05VTExfQ09MVU1OX0lOX0lOREVYICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTIxO1xuZXhwb3J0cy5FUl9DQU5UX0ZJTkRfVURGICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTEyMjtcbmV4cG9ydHMuRVJfQ0FOVF9JTklUSUFMSVpFX1VERiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExMjM7XG5leHBvcnRzLkVSX1VERl9OT19QQVRIUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTI0O1xuZXhwb3J0cy5FUl9VREZfRVhJU1RTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTEyNTtcbmV4cG9ydHMuRVJfQ0FOVF9PUEVOX0xJQlJBUlkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExMjY7XG5leHBvcnRzLkVSX0NBTlRfRklORF9ETF9FTlRSWSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTI3O1xuZXhwb3J0cy5FUl9GVU5DVElPTl9OT1RfREVGSU5FRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTEyODtcbmV4cG9ydHMuRVJfSE9TVF9JU19CTE9DS0VEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExMjk7XG5leHBvcnRzLkVSX0hPU1RfTk9UX1BSSVZJTEVHRUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTMwO1xuZXhwb3J0cy5FUl9QQVNTV09SRF9BTk9OWU1PVVNfVVNFUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTEzMTtcbmV4cG9ydHMuRVJfUEFTU1dPUkRfTk9UX0FMTE9XRUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExMzI7XG5leHBvcnRzLkVSX1BBU1NXT1JEX05PX01BVENIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTMzO1xuZXhwb3J0cy5FUl9VUERBVEVfSU5GTyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTEzNDtcbmV4cG9ydHMuRVJfQ0FOVF9DUkVBVEVfVEhSRUFEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExMzU7XG5leHBvcnRzLkVSX1dST05HX1ZBTFVFX0NPVU5UX09OX1JPVyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTM2O1xuZXhwb3J0cy5FUl9DQU5UX1JFT1BFTl9UQUJMRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTEzNztcbmV4cG9ydHMuRVJfSU5WQUxJRF9VU0VfT0ZfTlVMTCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExMzg7XG5leHBvcnRzLkVSX1JFR0VYUF9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTM5O1xuZXhwb3J0cy5FUl9NSVhfT0ZfR1JPVVBfRlVOQ19BTkRfRklFTERTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE0MDtcbmV4cG9ydHMuRVJfTk9ORVhJU1RJTkdfR1JBTlQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExNDE7XG5leHBvcnRzLkVSX1RBQkxFQUNDRVNTX0RFTklFRF9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTQyO1xuZXhwb3J0cy5FUl9DT0xVTU5BQ0NFU1NfREVOSUVEX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE0MztcbmV4cG9ydHMuRVJfSUxMRUdBTF9HUkFOVF9GT1JfVEFCTEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExNDQ7XG5leHBvcnRzLkVSX0dSQU5UX1dST05HX0hPU1RfT1JfVVNFUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTQ1O1xuZXhwb3J0cy5FUl9OT19TVUNIX1RBQkxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE0NjtcbmV4cG9ydHMuRVJfTk9ORVhJU1RJTkdfVEFCTEVfR1JBTlQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExNDc7XG5leHBvcnRzLkVSX05PVF9BTExPV0VEX0NPTU1BTkQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTQ4O1xuZXhwb3J0cy5FUl9TWU5UQVhfRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE0OTtcbmV4cG9ydHMuRVJfREVMQVlFRF9DQU5UX0NIQU5HRV9MT0NLICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExNTA7XG5leHBvcnRzLkVSX1RPT19NQU5ZX0RFTEFZRURfVEhSRUFEUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTUxO1xuZXhwb3J0cy5FUl9BQk9SVElOR19DT05ORUNUSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE1MjtcbmV4cG9ydHMuRVJfTkVUX1BBQ0tFVF9UT09fTEFSR0UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExNTM7XG5leHBvcnRzLkVSX05FVF9SRUFEX0VSUk9SX0ZST01fUElQRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTU0O1xuZXhwb3J0cy5FUl9ORVRfRkNOVExfRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE1NTtcbmV4cG9ydHMuRVJfTkVUX1BBQ0tFVFNfT1VUX09GX09SREVSICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExNTY7XG5leHBvcnRzLkVSX05FVF9VTkNPTVBSRVNTX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTU3O1xuZXhwb3J0cy5FUl9ORVRfUkVBRF9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE1ODtcbmV4cG9ydHMuRVJfTkVUX1JFQURfSU5URVJSVVBURUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExNTk7XG5leHBvcnRzLkVSX05FVF9FUlJPUl9PTl9XUklURSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTYwO1xuZXhwb3J0cy5FUl9ORVRfV1JJVEVfSU5URVJSVVBURUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE2MTtcbmV4cG9ydHMuRVJfVE9PX0xPTkdfU1RSSU5HICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExNjI7XG5leHBvcnRzLkVSX1RBQkxFX0NBTlRfSEFORExFX0JMT0IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTYzO1xuZXhwb3J0cy5FUl9UQUJMRV9DQU5UX0hBTkRMRV9BVVRPX0lOQ1JFTUVOVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE2NDtcbmV4cG9ydHMuRVJfREVMQVlFRF9JTlNFUlRfVEFCTEVfTE9DS0VEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExNjU7XG5leHBvcnRzLkVSX1dST05HX0NPTFVNTl9OQU1FICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTY2O1xuZXhwb3J0cy5FUl9XUk9OR19LRVlfQ09MVU1OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE2NztcbmV4cG9ydHMuRVJfV1JPTkdfTVJHX1RBQkxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExNjg7XG5leHBvcnRzLkVSX0RVUF9VTklRVUUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTY5O1xuZXhwb3J0cy5FUl9CTE9CX0tFWV9XSVRIT1VUX0xFTkdUSCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE3MDtcbmV4cG9ydHMuRVJfUFJJTUFSWV9DQU5UX0hBVkVfTlVMTCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExNzE7XG5leHBvcnRzLkVSX1RPT19NQU5ZX1JPV1MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTcyO1xuZXhwb3J0cy5FUl9SRVFVSVJFU19QUklNQVJZX0tFWSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE3MztcbmV4cG9ydHMuRVJfTk9fUkFJRF9DT01QSUxFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExNzQ7XG5leHBvcnRzLkVSX1VQREFURV9XSVRIT1VUX0tFWV9JTl9TQUZFX01PREUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTc1O1xuZXhwb3J0cy5FUl9LRVlfRE9FU19OT1RfRVhJVFMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE3NjtcbmV4cG9ydHMuRVJfQ0hFQ0tfTk9fU1VDSF9UQUJMRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExNzc7XG5leHBvcnRzLkVSX0NIRUNLX05PVF9JTVBMRU1FTlRFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTc4O1xuZXhwb3J0cy5FUl9DQU5UX0RPX1RISVNfRFVSSU5HX0FOX1RSQU5TQUNUSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE3OTtcbmV4cG9ydHMuRVJfRVJST1JfRFVSSU5HX0NPTU1JVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExODA7XG5leHBvcnRzLkVSX0VSUk9SX0RVUklOR19ST0xMQkFDSyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTgxO1xuZXhwb3J0cy5FUl9FUlJPUl9EVVJJTkdfRkxVU0hfTE9HUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE4MjtcbmV4cG9ydHMuRVJfRVJST1JfRFVSSU5HX0NIRUNLUE9JTlQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExODM7XG5leHBvcnRzLkVSX05FV19BQk9SVElOR19DT05ORUNUSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTg0O1xuZXhwb3J0cy5FUl9EVU1QX05PVF9JTVBMRU1FTlRFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE4NTtcbmV4cG9ydHMuRVJfRkxVU0hfTUFTVEVSX0JJTkxPR19DTE9TRUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExODY7XG5leHBvcnRzLkVSX0lOREVYX1JFQlVJTEQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTg3O1xuZXhwb3J0cy5FUl9NQVNURVIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE4ODtcbmV4cG9ydHMuRVJfTUFTVEVSX05FVF9SRUFEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExODk7XG5leHBvcnRzLkVSX01BU1RFUl9ORVRfV1JJVEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTkwO1xuZXhwb3J0cy5FUl9GVF9NQVRDSElOR19LRVlfTk9UX0ZPVU5EICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE5MTtcbmV4cG9ydHMuRVJfTE9DS19PUl9BQ1RJVkVfVFJBTlNBQ1RJT04gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExOTI7XG5leHBvcnRzLkVSX1VOS05PV05fU1lTVEVNX1ZBUklBQkxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTkzO1xuZXhwb3J0cy5FUl9DUkFTSEVEX09OX1VTQUdFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE5NDtcbmV4cG9ydHMuRVJfQ1JBU0hFRF9PTl9SRVBBSVIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExOTU7XG5leHBvcnRzLkVSX1dBUk5JTkdfTk9UX0NPTVBMRVRFX1JPTExCQUNLICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTk2O1xuZXhwb3J0cy5FUl9UUkFOU19DQUNIRV9GVUxMICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTE5NztcbmV4cG9ydHMuRVJfU0xBVkVfTVVTVF9TVE9QICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDExOTg7XG5leHBvcnRzLkVSX1NMQVZFX05PVF9SVU5OSU5HICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMTk5O1xuZXhwb3J0cy5FUl9CQURfU0xBVkUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTIwMDtcbmV4cG9ydHMuRVJfTUFTVEVSX0lORk8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyMDE7XG5leHBvcnRzLkVSX1NMQVZFX1RIUkVBRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjAyO1xuZXhwb3J0cy5FUl9UT09fTUFOWV9VU0VSX0NPTk5FQ1RJT05TICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTIwMztcbmV4cG9ydHMuRVJfU0VUX0NPTlNUQU5UU19PTkxZICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyMDQ7XG5leHBvcnRzLkVSX0xPQ0tfV0FJVF9USU1FT1VUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjA1O1xuZXhwb3J0cy5FUl9MT0NLX1RBQkxFX0ZVTEwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTIwNjtcbmV4cG9ydHMuRVJfUkVBRF9PTkxZX1RSQU5TQUNUSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyMDc7XG5leHBvcnRzLkVSX0RST1BfREJfV0lUSF9SRUFEX0xPQ0sgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjA4O1xuZXhwb3J0cy5FUl9DUkVBVEVfREJfV0lUSF9SRUFEX0xPQ0sgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTIwOTtcbmV4cG9ydHMuRVJfV1JPTkdfQVJHVU1FTlRTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyMTA7XG5leHBvcnRzLkVSX05PX1BFUk1JU1NJT05fVE9fQ1JFQVRFX1VTRVIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjExO1xuZXhwb3J0cy5FUl9VTklPTl9UQUJMRVNfSU5fRElGRkVSRU5UX0RJUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTIxMjtcbmV4cG9ydHMuRVJfTE9DS19ERUFETE9DSyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyMTM7XG5leHBvcnRzLkVSX1RBQkxFX0NBTlRfSEFORExFX0ZUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjE0O1xuZXhwb3J0cy5FUl9DQU5OT1RfQUREX0ZPUkVJR04gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTIxNTtcbmV4cG9ydHMuRVJfTk9fUkVGRVJFTkNFRF9ST1cgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyMTY7XG5leHBvcnRzLkVSX1JPV19JU19SRUZFUkVOQ0VEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjE3O1xuZXhwb3J0cy5FUl9DT05ORUNUX1RPX01BU1RFUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTIxODtcbmV4cG9ydHMuRVJfUVVFUllfT05fTUFTVEVSICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyMTk7XG5leHBvcnRzLkVSX0VSUk9SX1dIRU5fRVhFQ1VUSU5HX0NPTU1BTkQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjIwO1xuZXhwb3J0cy5FUl9XUk9OR19VU0FHRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTIyMTtcbmV4cG9ydHMuRVJfV1JPTkdfTlVNQkVSX09GX0NPTFVNTlNfSU5fU0VMRUNUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyMjI7XG5leHBvcnRzLkVSX0NBTlRfVVBEQVRFX1dJVEhfUkVBRExPQ0sgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjIzO1xuZXhwb3J0cy5FUl9NSVhJTkdfTk9UX0FMTE9XRUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTIyNDtcbmV4cG9ydHMuRVJfRFVQX0FSR1VNRU5UICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyMjU7XG5leHBvcnRzLkVSX1VTRVJfTElNSVRfUkVBQ0hFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjI2O1xuZXhwb3J0cy5FUl9TUEVDSUZJQ19BQ0NFU1NfREVOSUVEX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTIyNztcbmV4cG9ydHMuRVJfTE9DQUxfVkFSSUFCTEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyMjg7XG5leHBvcnRzLkVSX0dMT0JBTF9WQVJJQUJMRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjI5O1xuZXhwb3J0cy5FUl9OT19ERUZBVUxUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTIzMDtcbmV4cG9ydHMuRVJfV1JPTkdfVkFMVUVfRk9SX1ZBUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyMzE7XG5leHBvcnRzLkVSX1dST05HX1RZUEVfRk9SX1ZBUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjMyO1xuZXhwb3J0cy5FUl9WQVJfQ0FOVF9CRV9SRUFEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTIzMztcbmV4cG9ydHMuRVJfQ0FOVF9VU0VfT1BUSU9OX0hFUkUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyMzQ7XG5leHBvcnRzLkVSX05PVF9TVVBQT1JURURfWUVUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjM1O1xuZXhwb3J0cy5FUl9NQVNURVJfRkFUQUxfRVJST1JfUkVBRElOR19CSU5MT0cgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTIzNjtcbmV4cG9ydHMuRVJfU0xBVkVfSUdOT1JFRF9UQUJMRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyMzc7XG5leHBvcnRzLkVSX0lOQ09SUkVDVF9HTE9CQUxfTE9DQUxfVkFSICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjM4O1xuZXhwb3J0cy5FUl9XUk9OR19GS19ERUYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTIzOTtcbmV4cG9ydHMuRVJfS0VZX1JFRl9ET19OT1RfTUFUQ0hfVEFCTEVfUkVGICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyNDA7XG5leHBvcnRzLkVSX09QRVJBTkRfQ09MVU1OUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjQxO1xuZXhwb3J0cy5FUl9TVUJRVUVSWV9OT18xX1JPVyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI0MjtcbmV4cG9ydHMuRVJfVU5LTk9XTl9TVE1UX0hBTkRMRVIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyNDM7XG5leHBvcnRzLkVSX0NPUlJVUFRfSEVMUF9EQiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjQ0O1xuZXhwb3J0cy5FUl9DWUNMSUNfUkVGRVJFTkNFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI0NTtcbmV4cG9ydHMuRVJfQVVUT19DT05WRVJUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyNDY7XG5leHBvcnRzLkVSX0lMTEVHQUxfUkVGRVJFTkNFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjQ3O1xuZXhwb3J0cy5FUl9ERVJJVkVEX01VU1RfSEFWRV9BTElBUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI0ODtcbmV4cG9ydHMuRVJfU0VMRUNUX1JFRFVDRUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyNDk7XG5leHBvcnRzLkVSX1RBQkxFTkFNRV9OT1RfQUxMT1dFRF9IRVJFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjUwO1xuZXhwb3J0cy5FUl9OT1RfU1VQUE9SVEVEX0FVVEhfTU9ERSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI1MTtcbmV4cG9ydHMuRVJfU1BBVElBTF9DQU5UX0hBVkVfTlVMTCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyNTI7XG5leHBvcnRzLkVSX0NPTExBVElPTl9DSEFSU0VUX01JU01BVENIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjUzO1xuZXhwb3J0cy5FUl9TTEFWRV9XQVNfUlVOTklORyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI1NDtcbmV4cG9ydHMuRVJfU0xBVkVfV0FTX05PVF9SVU5OSU5HICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyNTU7XG5leHBvcnRzLkVSX1RPT19CSUdfRk9SX1VOQ09NUFJFU1MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjU2O1xuZXhwb3J0cy5FUl9aTElCX1pfTUVNX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI1NztcbmV4cG9ydHMuRVJfWkxJQl9aX0JVRl9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyNTg7XG5leHBvcnRzLkVSX1pMSUJfWl9EQVRBX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjU5O1xuZXhwb3J0cy5FUl9DVVRfVkFMVUVfR1JPVVBfQ09OQ0FUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI2MDtcbmV4cG9ydHMuRVJfV0FSTl9UT09fRkVXX1JFQ09SRFMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyNjE7XG5leHBvcnRzLkVSX1dBUk5fVE9PX01BTllfUkVDT1JEUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjYyO1xuZXhwb3J0cy5FUl9XQVJOX05VTExfVE9fTk9UTlVMTCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI2MztcbmV4cG9ydHMuRVJfV0FSTl9EQVRBX09VVF9PRl9SQU5HRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyNjQ7XG5leHBvcnRzLldBUk5fREFUQV9UUlVOQ0FURUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjY1O1xuZXhwb3J0cy5FUl9XQVJOX1VTSU5HX09USEVSX0hBTkRMRVIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI2NjtcbmV4cG9ydHMuRVJfQ0FOVF9BR0dSRUdBVEVfMkNPTExBVElPTlMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyNjc7XG5leHBvcnRzLkVSX0RST1BfVVNFUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjY4O1xuZXhwb3J0cy5FUl9SRVZPS0VfR1JBTlRTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI2OTtcbmV4cG9ydHMuRVJfQ0FOVF9BR0dSRUdBVEVfM0NPTExBVElPTlMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyNzA7XG5leHBvcnRzLkVSX0NBTlRfQUdHUkVHQVRFX05DT0xMQVRJT05TICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjcxO1xuZXhwb3J0cy5FUl9WQVJJQUJMRV9JU19OT1RfU1RSVUNUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI3MjtcbmV4cG9ydHMuRVJfVU5LTk9XTl9DT0xMQVRJT04gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyNzM7XG5leHBvcnRzLkVSX1NMQVZFX0lHTk9SRURfU1NMX1BBUkFNUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjc0O1xuZXhwb3J0cy5FUl9TRVJWRVJfSVNfSU5fU0VDVVJFX0FVVEhfTU9ERSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI3NTtcbmV4cG9ydHMuRVJfV0FSTl9GSUVMRF9SRVNPTFZFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyNzY7XG5leHBvcnRzLkVSX0JBRF9TTEFWRV9VTlRJTF9DT05EICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjc3O1xuZXhwb3J0cy5FUl9NSVNTSU5HX1NLSVBfU0xBVkUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI3ODtcbmV4cG9ydHMuRVJfVU5USUxfQ09ORF9JR05PUkVEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyNzk7XG5leHBvcnRzLkVSX1dST05HX05BTUVfRk9SX0lOREVYICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjgwO1xuZXhwb3J0cy5FUl9XUk9OR19OQU1FX0ZPUl9DQVRBTE9HICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI4MTtcbmV4cG9ydHMuRVJfV0FSTl9RQ19SRVNJWkUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyODI7XG5leHBvcnRzLkVSX0JBRF9GVF9DT0xVTU4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjgzO1xuZXhwb3J0cy5FUl9VTktOT1dOX0tFWV9DQUNIRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI4NDtcbmV4cG9ydHMuRVJfV0FSTl9IT1NUTkFNRV9XT05UX1dPUksgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyODU7XG5leHBvcnRzLkVSX1VOS05PV05fU1RPUkFHRV9FTkdJTkUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjg2O1xuZXhwb3J0cy5FUl9XQVJOX0RFUFJFQ0FURURfU1lOVEFYICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI4NztcbmV4cG9ydHMuRVJfTk9OX1VQREFUQUJMRV9UQUJMRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyODg7XG5leHBvcnRzLkVSX0ZFQVRVUkVfRElTQUJMRUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjg5O1xuZXhwb3J0cy5FUl9PUFRJT05fUFJFVkVOVFNfU1RBVEVNRU5UICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI5MDtcbmV4cG9ydHMuRVJfRFVQTElDQVRFRF9WQUxVRV9JTl9UWVBFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyOTE7XG5leHBvcnRzLkVSX1RSVU5DQVRFRF9XUk9OR19WQUxVRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjkyO1xuZXhwb3J0cy5FUl9UT09fTVVDSF9BVVRPX1RJTUVTVEFNUF9DT0xTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI5MztcbmV4cG9ydHMuRVJfSU5WQUxJRF9PTl9VUERBVEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyOTQ7XG5leHBvcnRzLkVSX1VOU1VQUE9SVEVEX1BTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjk1O1xuZXhwb3J0cy5FUl9HRVRfRVJSTVNHICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI5NjtcbmV4cG9ydHMuRVJfR0VUX1RFTVBPUkFSWV9FUlJNU0cgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEyOTc7XG5leHBvcnRzLkVSX1VOS05PV05fVElNRV9aT05FICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMjk4O1xuZXhwb3J0cy5FUl9XQVJOX0lOVkFMSURfVElNRVNUQU1QICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI5OTtcbmV4cG9ydHMuRVJfSU5WQUxJRF9DSEFSQUNURVJfU1RSSU5HICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzMDA7XG5leHBvcnRzLkVSX1dBUk5fQUxMT1dFRF9QQUNLRVRfT1ZFUkZMT1dFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzAxO1xuZXhwb3J0cy5FUl9DT05GTElDVElOR19ERUNMQVJBVElPTlMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTMwMjtcbmV4cG9ydHMuRVJfU1BfTk9fUkVDVVJTSVZFX0NSRUFURSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzMDM7XG5leHBvcnRzLkVSX1NQX0FMUkVBRFlfRVhJU1RTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzA0O1xuZXhwb3J0cy5FUl9TUF9ET0VTX05PVF9FWElTVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTMwNTtcbmV4cG9ydHMuRVJfU1BfRFJPUF9GQUlMRUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzMDY7XG5leHBvcnRzLkVSX1NQX1NUT1JFX0ZBSUxFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzA3O1xuZXhwb3J0cy5FUl9TUF9MSUxBQkVMX01JU01BVENIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTMwODtcbmV4cG9ydHMuRVJfU1BfTEFCRUxfUkVERUZJTkUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzMDk7XG5leHBvcnRzLkVSX1NQX0xBQkVMX01JU01BVENIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzEwO1xuZXhwb3J0cy5FUl9TUF9VTklOSVRfVkFSICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTMxMTtcbmV4cG9ydHMuRVJfU1BfQkFEU0VMRUNUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzMTI7XG5leHBvcnRzLkVSX1NQX0JBRFJFVFVSTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzEzO1xuZXhwb3J0cy5FUl9TUF9CQURTVEFURU1FTlQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTMxNDtcbmV4cG9ydHMuRVJfVVBEQVRFX0xPR19ERVBSRUNBVEVEX0lHTk9SRUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzMTU7XG5leHBvcnRzLkVSX1VQREFURV9MT0dfREVQUkVDQVRFRF9UUkFOU0xBVEVEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzE2O1xuZXhwb3J0cy5FUl9RVUVSWV9JTlRFUlJVUFRFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTMxNztcbmV4cG9ydHMuRVJfU1BfV1JPTkdfTk9fT0ZfQVJHUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzMTg7XG5leHBvcnRzLkVSX1NQX0NPTkRfTUlTTUFUQ0ggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzE5O1xuZXhwb3J0cy5FUl9TUF9OT1JFVFVSTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTMyMDtcbmV4cG9ydHMuRVJfU1BfTk9SRVRVUk5FTkQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzMjE7XG5leHBvcnRzLkVSX1NQX0JBRF9DVVJTT1JfUVVFUlkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzIyO1xuZXhwb3J0cy5FUl9TUF9CQURfQ1VSU09SX1NFTEVDVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTMyMztcbmV4cG9ydHMuRVJfU1BfQ1VSU09SX01JU01BVENIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzMjQ7XG5leHBvcnRzLkVSX1NQX0NVUlNPUl9BTFJFQURZX09QRU4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzI1O1xuZXhwb3J0cy5FUl9TUF9DVVJTT1JfTk9UX09QRU4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTMyNjtcbmV4cG9ydHMuRVJfU1BfVU5ERUNMQVJFRF9WQVIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzMjc7XG5leHBvcnRzLkVSX1NQX1dST05HX05PX09GX0ZFVENIX0FSR1MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzI4O1xuZXhwb3J0cy5FUl9TUF9GRVRDSF9OT19EQVRBICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTMyOTtcbmV4cG9ydHMuRVJfU1BfRFVQX1BBUkFNICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzMzA7XG5leHBvcnRzLkVSX1NQX0RVUF9WQVIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzMxO1xuZXhwb3J0cy5FUl9TUF9EVVBfQ09ORCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTMzMjtcbmV4cG9ydHMuRVJfU1BfRFVQX0NVUlMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzMzM7XG5leHBvcnRzLkVSX1NQX0NBTlRfQUxURVIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzM0O1xuZXhwb3J0cy5FUl9TUF9TVUJTRUxFQ1RfTllJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTMzNTtcbmV4cG9ydHMuRVJfU1RNVF9OT1RfQUxMT1dFRF9JTl9TRl9PUl9UUkcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzMzY7XG5leHBvcnRzLkVSX1NQX1ZBUkNPTkRfQUZURVJfQ1VSU0hORExSICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzM3O1xuZXhwb3J0cy5FUl9TUF9DVVJTT1JfQUZURVJfSEFORExFUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTMzODtcbmV4cG9ydHMuRVJfU1BfQ0FTRV9OT1RfRk9VTkQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzMzk7XG5leHBvcnRzLkVSX0ZQQVJTRVJfVE9PX0JJR19GSUxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzQwO1xuZXhwb3J0cy5FUl9GUEFSU0VSX0JBRF9IRUFERVIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTM0MTtcbmV4cG9ydHMuRVJfRlBBUlNFUl9FT0ZfSU5fQ09NTUVOVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzNDI7XG5leHBvcnRzLkVSX0ZQQVJTRVJfRVJST1JfSU5fUEFSQU1FVEVSICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzQzO1xuZXhwb3J0cy5FUl9GUEFSU0VSX0VPRl9JTl9VTktOT1dOX1BBUkFNRVRFUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTM0NDtcbmV4cG9ydHMuRVJfVklFV19OT19FWFBMQUlOICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzNDU7XG5leHBvcnRzLkVSX0ZSTV9VTktOT1dOX1RZUEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzQ2O1xuZXhwb3J0cy5FUl9XUk9OR19PQkpFQ1QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTM0NztcbmV4cG9ydHMuRVJfTk9OVVBEQVRFQUJMRV9DT0xVTU4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzNDg7XG5leHBvcnRzLkVSX1ZJRVdfU0VMRUNUX0RFUklWRUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzQ5O1xuZXhwb3J0cy5FUl9WSUVXX1NFTEVDVF9DTEFVU0UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTM1MDtcbmV4cG9ydHMuRVJfVklFV19TRUxFQ1RfVkFSSUFCTEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzNTE7XG5leHBvcnRzLkVSX1ZJRVdfU0VMRUNUX1RNUFRBQkxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzUyO1xuZXhwb3J0cy5FUl9WSUVXX1dST05HX0xJU1QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTM1MztcbmV4cG9ydHMuRVJfV0FSTl9WSUVXX01FUkdFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzNTQ7XG5leHBvcnRzLkVSX1dBUk5fVklFV19XSVRIT1VUX0tFWSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzU1O1xuZXhwb3J0cy5FUl9WSUVXX0lOVkFMSUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTM1NjtcbmV4cG9ydHMuRVJfU1BfTk9fRFJPUF9TUCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzNTc7XG5leHBvcnRzLkVSX1NQX0dPVE9fSU5fSE5ETFIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzU4O1xuZXhwb3J0cy5FUl9UUkdfQUxSRUFEWV9FWElTVFMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTM1OTtcbmV4cG9ydHMuRVJfVFJHX0RPRVNfTk9UX0VYSVNUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzNjA7XG5leHBvcnRzLkVSX1RSR19PTl9WSUVXX09SX1RFTVBfVEFCTEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzYxO1xuZXhwb3J0cy5FUl9UUkdfQ0FOVF9DSEFOR0VfUk9XICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTM2MjtcbmV4cG9ydHMuRVJfVFJHX05PX1NVQ0hfUk9XX0lOX1RSRyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzNjM7XG5leHBvcnRzLkVSX05PX0RFRkFVTFRfRk9SX0ZJRUxEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzY0O1xuZXhwb3J0cy5FUl9ESVZJU0lPTl9CWV9aRVJPICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTM2NTtcbmV4cG9ydHMuRVJfVFJVTkNBVEVEX1dST05HX1ZBTFVFX0ZPUl9GSUVMRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzNjY7XG5leHBvcnRzLkVSX0lMTEVHQUxfVkFMVUVfRk9SX1RZUEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzY3O1xuZXhwb3J0cy5FUl9WSUVXX05PTlVQRF9DSEVDSyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTM2ODtcbmV4cG9ydHMuRVJfVklFV19DSEVDS19GQUlMRUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzNjk7XG5leHBvcnRzLkVSX1BST0NBQ0NFU1NfREVOSUVEX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzcwO1xuZXhwb3J0cy5FUl9SRUxBWV9MT0dfRkFJTCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTM3MTtcbmV4cG9ydHMuRVJfUEFTU1dEX0xFTkdUSCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzNzI7XG5leHBvcnRzLkVSX1VOS05PV05fVEFSR0VUX0JJTkxPRyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzczO1xuZXhwb3J0cy5FUl9JT19FUlJfTE9HX0lOREVYX1JFQUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTM3NDtcbmV4cG9ydHMuRVJfQklOTE9HX1BVUkdFX1BST0hJQklURUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzNzU7XG5leHBvcnRzLkVSX0ZTRUVLX0ZBSUwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzc2O1xuZXhwb3J0cy5FUl9CSU5MT0dfUFVSR0VfRkFUQUxfRVJSICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTM3NztcbmV4cG9ydHMuRVJfTE9HX0lOX1VTRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzNzg7XG5leHBvcnRzLkVSX0xPR19QVVJHRV9VTktOT1dOX0VSUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzc5O1xuZXhwb3J0cy5FUl9SRUxBWV9MT0dfSU5JVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTM4MDtcbmV4cG9ydHMuRVJfTk9fQklOQVJZX0xPR0dJTkcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzODE7XG5leHBvcnRzLkVSX1JFU0VSVkVEX1NZTlRBWCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzgyO1xuZXhwb3J0cy5FUl9XU0FTX0ZBSUxFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTM4MztcbmV4cG9ydHMuRVJfRElGRl9HUk9VUFNfUFJPQyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzODQ7XG5leHBvcnRzLkVSX05PX0dST1VQX0ZPUl9QUk9DICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzg1O1xuZXhwb3J0cy5FUl9PUkRFUl9XSVRIX1BST0MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTM4NjtcbmV4cG9ydHMuRVJfTE9HR0lOR19QUk9ISUJJVF9DSEFOR0lOR19PRiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzODc7XG5leHBvcnRzLkVSX05PX0ZJTEVfTUFQUElORyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzg4O1xuZXhwb3J0cy5FUl9XUk9OR19NQUdJQyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTM4OTtcbmV4cG9ydHMuRVJfUFNfTUFOWV9QQVJBTSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzOTA7XG5leHBvcnRzLkVSX0tFWV9QQVJUXzAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzkxO1xuZXhwb3J0cy5FUl9WSUVXX0NIRUNLU1VNICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTM5MjtcbmV4cG9ydHMuRVJfVklFV19NVUxUSVVQREFURSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzOTM7XG5leHBvcnRzLkVSX1ZJRVdfTk9fSU5TRVJUX0ZJRUxEX0xJU1QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzk0O1xuZXhwb3J0cy5FUl9WSUVXX0RFTEVURV9NRVJHRV9WSUVXICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTM5NTtcbmV4cG9ydHMuRVJfQ0FOTk9UX1VTRVIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzOTY7XG5leHBvcnRzLkVSX1hBRVJfTk9UQSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxMzk3O1xuZXhwb3J0cy5FUl9YQUVSX0lOVkFMICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTM5ODtcbmV4cG9ydHMuRVJfWEFFUl9STUZBSUwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDEzOTk7XG5leHBvcnRzLkVSX1hBRVJfT1VUU0lERSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDAwO1xuZXhwb3J0cy5FUl9YQUVSX1JNRVJSICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQwMTtcbmV4cG9ydHMuRVJfWEFfUkJST0xMQkFDSyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0MDI7XG5leHBvcnRzLkVSX05PTkVYSVNUSU5HX1BST0NfR1JBTlQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDAzO1xuZXhwb3J0cy5FUl9QUk9DX0FVVE9fR1JBTlRfRkFJTCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQwNDtcbmV4cG9ydHMuRVJfUFJPQ19BVVRPX1JFVk9LRV9GQUlMICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0MDU7XG5leHBvcnRzLkVSX0RBVEFfVE9PX0xPTkcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDA2O1xuZXhwb3J0cy5FUl9TUF9CQURfU1FMU1RBVEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQwNztcbmV4cG9ydHMuRVJfU1RBUlRVUCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0MDg7XG5leHBvcnRzLkVSX0xPQURfRlJPTV9GSVhFRF9TSVpFX1JPV1NfVE9fVkFSICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDA5O1xuZXhwb3J0cy5FUl9DQU5UX0NSRUFURV9VU0VSX1dJVEhfR1JBTlQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQxMDtcbmV4cG9ydHMuRVJfV1JPTkdfVkFMVUVfRk9SX1RZUEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0MTE7XG5leHBvcnRzLkVSX1RBQkxFX0RFRl9DSEFOR0VEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDEyO1xuZXhwb3J0cy5FUl9TUF9EVVBfSEFORExFUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQxMztcbmV4cG9ydHMuRVJfU1BfTk9UX1ZBUl9BUkcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0MTQ7XG5leHBvcnRzLkVSX1NQX05PX1JFVFNFVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDE1O1xuZXhwb3J0cy5FUl9DQU5UX0NSRUFURV9HRU9NRVRSWV9PQkpFQ1QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQxNjtcbmV4cG9ydHMuRVJfRkFJTEVEX1JPVVRJTkVfQlJFQUtfQklOTE9HICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0MTc7XG5leHBvcnRzLkVSX0JJTkxPR19VTlNBRkVfUk9VVElORSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDE4O1xuZXhwb3J0cy5FUl9CSU5MT0dfQ1JFQVRFX1JPVVRJTkVfTkVFRF9TVVBFUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQxOTtcbmV4cG9ydHMuRVJfRVhFQ19TVE1UX1dJVEhfT1BFTl9DVVJTT1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0MjA7XG5leHBvcnRzLkVSX1NUTVRfSEFTX05PX09QRU5fQ1VSU09SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDIxO1xuZXhwb3J0cy5FUl9DT01NSVRfTk9UX0FMTE9XRURfSU5fU0ZfT1JfVFJHICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQyMjtcbmV4cG9ydHMuRVJfTk9fREVGQVVMVF9GT1JfVklFV19GSUVMRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0MjM7XG5leHBvcnRzLkVSX1NQX05PX1JFQ1VSU0lPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDI0O1xuZXhwb3J0cy5FUl9UT09fQklHX1NDQUxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQyNTtcbmV4cG9ydHMuRVJfVE9PX0JJR19QUkVDSVNJT04gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0MjY7XG5leHBvcnRzLkVSX01fQklHR0VSX1RIQU5fRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDI3O1xuZXhwb3J0cy5FUl9XUk9OR19MT0NLX09GX1NZU1RFTV9UQUJMRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQyODtcbmV4cG9ydHMuRVJfQ09OTkVDVF9UT19GT1JFSUdOX0RBVEFfU09VUkNFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0Mjk7XG5leHBvcnRzLkVSX1FVRVJZX09OX0ZPUkVJR05fREFUQV9TT1VSQ0UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDMwO1xuZXhwb3J0cy5FUl9GT1JFSUdOX0RBVEFfU09VUkNFX0RPRVNOVF9FWElTVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQzMTtcbmV4cG9ydHMuRVJfRk9SRUlHTl9EQVRBX1NUUklOR19JTlZBTElEX0NBTlRfQ1JFQVRFICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0MzI7XG5leHBvcnRzLkVSX0ZPUkVJR05fREFUQV9TVFJJTkdfSU5WQUxJRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDMzO1xuZXhwb3J0cy5FUl9DQU5UX0NSRUFURV9GRURFUkFURURfVEFCTEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQzNDtcbmV4cG9ydHMuRVJfVFJHX0lOX1dST05HX1NDSEVNQSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0MzU7XG5leHBvcnRzLkVSX1NUQUNLX09WRVJSVU5fTkVFRF9NT1JFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDM2O1xuZXhwb3J0cy5FUl9UT09fTE9OR19CT0RZICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQzNztcbmV4cG9ydHMuRVJfV0FSTl9DQU5UX0RST1BfREVGQVVMVF9LRVlDQUNIRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0Mzg7XG5leHBvcnRzLkVSX1RPT19CSUdfRElTUExBWVdJRFRIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDM5O1xuZXhwb3J0cy5FUl9YQUVSX0RVUElEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ0MDtcbmV4cG9ydHMuRVJfREFURVRJTUVfRlVOQ1RJT05fT1ZFUkZMT1cgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0NDE7XG5leHBvcnRzLkVSX0NBTlRfVVBEQVRFX1VTRURfVEFCTEVfSU5fU0ZfT1JfVFJHICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDQyO1xuZXhwb3J0cy5FUl9WSUVXX1BSRVZFTlRfVVBEQVRFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ0MztcbmV4cG9ydHMuRVJfUFNfTk9fUkVDVVJTSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0NDQ7XG5leHBvcnRzLkVSX1NQX0NBTlRfU0VUX0FVVE9DT01NSVQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDQ1O1xuZXhwb3J0cy5FUl9NQUxGT1JNRURfREVGSU5FUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ0NjtcbmV4cG9ydHMuRVJfVklFV19GUk1fTk9fVVNFUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0NDc7XG5leHBvcnRzLkVSX1ZJRVdfT1RIRVJfVVNFUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDQ4O1xuZXhwb3J0cy5FUl9OT19TVUNIX1VTRVIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ0OTtcbmV4cG9ydHMuRVJfRk9SQklEX1NDSEVNQV9DSEFOR0UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0NTA7XG5leHBvcnRzLkVSX1JPV19JU19SRUZFUkVOQ0VEXzIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDUxO1xuZXhwb3J0cy5FUl9OT19SRUZFUkVOQ0VEX1JPV18yICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ1MjtcbmV4cG9ydHMuRVJfU1BfQkFEX1ZBUl9TSEFET1cgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0NTM7XG5leHBvcnRzLkVSX1RSR19OT19ERUZJTkVSICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDU0O1xuZXhwb3J0cy5FUl9PTERfRklMRV9GT1JNQVQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ1NTtcbmV4cG9ydHMuRVJfU1BfUkVDVVJTSU9OX0xJTUlUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0NTY7XG5leHBvcnRzLkVSX1NQX1BST0NfVEFCTEVfQ09SUlVQVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDU3O1xuZXhwb3J0cy5FUl9TUF9XUk9OR19OQU1FICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ1ODtcbmV4cG9ydHMuRVJfVEFCTEVfTkVFRFNfVVBHUkFERSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0NTk7XG5leHBvcnRzLkVSX1NQX05PX0FHR1JFR0FURSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDYwO1xuZXhwb3J0cy5FUl9NQVhfUFJFUEFSRURfU1RNVF9DT1VOVF9SRUFDSEVEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ2MTtcbmV4cG9ydHMuRVJfVklFV19SRUNVUlNJVkUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0NjI7XG5leHBvcnRzLkVSX05PTl9HUk9VUElOR19GSUVMRF9VU0VEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDYzO1xuZXhwb3J0cy5FUl9UQUJMRV9DQU5UX0hBTkRMRV9TUEtFWVMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ2NDtcbmV4cG9ydHMuRVJfTk9fVFJJR0dFUlNfT05fU1lTVEVNX1NDSEVNQSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0NjU7XG5leHBvcnRzLkVSX1JFTU9WRURfU1BBQ0VTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDY2O1xuZXhwb3J0cy5FUl9BVVRPSU5DX1JFQURfRkFJTEVEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ2NztcbmV4cG9ydHMuRVJfVVNFUk5BTUUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0Njg7XG5leHBvcnRzLkVSX0hPU1ROQU1FICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDY5O1xuZXhwb3J0cy5FUl9XUk9OR19TVFJJTkdfTEVOR1RIICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ3MDtcbmV4cG9ydHMuRVJfTk9OX0lOU0VSVEFCTEVfVEFCTEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0NzE7XG5leHBvcnRzLkVSX0FETUlOX1dST05HX01SR19UQUJMRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDcyO1xuZXhwb3J0cy5FUl9UT09fSElHSF9MRVZFTF9PRl9ORVNUSU5HX0ZPUl9TRUxFQ1QgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ3MztcbmV4cG9ydHMuRVJfTkFNRV9CRUNPTUVTX0VNUFRZICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0NzQ7XG5leHBvcnRzLkVSX0FNQklHVU9VU19GSUVMRF9URVJNICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDc1O1xuZXhwb3J0cy5FUl9GT1JFSUdOX1NFUlZFUl9FWElTVFMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ3NjtcbmV4cG9ydHMuRVJfRk9SRUlHTl9TRVJWRVJfRE9FU05UX0VYSVNUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0Nzc7XG5leHBvcnRzLkVSX0lMTEVHQUxfSEFfQ1JFQVRFX09QVElPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDc4O1xuZXhwb3J0cy5FUl9QQVJUSVRJT05fUkVRVUlSRVNfVkFMVUVTX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ3OTtcbmV4cG9ydHMuRVJfUEFSVElUSU9OX1dST05HX1ZBTFVFU19FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0ODA7XG5leHBvcnRzLkVSX1BBUlRJVElPTl9NQVhWQUxVRV9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDgxO1xuZXhwb3J0cy5FUl9QQVJUSVRJT05fU1VCUEFSVElUSU9OX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ4MjtcbmV4cG9ydHMuRVJfUEFSVElUSU9OX1NVQlBBUlRfTUlYX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0ODM7XG5leHBvcnRzLkVSX1BBUlRJVElPTl9XUk9OR19OT19QQVJUX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDg0O1xuZXhwb3J0cy5FUl9QQVJUSVRJT05fV1JPTkdfTk9fU1VCUEFSVF9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ4NTtcbmV4cG9ydHMuRVJfV1JPTkdfRVhQUl9JTl9QQVJUSVRJT05fRlVOQ19FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0ODY7XG5leHBvcnRzLkVSX05PX0NPTlNUX0VYUFJfSU5fUkFOR0VfT1JfTElTVF9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDg3O1xuZXhwb3J0cy5FUl9GSUVMRF9OT1RfRk9VTkRfUEFSVF9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ4ODtcbmV4cG9ydHMuRVJfTElTVF9PRl9GSUVMRFNfT05MWV9JTl9IQVNIX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0ODk7XG5leHBvcnRzLkVSX0lOQ09OU0lTVEVOVF9QQVJUSVRJT05fSU5GT19FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDkwO1xuZXhwb3J0cy5FUl9QQVJUSVRJT05fRlVOQ19OT1RfQUxMT1dFRF9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ5MTtcbmV4cG9ydHMuRVJfUEFSVElUSU9OU19NVVNUX0JFX0RFRklORURfRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0OTI7XG5leHBvcnRzLkVSX1JBTkdFX05PVF9JTkNSRUFTSU5HX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDkzO1xuZXhwb3J0cy5FUl9JTkNPTlNJU1RFTlRfVFlQRV9PRl9GVU5DVElPTlNfRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ5NDtcbmV4cG9ydHMuRVJfTVVMVElQTEVfREVGX0NPTlNUX0lOX0xJU1RfUEFSVF9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0OTU7XG5leHBvcnRzLkVSX1BBUlRJVElPTl9FTlRSWV9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDk2O1xuZXhwb3J0cy5FUl9NSVhfSEFORExFUl9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTQ5NztcbmV4cG9ydHMuRVJfUEFSVElUSU9OX05PVF9ERUZJTkVEX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE0OTg7XG5leHBvcnRzLkVSX1RPT19NQU5ZX1BBUlRJVElPTlNfRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNDk5O1xuZXhwb3J0cy5FUl9TVUJQQVJUSVRJT05fRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTUwMDtcbmV4cG9ydHMuRVJfQ0FOVF9DUkVBVEVfSEFORExFUl9GSUxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1MDE7XG5leHBvcnRzLkVSX0JMT0JfRklFTERfSU5fUEFSVF9GVU5DX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTAyO1xuZXhwb3J0cy5FUl9VTklRVUVfS0VZX05FRURfQUxMX0ZJRUxEU19JTl9QRiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTUwMztcbmV4cG9ydHMuRVJfTk9fUEFSVFNfRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1MDQ7XG5leHBvcnRzLkVSX1BBUlRJVElPTl9NR01UX09OX05PTlBBUlRJVElPTkVEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTA1O1xuZXhwb3J0cy5FUl9GT1JFSUdOX0tFWV9PTl9QQVJUSVRJT05FRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTUwNjtcbmV4cG9ydHMuRVJfRFJPUF9QQVJUSVRJT05fTk9OX0VYSVNURU5UICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1MDc7XG5leHBvcnRzLkVSX0RST1BfTEFTVF9QQVJUSVRJT04gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTA4O1xuZXhwb3J0cy5FUl9DT0FMRVNDRV9PTkxZX09OX0hBU0hfUEFSVElUSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTUwOTtcbmV4cG9ydHMuRVJfUkVPUkdfSEFTSF9PTkxZX09OX1NBTUVfTk8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1MTA7XG5leHBvcnRzLkVSX1JFT1JHX05PX1BBUkFNX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTExO1xuZXhwb3J0cy5FUl9PTkxZX09OX1JBTkdFX0xJU1RfUEFSVElUSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTUxMjtcbmV4cG9ydHMuRVJfQUREX1BBUlRJVElPTl9TVUJQQVJUX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1MTM7XG5leHBvcnRzLkVSX0FERF9QQVJUSVRJT05fTk9fTkVXX1BBUlRJVElPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTE0O1xuZXhwb3J0cy5FUl9DT0FMRVNDRV9QQVJUSVRJT05fTk9fUEFSVElUSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTUxNTtcbmV4cG9ydHMuRVJfUkVPUkdfUEFSVElUSU9OX05PVF9FWElTVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1MTY7XG5leHBvcnRzLkVSX1NBTUVfTkFNRV9QQVJUSVRJT04gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTE3O1xuZXhwb3J0cy5FUl9OT19CSU5MT0dfRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTUxODtcbmV4cG9ydHMuRVJfQ09OU0VDVVRJVkVfUkVPUkdfUEFSVElUSU9OUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1MTk7XG5leHBvcnRzLkVSX1JFT1JHX09VVFNJREVfUkFOR0UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTIwO1xuZXhwb3J0cy5FUl9QQVJUSVRJT05fRlVOQ1RJT05fRkFJTFVSRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTUyMTtcbmV4cG9ydHMuRVJfUEFSVF9TVEFURV9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1MjI7XG5leHBvcnRzLkVSX0xJTUlURURfUEFSVF9SQU5HRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTIzO1xuZXhwb3J0cy5FUl9QTFVHSU5fSVNfTk9UX0xPQURFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTUyNDtcbmV4cG9ydHMuRVJfV1JPTkdfVkFMVUUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1MjU7XG5leHBvcnRzLkVSX05PX1BBUlRJVElPTl9GT1JfR0lWRU5fVkFMVUUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTI2O1xuZXhwb3J0cy5FUl9GSUxFR1JPVVBfT1BUSU9OX09OTFlfT05DRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTUyNztcbmV4cG9ydHMuRVJfQ1JFQVRFX0ZJTEVHUk9VUF9GQUlMRUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1Mjg7XG5leHBvcnRzLkVSX0RST1BfRklMRUdST1VQX0ZBSUxFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTI5O1xuZXhwb3J0cy5FUl9UQUJMRVNQQUNFX0FVVE9fRVhURU5EX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTUzMDtcbmV4cG9ydHMuRVJfV1JPTkdfU0laRV9OVU1CRVIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1MzE7XG5leHBvcnRzLkVSX1NJWkVfT1ZFUkZMT1dfRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTMyO1xuZXhwb3J0cy5FUl9BTFRFUl9GSUxFR1JPVVBfRkFJTEVEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTUzMztcbmV4cG9ydHMuRVJfQklOTE9HX1JPV19MT0dHSU5HX0ZBSUxFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1MzQ7XG5leHBvcnRzLkVSX0JJTkxPR19ST1dfV1JPTkdfVEFCTEVfREVGICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTM1O1xuZXhwb3J0cy5FUl9CSU5MT0dfUk9XX1JCUl9UT19TQlIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTUzNjtcbmV4cG9ydHMuRVJfRVZFTlRfQUxSRUFEWV9FWElTVFMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1Mzc7XG5leHBvcnRzLkVSX0VWRU5UX1NUT1JFX0ZBSUxFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTM4O1xuZXhwb3J0cy5FUl9FVkVOVF9ET0VTX05PVF9FWElTVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTUzOTtcbmV4cG9ydHMuRVJfRVZFTlRfQ0FOVF9BTFRFUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1NDA7XG5leHBvcnRzLkVSX0VWRU5UX0RST1BfRkFJTEVEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTQxO1xuZXhwb3J0cy5FUl9FVkVOVF9JTlRFUlZBTF9OT1RfUE9TSVRJVkVfT1JfVE9PX0JJRyAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTU0MjtcbmV4cG9ydHMuRVJfRVZFTlRfRU5EU19CRUZPUkVfU1RBUlRTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1NDM7XG5leHBvcnRzLkVSX0VWRU5UX0VYRUNfVElNRV9JTl9USEVfUEFTVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTQ0O1xuZXhwb3J0cy5FUl9FVkVOVF9PUEVOX1RBQkxFX0ZBSUxFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTU0NTtcbmV4cG9ydHMuRVJfRVZFTlRfTkVJVEhFUl9NX0VYUFJfTk9SX01fQVQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1NDY7XG5leHBvcnRzLkVSX0NPTF9DT1VOVF9ET0VTTlRfTUFUQ0hfQ09SUlVQVEVEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTQ3O1xuZXhwb3J0cy5FUl9DQU5OT1RfTE9BRF9GUk9NX1RBQkxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTU0ODtcbmV4cG9ydHMuRVJfRVZFTlRfQ0FOTk9UX0RFTEVURSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1NDk7XG5leHBvcnRzLkVSX0VWRU5UX0NPTVBJTEVfRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTUwO1xuZXhwb3J0cy5FUl9FVkVOVF9TQU1FX05BTUUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTU1MTtcbmV4cG9ydHMuRVJfRVZFTlRfREFUQV9UT09fTE9ORyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1NTI7XG5leHBvcnRzLkVSX0RST1BfSU5ERVhfRksgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTUzO1xuZXhwb3J0cy5FUl9XQVJOX0RFUFJFQ0FURURfU1lOVEFYX1dJVEhfVkVSICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTU1NDtcbmV4cG9ydHMuRVJfQ0FOVF9XUklURV9MT0NLX0xPR19UQUJMRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1NTU7XG5leHBvcnRzLkVSX0NBTlRfTE9DS19MT0dfVEFCTEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTU2O1xuZXhwb3J0cy5FUl9GT1JFSUdOX0RVUExJQ0FURV9LRVkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTU1NztcbmV4cG9ydHMuRVJfQ09MX0NPVU5UX0RPRVNOVF9NQVRDSF9QTEVBU0VfVVBEQVRFICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1NTg7XG5leHBvcnRzLkVSX1RFTVBfVEFCTEVfUFJFVkVOVFNfU1dJVENIX09VVF9PRl9SQlIgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTU5O1xuZXhwb3J0cy5FUl9TVE9SRURfRlVOQ1RJT05fUFJFVkVOVFNfU1dJVENIX0JJTkxPR19GT1JNQVQgICAgICAgICAgICAgICAgICAgID0gMTU2MDtcbmV4cG9ydHMuRVJfTkRCX0NBTlRfU1dJVENIX0JJTkxPR19GT1JNQVQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1NjE7XG5leHBvcnRzLkVSX1BBUlRJVElPTl9OT19URU1QT1JBUlkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTYyO1xuZXhwb3J0cy5FUl9QQVJUSVRJT05fQ09OU1RfRE9NQUlOX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTU2MztcbmV4cG9ydHMuRVJfUEFSVElUSU9OX0ZVTkNUSU9OX0lTX05PVF9BTExPV0VEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1NjQ7XG5leHBvcnRzLkVSX0RETF9MT0dfRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTY1O1xuZXhwb3J0cy5FUl9OVUxMX0lOX1ZBTFVFU19MRVNTX1RIQU4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTU2NjtcbmV4cG9ydHMuRVJfV1JPTkdfUEFSVElUSU9OX05BTUUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1Njc7XG5leHBvcnRzLkVSX0NBTlRfQ0hBTkdFX1RYX0NIQVJBQ1RFUklTVElDUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTY4O1xuZXhwb3J0cy5FUl9EVVBfRU5UUllfQVVUT0lOQ1JFTUVOVF9DQVNFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTU2OTtcbmV4cG9ydHMuRVJfRVZFTlRfTU9ESUZZX1FVRVVFX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1NzA7XG5leHBvcnRzLkVSX0VWRU5UX1NFVF9WQVJfRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTcxO1xuZXhwb3J0cy5FUl9QQVJUSVRJT05fTUVSR0VfRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTU3MjtcbmV4cG9ydHMuRVJfQ0FOVF9BQ1RJVkFURV9MT0cgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1NzM7XG5leHBvcnRzLkVSX1JCUl9OT1RfQVZBSUxBQkxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTc0O1xuZXhwb3J0cy5FUl9CQVNFNjRfREVDT0RFX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTU3NTtcbmV4cG9ydHMuRVJfRVZFTlRfUkVDVVJTSU9OX0ZPUkJJRERFTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1NzY7XG5leHBvcnRzLkVSX0VWRU5UU19EQl9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTc3O1xuZXhwb3J0cy5FUl9PTkxZX0lOVEVHRVJTX0FMTE9XRUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTU3ODtcbmV4cG9ydHMuRVJfVU5TVVBPUlRFRF9MT0dfRU5HSU5FICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1Nzk7XG5leHBvcnRzLkVSX0JBRF9MT0dfU1RBVEVNRU5UICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTgwO1xuZXhwb3J0cy5FUl9DQU5UX1JFTkFNRV9MT0dfVEFCTEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTU4MTtcbmV4cG9ydHMuRVJfV1JPTkdfUEFSQU1DT1VOVF9UT19OQVRJVkVfRkNUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1ODI7XG5leHBvcnRzLkVSX1dST05HX1BBUkFNRVRFUlNfVE9fTkFUSVZFX0ZDVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTgzO1xuZXhwb3J0cy5FUl9XUk9OR19QQVJBTUVURVJTX1RPX1NUT1JFRF9GQ1QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTU4NDtcbmV4cG9ydHMuRVJfTkFUSVZFX0ZDVF9OQU1FX0NPTExJU0lPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1ODU7XG5leHBvcnRzLkVSX0RVUF9FTlRSWV9XSVRIX0tFWV9OQU1FICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTg2O1xuZXhwb3J0cy5FUl9CSU5MT0dfUFVSR0VfRU1GSUxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTU4NztcbmV4cG9ydHMuRVJfRVZFTlRfQ0FOTk9UX0NSRUFURV9JTl9USEVfUEFTVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1ODg7XG5leHBvcnRzLkVSX0VWRU5UX0NBTk5PVF9BTFRFUl9JTl9USEVfUEFTVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTg5O1xuZXhwb3J0cy5FUl9TTEFWRV9JTkNJREVOVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTU5MDtcbmV4cG9ydHMuRVJfTk9fUEFSVElUSU9OX0ZPUl9HSVZFTl9WQUxVRV9TSUxFTlQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1OTE7XG5leHBvcnRzLkVSX0JJTkxPR19VTlNBRkVfU1RBVEVNRU5UICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTkyO1xuZXhwb3J0cy5FUl9TTEFWRV9GQVRBTF9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTU5MztcbmV4cG9ydHMuRVJfU0xBVkVfUkVMQVlfTE9HX1JFQURfRkFJTFVSRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1OTQ7XG5leHBvcnRzLkVSX1NMQVZFX1JFTEFZX0xPR19XUklURV9GQUlMVVJFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTk1O1xuZXhwb3J0cy5FUl9TTEFWRV9DUkVBVEVfRVZFTlRfRkFJTFVSRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTU5NjtcbmV4cG9ydHMuRVJfU0xBVkVfTUFTVEVSX0NPTV9GQUlMVVJFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE1OTc7XG5leHBvcnRzLkVSX0JJTkxPR19MT0dHSU5HX0lNUE9TU0lCTEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNTk4O1xuZXhwb3J0cy5FUl9WSUVXX05PX0NSRUFUSU9OX0NUWCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTU5OTtcbmV4cG9ydHMuRVJfVklFV19JTlZBTElEX0NSRUFUSU9OX0NUWCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2MDA7XG5leHBvcnRzLkVSX1NSX0lOVkFMSURfQ1JFQVRJT05fQ1RYICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjAxO1xuZXhwb3J0cy5FUl9UUkdfQ09SUlVQVEVEX0ZJTEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTYwMjtcbmV4cG9ydHMuRVJfVFJHX05PX0NSRUFUSU9OX0NUWCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2MDM7XG5leHBvcnRzLkVSX1RSR19JTlZBTElEX0NSRUFUSU9OX0NUWCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjA0O1xuZXhwb3J0cy5FUl9FVkVOVF9JTlZBTElEX0NSRUFUSU9OX0NUWCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTYwNTtcbmV4cG9ydHMuRVJfVFJHX0NBTlRfT1BFTl9UQUJMRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2MDY7XG5leHBvcnRzLkVSX0NBTlRfQ1JFQVRFX1NST1VUSU5FICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjA3O1xuZXhwb3J0cy5FUl9ORVZFUl9VU0VEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTYwODtcbmV4cG9ydHMuRVJfTk9fRk9STUFUX0RFU0NSSVBUSU9OX0VWRU5UX0JFRk9SRV9CSU5MT0dfU1RBVEVNRU5UICAgICAgICAgICAgICA9IDE2MDk7XG5leHBvcnRzLkVSX1NMQVZFX0NPUlJVUFRfRVZFTlQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjEwO1xuZXhwb3J0cy5FUl9MT0FEX0RBVEFfSU5WQUxJRF9DT0xVTU4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTYxMTtcbmV4cG9ydHMuRVJfTE9HX1BVUkdFX05PX0ZJTEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2MTI7XG5leHBvcnRzLkVSX1hBX1JCVElNRU9VVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjEzO1xuZXhwb3J0cy5FUl9YQV9SQkRFQURMT0NLICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTYxNDtcbmV4cG9ydHMuRVJfTkVFRF9SRVBSRVBBUkUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2MTU7XG5leHBvcnRzLkVSX0RFTEFZRURfTk9UX1NVUFBPUlRFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjE2O1xuZXhwb3J0cy5XQVJOX05PX01BU1RFUl9JTkZPICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTYxNztcbmV4cG9ydHMuV0FSTl9PUFRJT05fSUdOT1JFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2MTg7XG5leHBvcnRzLldBUk5fUExVR0lOX0RFTEVURV9CVUlMVElOICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjE5O1xuZXhwb3J0cy5XQVJOX1BMVUdJTl9CVVNZICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTYyMDtcbmV4cG9ydHMuRVJfVkFSSUFCTEVfSVNfUkVBRE9OTFkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2MjE7XG5leHBvcnRzLkVSX1dBUk5fRU5HSU5FX1RSQU5TQUNUSU9OX1JPTExCQUNLICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjIyO1xuZXhwb3J0cy5FUl9TTEFWRV9IRUFSVEJFQVRfRkFJTFVSRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTYyMztcbmV4cG9ydHMuRVJfU0xBVkVfSEVBUlRCRUFUX1ZBTFVFX09VVF9PRl9SQU5HRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2MjQ7XG5leHBvcnRzLkVSX05EQl9SRVBMSUNBVElPTl9TQ0hFTUFfRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjI1O1xuZXhwb3J0cy5FUl9DT05GTElDVF9GTl9QQVJTRV9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTYyNjtcbmV4cG9ydHMuRVJfRVhDRVBUSU9OU19XUklURV9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2Mjc7XG5leHBvcnRzLkVSX1RPT19MT05HX1RBQkxFX0NPTU1FTlQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjI4O1xuZXhwb3J0cy5FUl9UT09fTE9OR19GSUVMRF9DT01NRU5UICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTYyOTtcbmV4cG9ydHMuRVJfRlVOQ19JTkVYSVNURU5UX05BTUVfQ09MTElTSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2MzA7XG5leHBvcnRzLkVSX0RBVEFCQVNFX05BTUUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjMxO1xuZXhwb3J0cy5FUl9UQUJMRV9OQU1FICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTYzMjtcbmV4cG9ydHMuRVJfUEFSVElUSU9OX05BTUUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2MzM7XG5leHBvcnRzLkVSX1NVQlBBUlRJVElPTl9OQU1FICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjM0O1xuZXhwb3J0cy5FUl9URU1QT1JBUllfTkFNRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTYzNTtcbmV4cG9ydHMuRVJfUkVOQU1FRF9OQU1FICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2MzY7XG5leHBvcnRzLkVSX1RPT19NQU5ZX0NPTkNVUlJFTlRfVFJYUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjM3O1xuZXhwb3J0cy5XQVJOX05PTl9BU0NJSV9TRVBBUkFUT1JfTk9UX0lNUExFTUVOVEVEICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTYzODtcbmV4cG9ydHMuRVJfREVCVUdfU1lOQ19USU1FT1VUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2Mzk7XG5leHBvcnRzLkVSX0RFQlVHX1NZTkNfSElUX0xJTUlUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjQwO1xuZXhwb3J0cy5FUl9EVVBfU0lHTkFMX1NFVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTY0MTtcbmV4cG9ydHMuRVJfU0lHTkFMX1dBUk4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2NDI7XG5leHBvcnRzLkVSX1NJR05BTF9OT1RfRk9VTkQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjQzO1xuZXhwb3J0cy5FUl9TSUdOQUxfRVhDRVBUSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTY0NDtcbmV4cG9ydHMuRVJfUkVTSUdOQUxfV0lUSE9VVF9BQ1RJVkVfSEFORExFUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2NDU7XG5leHBvcnRzLkVSX1NJR05BTF9CQURfQ09ORElUSU9OX1RZUEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjQ2O1xuZXhwb3J0cy5XQVJOX0NPTkRfSVRFTV9UUlVOQ0FURUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTY0NztcbmV4cG9ydHMuRVJfQ09ORF9JVEVNX1RPT19MT05HICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2NDg7XG5leHBvcnRzLkVSX1VOS05PV05fTE9DQUxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjQ5O1xuZXhwb3J0cy5FUl9TTEFWRV9JR05PUkVfU0VSVkVSX0lEUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTY1MDtcbmV4cG9ydHMuRVJfUVVFUllfQ0FDSEVfRElTQUJMRUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2NTE7XG5leHBvcnRzLkVSX1NBTUVfTkFNRV9QQVJUSVRJT05fRklFTEQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjUyO1xuZXhwb3J0cy5FUl9QQVJUSVRJT05fQ09MVU1OX0xJU1RfRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTY1MztcbmV4cG9ydHMuRVJfV1JPTkdfVFlQRV9DT0xVTU5fVkFMVUVfRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2NTQ7XG5leHBvcnRzLkVSX1RPT19NQU5ZX1BBUlRJVElPTl9GVU5DX0ZJRUxEU19FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjU1O1xuZXhwb3J0cy5FUl9NQVhWQUxVRV9JTl9WQUxVRVNfSU4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTY1NjtcbmV4cG9ydHMuRVJfVE9PX01BTllfVkFMVUVTX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2NTc7XG5leHBvcnRzLkVSX1JPV19TSU5HTEVfUEFSVElUSU9OX0ZJRUxEX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjU4O1xuZXhwb3J0cy5FUl9GSUVMRF9UWVBFX05PVF9BTExPV0VEX0FTX1BBUlRJVElPTl9GSUVMRCAgICAgICAgICAgICAgICAgICAgICAgID0gMTY1OTtcbmV4cG9ydHMuRVJfUEFSVElUSU9OX0ZJRUxEU19UT09fTE9ORyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2NjA7XG5leHBvcnRzLkVSX0JJTkxPR19ST1dfRU5HSU5FX0FORF9TVE1UX0VOR0lORSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjYxO1xuZXhwb3J0cy5FUl9CSU5MT0dfUk9XX01PREVfQU5EX1NUTVRfRU5HSU5FICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTY2MjtcbmV4cG9ydHMuRVJfQklOTE9HX1VOU0FGRV9BTkRfU1RNVF9FTkdJTkUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2NjM7XG5leHBvcnRzLkVSX0JJTkxPR19ST1dfSU5KRUNUSU9OX0FORF9TVE1UX0VOR0lORSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjY0O1xuZXhwb3J0cy5FUl9CSU5MT0dfU1RNVF9NT0RFX0FORF9ST1dfRU5HSU5FICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTY2NTtcbmV4cG9ydHMuRVJfQklOTE9HX1JPV19JTkpFQ1RJT05fQU5EX1NUTVRfTU9ERSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2NjY7XG5leHBvcnRzLkVSX0JJTkxPR19NVUxUSVBMRV9FTkdJTkVTX0FORF9TRUxGX0xPR0dJTkdfRU5HSU5FICAgICAgICAgICAgICAgICAgPSAxNjY3O1xuZXhwb3J0cy5FUl9CSU5MT0dfVU5TQUZFX0xJTUlUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTY2ODtcbmV4cG9ydHMuRVJfQklOTE9HX1VOU0FGRV9JTlNFUlRfREVMQVlFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2Njk7XG5leHBvcnRzLkVSX0JJTkxPR19VTlNBRkVfU1lTVEVNX1RBQkxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjcwO1xuZXhwb3J0cy5FUl9CSU5MT0dfVU5TQUZFX0FVVE9JTkNfQ09MVU1OUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTY3MTtcbmV4cG9ydHMuRVJfQklOTE9HX1VOU0FGRV9VREYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2NzI7XG5leHBvcnRzLkVSX0JJTkxPR19VTlNBRkVfU1lTVEVNX1ZBUklBQkxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjczO1xuZXhwb3J0cy5FUl9CSU5MT0dfVU5TQUZFX1NZU1RFTV9GVU5DVElPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTY3NDtcbmV4cG9ydHMuRVJfQklOTE9HX1VOU0FGRV9OT05UUkFOU19BRlRFUl9UUkFOUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2NzU7XG5leHBvcnRzLkVSX01FU1NBR0VfQU5EX1NUQVRFTUVOVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjc2O1xuZXhwb3J0cy5FUl9TTEFWRV9DT05WRVJTSU9OX0ZBSUxFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTY3NztcbmV4cG9ydHMuRVJfU0xBVkVfQ0FOVF9DUkVBVEVfQ09OVkVSU0lPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2Nzg7XG5leHBvcnRzLkVSX0lOU0lERV9UUkFOU0FDVElPTl9QUkVWRU5UU19TV0lUQ0hfQklOTE9HX0ZPUk1BVCAgICAgICAgICAgICAgICAgPSAxNjc5O1xuZXhwb3J0cy5FUl9QQVRIX0xFTkdUSCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTY4MDtcbmV4cG9ydHMuRVJfV0FSTl9ERVBSRUNBVEVEX1NZTlRBWF9OT19SRVBMQUNFTUVOVCAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2ODE7XG5leHBvcnRzLkVSX1dST05HX05BVElWRV9UQUJMRV9TVFJVQ1RVUkUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjgyO1xuZXhwb3J0cy5FUl9XUk9OR19QRVJGU0NIRU1BX1VTQUdFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTY4MztcbmV4cG9ydHMuRVJfV0FSTl9JX1NfU0tJUFBFRF9UQUJMRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2ODQ7XG5leHBvcnRzLkVSX0lOU0lERV9UUkFOU0FDVElPTl9QUkVWRU5UU19TV0lUQ0hfQklOTE9HX0RJUkVDVCAgICAgICAgICAgICAgICAgPSAxNjg1O1xuZXhwb3J0cy5FUl9TVE9SRURfRlVOQ1RJT05fUFJFVkVOVFNfU1dJVENIX0JJTkxPR19ESVJFQ1QgICAgICAgICAgICAgICAgICAgID0gMTY4NjtcbmV4cG9ydHMuRVJfU1BBVElBTF9NVVNUX0hBVkVfR0VPTV9DT0wgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2ODc7XG5leHBvcnRzLkVSX1RPT19MT05HX0lOREVYX0NPTU1FTlQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjg4O1xuZXhwb3J0cy5FUl9MT0NLX0FCT1JURUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTY4OTtcbmV4cG9ydHMuRVJfREFUQV9PVVRfT0ZfUkFOR0UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2OTA7XG5leHBvcnRzLkVSX1dST05HX1NQVkFSX1RZUEVfSU5fTElNSVQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjkxO1xuZXhwb3J0cy5FUl9CSU5MT0dfVU5TQUZFX01VTFRJUExFX0VOR0lORVNfQU5EX1NFTEZfTE9HR0lOR19FTkdJTkUgICAgICAgICAgID0gMTY5MjtcbmV4cG9ydHMuRVJfQklOTE9HX1VOU0FGRV9NSVhFRF9TVEFURU1FTlQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2OTM7XG5leHBvcnRzLkVSX0lOU0lERV9UUkFOU0FDVElPTl9QUkVWRU5UU19TV0lUQ0hfU1FMX0xPR19CSU4gICAgICAgICAgICAgICAgICAgPSAxNjk0O1xuZXhwb3J0cy5FUl9TVE9SRURfRlVOQ1RJT05fUFJFVkVOVFNfU1dJVENIX1NRTF9MT0dfQklOICAgICAgICAgICAgICAgICAgICAgID0gMTY5NTtcbmV4cG9ydHMuRVJfRkFJTEVEX1JFQURfRlJPTV9QQVJfRklMRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2OTY7XG5leHBvcnRzLkVSX1ZBTFVFU19JU19OT1RfSU5UX1RZUEVfRVJST1IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNjk3O1xuZXhwb3J0cy5FUl9BQ0NFU1NfREVOSUVEX05PX1BBU1NXT1JEX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTY5ODtcbmV4cG9ydHMuRVJfU0VUX1BBU1NXT1JEX0FVVEhfUExVR0lOICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE2OTk7XG5leHBvcnRzLkVSX0dSQU5UX1BMVUdJTl9VU0VSX0VYSVNUUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzAwO1xuZXhwb3J0cy5FUl9UUlVOQ0FURV9JTExFR0FMX0ZLICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTcwMTtcbmV4cG9ydHMuRVJfUExVR0lOX0lTX1BFUk1BTkVOVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3MDI7XG5leHBvcnRzLkVSX1NMQVZFX0hFQVJUQkVBVF9WQUxVRV9PVVRfT0ZfUkFOR0VfTUlOICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzAzO1xuZXhwb3J0cy5FUl9TTEFWRV9IRUFSVEJFQVRfVkFMVUVfT1VUX09GX1JBTkdFX01BWCAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTcwNDtcbmV4cG9ydHMuRVJfU1RNVF9DQUNIRV9GVUxMICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3MDU7XG5leHBvcnRzLkVSX01VTFRJX1VQREFURV9LRVlfQ09ORkxJQ1QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzA2O1xuZXhwb3J0cy5FUl9UQUJMRV9ORUVEU19SRUJVSUxEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTcwNztcbmV4cG9ydHMuV0FSTl9PUFRJT05fQkVMT1dfTElNSVQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3MDg7XG5leHBvcnRzLkVSX0lOREVYX0NPTFVNTl9UT09fTE9ORyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzA5O1xuZXhwb3J0cy5FUl9FUlJPUl9JTl9UUklHR0VSX0JPRFkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTcxMDtcbmV4cG9ydHMuRVJfRVJST1JfSU5fVU5LTk9XTl9UUklHR0VSX0JPRFkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3MTE7XG5leHBvcnRzLkVSX0lOREVYX0NPUlJVUFQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzEyO1xuZXhwb3J0cy5FUl9VTkRPX1JFQ09SRF9UT09fQklHICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTcxMztcbmV4cG9ydHMuRVJfQklOTE9HX1VOU0FGRV9JTlNFUlRfSUdOT1JFX1NFTEVDVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3MTQ7XG5leHBvcnRzLkVSX0JJTkxPR19VTlNBRkVfSU5TRVJUX1NFTEVDVF9VUERBVEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzE1O1xuZXhwb3J0cy5FUl9CSU5MT0dfVU5TQUZFX1JFUExBQ0VfU0VMRUNUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTcxNjtcbmV4cG9ydHMuRVJfQklOTE9HX1VOU0FGRV9DUkVBVEVfSUdOT1JFX1NFTEVDVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3MTc7XG5leHBvcnRzLkVSX0JJTkxPR19VTlNBRkVfQ1JFQVRFX1JFUExBQ0VfU0VMRUNUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzE4O1xuZXhwb3J0cy5FUl9CSU5MT0dfVU5TQUZFX1VQREFURV9JR05PUkUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTcxOTtcbmV4cG9ydHMuRVJfUExVR0lOX05PX1VOSU5TVEFMTCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3MjA7XG5leHBvcnRzLkVSX1BMVUdJTl9OT19JTlNUQUxMICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzIxO1xuZXhwb3J0cy5FUl9CSU5MT0dfVU5TQUZFX1dSSVRFX0FVVE9JTkNfU0VMRUNUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTcyMjtcbmV4cG9ydHMuRVJfQklOTE9HX1VOU0FGRV9DUkVBVEVfU0VMRUNUX0FVVE9JTkMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3MjM7XG5leHBvcnRzLkVSX0JJTkxPR19VTlNBRkVfSU5TRVJUX1RXT19LRVlTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzI0O1xuZXhwb3J0cy5FUl9UQUJMRV9JTl9GS19DSEVDSyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTcyNTtcbmV4cG9ydHMuRVJfVU5TVVBQT1JURURfRU5HSU5FICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3MjY7XG5leHBvcnRzLkVSX0JJTkxPR19VTlNBRkVfQVVUT0lOQ19OT1RfRklSU1QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzI3O1xuZXhwb3J0cy5FUl9DQU5OT1RfTE9BRF9GUk9NX1RBQkxFX1YyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTcyODtcbmV4cG9ydHMuRVJfTUFTVEVSX0RFTEFZX1ZBTFVFX09VVF9PRl9SQU5HRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3Mjk7XG5leHBvcnRzLkVSX09OTFlfRkRfQU5EX1JCUl9FVkVOVFNfQUxMT1dFRF9JTl9CSU5MT0dfU1RBVEVNRU5UICAgICAgICAgICAgICAgPSAxNzMwO1xuZXhwb3J0cy5FUl9QQVJUSVRJT05fRVhDSEFOR0VfRElGRkVSRU5UX09QVElPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTczMTtcbmV4cG9ydHMuRVJfUEFSVElUSU9OX0VYQ0hBTkdFX1BBUlRfVEFCTEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3MzI7XG5leHBvcnRzLkVSX1BBUlRJVElPTl9FWENIQU5HRV9URU1QX1RBQkxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzMzO1xuZXhwb3J0cy5FUl9QQVJUSVRJT05fSU5TVEVBRF9PRl9TVUJQQVJUSVRJT04gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTczNDtcbmV4cG9ydHMuRVJfVU5LTk9XTl9QQVJUSVRJT04gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3MzU7XG5leHBvcnRzLkVSX1RBQkxFU19ESUZGRVJFTlRfTUVUQURBVEEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzM2O1xuZXhwb3J0cy5FUl9ST1dfRE9FU19OT1RfTUFUQ0hfUEFSVElUSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTczNztcbmV4cG9ydHMuRVJfQklOTE9HX0NBQ0hFX1NJWkVfR1JFQVRFUl9USEFOX01BWCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3Mzg7XG5leHBvcnRzLkVSX1dBUk5fSU5ERVhfTk9UX0FQUExJQ0FCTEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzM5O1xuZXhwb3J0cy5FUl9QQVJUSVRJT05fRVhDSEFOR0VfRk9SRUlHTl9LRVkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTc0MDtcbmV4cG9ydHMuRVJfTk9fU1VDSF9LRVlfVkFMVUUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3NDE7XG5leHBvcnRzLkVSX1JQTF9JTkZPX0RBVEFfVE9PX0xPTkcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzQyO1xuZXhwb3J0cy5FUl9ORVRXT1JLX1JFQURfRVZFTlRfQ0hFQ0tTVU1fRkFJTFVSRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTc0MztcbmV4cG9ydHMuRVJfQklOTE9HX1JFQURfRVZFTlRfQ0hFQ0tTVU1fRkFJTFVSRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3NDQ7XG5leHBvcnRzLkVSX0JJTkxPR19TVE1UX0NBQ0hFX1NJWkVfR1JFQVRFUl9USEFOX01BWCAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzQ1O1xuZXhwb3J0cy5FUl9DQU5UX1VQREFURV9UQUJMRV9JTl9DUkVBVEVfVEFCTEVfU0VMRUNUICAgICAgICAgICAgICAgICAgICAgICAgID0gMTc0NjtcbmV4cG9ydHMuRVJfUEFSVElUSU9OX0NMQVVTRV9PTl9OT05QQVJUSVRJT05FRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3NDc7XG5leHBvcnRzLkVSX1JPV19ET0VTX05PVF9NQVRDSF9HSVZFTl9QQVJUSVRJT05fU0VUICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzQ4O1xuZXhwb3J0cy5FUl9OT19TVUNIX1BBUlRJVElPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTc0OTtcbmV4cG9ydHMuRVJfQ0hBTkdFX1JQTF9JTkZPX1JFUE9TSVRPUllfRkFJTFVSRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3NTA7XG5leHBvcnRzLkVSX1dBUk5JTkdfTk9UX0NPTVBMRVRFX1JPTExCQUNLX1dJVEhfQ1JFQVRFRF9URU1QX1RBQkxFICAgICAgICAgICAgPSAxNzUxO1xuZXhwb3J0cy5FUl9XQVJOSU5HX05PVF9DT01QTEVURV9ST0xMQkFDS19XSVRIX0RST1BQRURfVEVNUF9UQUJMRSAgICAgICAgICAgID0gMTc1MjtcbmV4cG9ydHMuRVJfTVRTX0ZFQVRVUkVfSVNfTk9UX1NVUFBPUlRFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3NTM7XG5leHBvcnRzLkVSX01UU19VUERBVEVEX0RCU19HUkVBVEVSX01BWCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzU0O1xuZXhwb3J0cy5FUl9NVFNfQ0FOVF9QQVJBTExFTCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTc1NTtcbmV4cG9ydHMuRVJfTVRTX0lOQ09OU0lTVEVOVF9EQVRBICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3NTY7XG5leHBvcnRzLkVSX0ZVTExURVhUX05PVF9TVVBQT1JURURfV0lUSF9QQVJUSVRJT05JTkcgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzU3O1xuZXhwb3J0cy5FUl9EQV9JTlZBTElEX0NPTkRJVElPTl9OVU1CRVIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTc1ODtcbmV4cG9ydHMuRVJfSU5TRUNVUkVfUExBSU5fVEVYVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3NTk7XG5leHBvcnRzLkVSX0lOU0VDVVJFX0NIQU5HRV9NQVNURVIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzYwO1xuZXhwb3J0cy5FUl9GT1JFSUdOX0RVUExJQ0FURV9LRVlfV0lUSF9DSElMRF9JTkZPICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTc2MTtcbmV4cG9ydHMuRVJfRk9SRUlHTl9EVVBMSUNBVEVfS0VZX1dJVEhPVVRfQ0hJTERfSU5GTyAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3NjI7XG5leHBvcnRzLkVSX1NRTFRIUkVBRF9XSVRIX1NFQ1VSRV9TTEFWRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzYzO1xuZXhwb3J0cy5FUl9UQUJMRV9IQVNfTk9fRlQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTc2NDtcbmV4cG9ydHMuRVJfVkFSSUFCTEVfTk9UX1NFVFRBQkxFX0lOX1NGX09SX1RSSUdHRVIgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3NjU7XG5leHBvcnRzLkVSX1ZBUklBQkxFX05PVF9TRVRUQUJMRV9JTl9UUkFOU0FDVElPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzY2O1xuZXhwb3J0cy5FUl9HVElEX05FWFRfSVNfTk9UX0lOX0dUSURfTkVYVF9MSVNUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTc2NztcbmV4cG9ydHMuRVJfQ0FOVF9DSEFOR0VfR1RJRF9ORVhUX0lOX1RSQU5TQUNUSU9OX1dIRU5fR1RJRF9ORVhUX0xJU1RfSVNfTlVMTCA9IDE3Njg7XG5leHBvcnRzLkVSX1NFVF9TVEFURU1FTlRfQ0FOTk9UX0lOVk9LRV9GVU5DVElPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzY5O1xuZXhwb3J0cy5FUl9HVElEX05FWFRfQ0FOVF9CRV9BVVRPTUFUSUNfSUZfR1RJRF9ORVhUX0xJU1RfSVNfTk9OX05VTEwgICAgICAgID0gMTc3MDtcbmV4cG9ydHMuRVJfU0tJUFBJTkdfTE9HR0VEX1RSQU5TQUNUSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3NzE7XG5leHBvcnRzLkVSX01BTEZPUk1FRF9HVElEX1NFVF9TUEVDSUZJQ0FUSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzcyO1xuZXhwb3J0cy5FUl9NQUxGT1JNRURfR1RJRF9TRVRfRU5DT0RJTkcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTc3MztcbmV4cG9ydHMuRVJfTUFMRk9STUVEX0dUSURfU1BFQ0lGSUNBVElPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3NzQ7XG5leHBvcnRzLkVSX0dOT19FWEhBVVNURUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzc1O1xuZXhwb3J0cy5FUl9CQURfU0xBVkVfQVVUT19QT1NJVElPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTc3NjtcbmV4cG9ydHMuRVJfQVVUT19QT1NJVElPTl9SRVFVSVJFU19HVElEX01PREVfT04gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3Nzc7XG5leHBvcnRzLkVSX0NBTlRfRE9fSU1QTElDSVRfQ09NTUlUX0lOX1RSWF9XSEVOX0dUSURfTkVYVF9JU19TRVQgICAgICAgICAgICAgPSAxNzc4O1xuZXhwb3J0cy5FUl9HVElEX01PREVfMl9PUl8zX1JFUVVJUkVTX0VORk9SQ0VfR1RJRF9DT05TSVNURU5DWV9PTiAgICAgICAgICAgID0gMTc3OTtcbmV4cG9ydHMuRVJfR1RJRF9NT0RFX1JFUVVJUkVTX0JJTkxPRyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3ODA7XG5leHBvcnRzLkVSX0NBTlRfU0VUX0dUSURfTkVYVF9UT19HVElEX1dIRU5fR1RJRF9NT0RFX0lTX09GRiAgICAgICAgICAgICAgICAgPSAxNzgxO1xuZXhwb3J0cy5FUl9DQU5UX1NFVF9HVElEX05FWFRfVE9fQU5PTllNT1VTX1dIRU5fR1RJRF9NT0RFX0lTX09OICAgICAgICAgICAgID0gMTc4MjtcbmV4cG9ydHMuRVJfQ0FOVF9TRVRfR1RJRF9ORVhUX0xJU1RfVE9fTk9OX05VTExfV0hFTl9HVElEX01PREVfSVNfT0ZGICAgICAgICA9IDE3ODM7XG5leHBvcnRzLkVSX0ZPVU5EX0dUSURfRVZFTlRfV0hFTl9HVElEX01PREVfSVNfT0ZGICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzg0O1xuZXhwb3J0cy5FUl9HVElEX1VOU0FGRV9OT05fVFJBTlNBQ1RJT05BTF9UQUJMRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTc4NTtcbmV4cG9ydHMuRVJfR1RJRF9VTlNBRkVfQ1JFQVRFX1NFTEVDVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3ODY7XG5leHBvcnRzLkVSX0dUSURfVU5TQUZFX0NSRUFURV9EUk9QX1RFTVBPUkFSWV9UQUJMRV9JTl9UUkFOU0FDVElPTiAgICAgICAgICAgPSAxNzg3O1xuZXhwb3J0cy5FUl9HVElEX01PREVfQ0FOX09OTFlfQ0hBTkdFX09ORV9TVEVQX0FUX0FfVElNRSAgICAgICAgICAgICAgICAgICAgID0gMTc4ODtcbmV4cG9ydHMuRVJfTUFTVEVSX0hBU19QVVJHRURfUkVRVUlSRURfR1RJRFMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3ODk7XG5leHBvcnRzLkVSX0NBTlRfU0VUX0dUSURfTkVYVF9XSEVOX09XTklOR19HVElEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzkwO1xuZXhwb3J0cy5FUl9VTktOT1dOX0VYUExBSU5fRk9STUFUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTc5MTtcbmV4cG9ydHMuRVJfQ0FOVF9FWEVDVVRFX0lOX1JFQURfT05MWV9UUkFOU0FDVElPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3OTI7XG5leHBvcnRzLkVSX1RPT19MT05HX1RBQkxFX1BBUlRJVElPTl9DT01NRU5UICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzkzO1xuZXhwb3J0cy5FUl9TTEFWRV9DT05GSUdVUkFUSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTc5NDtcbmV4cG9ydHMuRVJfSU5OT0RCX0ZUX0xJTUlUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3OTU7XG5leHBvcnRzLkVSX0lOTk9EQl9OT19GVF9URU1QX1RBQkxFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzk2O1xuZXhwb3J0cy5FUl9JTk5PREJfRlRfV1JPTkdfRE9DSURfQ09MVU1OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTc5NztcbmV4cG9ydHMuRVJfSU5OT0RCX0ZUX1dST05HX0RPQ0lEX0lOREVYICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE3OTg7XG5leHBvcnRzLkVSX0lOTk9EQl9PTkxJTkVfTE9HX1RPT19CSUcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxNzk5O1xuZXhwb3J0cy5FUl9VTktOT1dOX0FMVEVSX0FMR09SSVRITSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTgwMDtcbmV4cG9ydHMuRVJfVU5LTk9XTl9BTFRFUl9MT0NLICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4MDE7XG5leHBvcnRzLkVSX01UU19DSEFOR0VfTUFTVEVSX0NBTlRfUlVOX1dJVEhfR0FQUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODAyO1xuZXhwb3J0cy5FUl9NVFNfUkVDT1ZFUllfRkFJTFVSRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTgwMztcbmV4cG9ydHMuRVJfTVRTX1JFU0VUX1dPUktFUlMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4MDQ7XG5leHBvcnRzLkVSX0NPTF9DT1VOVF9ET0VTTlRfTUFUQ0hfQ09SUlVQVEVEX1YyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODA1O1xuZXhwb3J0cy5FUl9TTEFWRV9TSUxFTlRfUkVUUllfVFJBTlNBQ1RJT04gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTgwNjtcbmV4cG9ydHMuRVJfRElTQ0FSRF9GS19DSEVDS1NfUlVOTklORyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4MDc7XG5leHBvcnRzLkVSX1RBQkxFX1NDSEVNQV9NSVNNQVRDSCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODA4O1xuZXhwb3J0cy5FUl9UQUJMRV9JTl9TWVNURU1fVEFCTEVTUEFDRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTgwOTtcbmV4cG9ydHMuRVJfSU9fUkVBRF9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4MTA7XG5leHBvcnRzLkVSX0lPX1dSSVRFX0VSUk9SICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODExO1xuZXhwb3J0cy5FUl9UQUJMRVNQQUNFX01JU1NJTkcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTgxMjtcbmV4cG9ydHMuRVJfVEFCTEVTUEFDRV9FWElTVFMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4MTM7XG5leHBvcnRzLkVSX1RBQkxFU1BBQ0VfRElTQ0FSREVEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODE0O1xuZXhwb3J0cy5FUl9JTlRFUk5BTF9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTgxNTtcbmV4cG9ydHMuRVJfSU5OT0RCX0lNUE9SVF9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4MTY7XG5leHBvcnRzLkVSX0lOTk9EQl9JTkRFWF9DT1JSVVBUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODE3O1xuZXhwb3J0cy5FUl9JTlZBTElEX1lFQVJfQ09MVU1OX0xFTkdUSCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTgxODtcbmV4cG9ydHMuRVJfTk9UX1ZBTElEX1BBU1NXT1JEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4MTk7XG5leHBvcnRzLkVSX01VU1RfQ0hBTkdFX1BBU1NXT1JEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODIwO1xuZXhwb3J0cy5FUl9GS19OT19JTkRFWF9DSElMRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTgyMTtcbmV4cG9ydHMuRVJfRktfTk9fSU5ERVhfUEFSRU5UICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4MjI7XG5leHBvcnRzLkVSX0ZLX0ZBSUxfQUREX1NZU1RFTSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODIzO1xuZXhwb3J0cy5FUl9GS19DQU5OT1RfT1BFTl9QQVJFTlQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTgyNDtcbmV4cG9ydHMuRVJfRktfSU5DT1JSRUNUX09QVElPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4MjU7XG5leHBvcnRzLkVSX0ZLX0RVUF9OQU1FICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODI2O1xuZXhwb3J0cy5FUl9QQVNTV09SRF9GT1JNQVQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTgyNztcbmV4cG9ydHMuRVJfRktfQ09MVU1OX0NBTk5PVF9EUk9QICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4Mjg7XG5leHBvcnRzLkVSX0ZLX0NPTFVNTl9DQU5OT1RfRFJPUF9DSElMRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODI5O1xuZXhwb3J0cy5FUl9GS19DT0xVTU5fTk9UX05VTEwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTgzMDtcbmV4cG9ydHMuRVJfRFVQX0lOREVYICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4MzE7XG5leHBvcnRzLkVSX0ZLX0NPTFVNTl9DQU5OT1RfQ0hBTkdFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODMyO1xuZXhwb3J0cy5FUl9GS19DT0xVTU5fQ0FOTk9UX0NIQU5HRV9DSElMRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTgzMztcbmV4cG9ydHMuRVJfRktfQ0FOTk9UX0RFTEVURV9QQVJFTlQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4MzQ7XG5leHBvcnRzLkVSX01BTEZPUk1FRF9QQUNLRVQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODM1O1xuZXhwb3J0cy5FUl9SRUFEX09OTFlfTU9ERSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTgzNjtcbmV4cG9ydHMuRVJfR1RJRF9ORVhUX1RZUEVfVU5ERUZJTkVEX0dST1VQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4Mzc7XG5leHBvcnRzLkVSX1ZBUklBQkxFX05PVF9TRVRUQUJMRV9JTl9TUCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODM4O1xuZXhwb3J0cy5FUl9DQU5UX1NFVF9HVElEX1BVUkdFRF9XSEVOX0dUSURfTU9ERV9JU19PRkYgICAgICAgICAgICAgICAgICAgICAgID0gMTgzOTtcbmV4cG9ydHMuRVJfQ0FOVF9TRVRfR1RJRF9QVVJHRURfV0hFTl9HVElEX0VYRUNVVEVEX0lTX05PVF9FTVBUWSAgICAgICAgICAgICA9IDE4NDA7XG5leHBvcnRzLkVSX0NBTlRfU0VUX0dUSURfUFVSR0VEX1dIRU5fT1dORURfR1RJRFNfSVNfTk9UX0VNUFRZICAgICAgICAgICAgICAgPSAxODQxO1xuZXhwb3J0cy5FUl9HVElEX1BVUkdFRF9XQVNfQ0hBTkdFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTg0MjtcbmV4cG9ydHMuRVJfR1RJRF9FWEVDVVRFRF9XQVNfQ0hBTkdFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4NDM7XG5leHBvcnRzLkVSX0JJTkxPR19TVE1UX01PREVfQU5EX05PX1JFUExfVEFCTEVTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODQ0O1xuZXhwb3J0cy5FUl9BTFRFUl9PUEVSQVRJT05fTk9UX1NVUFBPUlRFRCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTg0NTtcbmV4cG9ydHMuRVJfQUxURVJfT1BFUkFUSU9OX05PVF9TVVBQT1JURURfUkVBU09OICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4NDY7XG5leHBvcnRzLkVSX0FMVEVSX09QRVJBVElPTl9OT1RfU1VQUE9SVEVEX1JFQVNPTl9DT1BZICAgICAgICAgICAgICAgICAgICAgICAgPSAxODQ3O1xuZXhwb3J0cy5FUl9BTFRFUl9PUEVSQVRJT05fTk9UX1NVUFBPUlRFRF9SRUFTT05fUEFSVElUSU9OICAgICAgICAgICAgICAgICAgID0gMTg0ODtcbmV4cG9ydHMuRVJfQUxURVJfT1BFUkFUSU9OX05PVF9TVVBQT1JURURfUkVBU09OX0ZLX1JFTkFNRSAgICAgICAgICAgICAgICAgICA9IDE4NDk7XG5leHBvcnRzLkVSX0FMVEVSX09QRVJBVElPTl9OT1RfU1VQUE9SVEVEX1JFQVNPTl9DT0xVTU5fVFlQRSAgICAgICAgICAgICAgICAgPSAxODUwO1xuZXhwb3J0cy5FUl9BTFRFUl9PUEVSQVRJT05fTk9UX1NVUFBPUlRFRF9SRUFTT05fRktfQ0hFQ0sgICAgICAgICAgICAgICAgICAgID0gMTg1MTtcbmV4cG9ydHMuRVJfQUxURVJfT1BFUkFUSU9OX05PVF9TVVBQT1JURURfUkVBU09OX0lHTk9SRSAgICAgICAgICAgICAgICAgICAgICA9IDE4NTI7XG5leHBvcnRzLkVSX0FMVEVSX09QRVJBVElPTl9OT1RfU1VQUE9SVEVEX1JFQVNPTl9OT1BLICAgICAgICAgICAgICAgICAgICAgICAgPSAxODUzO1xuZXhwb3J0cy5FUl9BTFRFUl9PUEVSQVRJT05fTk9UX1NVUFBPUlRFRF9SRUFTT05fQVVUT0lOQyAgICAgICAgICAgICAgICAgICAgID0gMTg1NDtcbmV4cG9ydHMuRVJfQUxURVJfT1BFUkFUSU9OX05PVF9TVVBQT1JURURfUkVBU09OX0hJRERFTl9GVFMgICAgICAgICAgICAgICAgICA9IDE4NTU7XG5leHBvcnRzLkVSX0FMVEVSX09QRVJBVElPTl9OT1RfU1VQUE9SVEVEX1JFQVNPTl9DSEFOR0VfRlRTICAgICAgICAgICAgICAgICAgPSAxODU2O1xuZXhwb3J0cy5FUl9BTFRFUl9PUEVSQVRJT05fTk9UX1NVUFBPUlRFRF9SRUFTT05fRlRTICAgICAgICAgICAgICAgICAgICAgICAgID0gMTg1NztcbmV4cG9ydHMuRVJfU1FMX1NMQVZFX1NLSVBfQ09VTlRFUl9OT1RfU0VUVEFCTEVfSU5fR1RJRF9NT0RFICAgICAgICAgICAgICAgICA9IDE4NTg7XG5leHBvcnRzLkVSX0RVUF9VTktOT1dOX0lOX0lOREVYICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODU5O1xuZXhwb3J0cy5FUl9JREVOVF9DQVVTRVNfVE9PX0xPTkdfUEFUSCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTg2MDtcbmV4cG9ydHMuRVJfQUxURVJfT1BFUkFUSU9OX05PVF9TVVBQT1JURURfUkVBU09OX05PVF9OVUxMICAgICAgICAgICAgICAgICAgICA9IDE4NjE7XG5leHBvcnRzLkVSX01VU1RfQ0hBTkdFX1BBU1NXT1JEX0xPR0lOICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODYyO1xuZXhwb3J0cy5FUl9ST1dfSU5fV1JPTkdfUEFSVElUSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTg2MztcbmV4cG9ydHMuRVJfTVRTX0VWRU5UX0JJR0dFUl9QRU5ESU5HX0pPQlNfU0laRV9NQVggICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4NjQ7XG5leHBvcnRzLkVSX0lOTk9EQl9OT19GVF9VU0VTX1BBUlNFUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODY1O1xuZXhwb3J0cy5FUl9CSU5MT0dfTE9HSUNBTF9DT1JSVVBUSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTg2NjtcbmV4cG9ydHMuRVJfV0FSTl9QVVJHRV9MT0dfSU5fVVNFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4Njc7XG5leHBvcnRzLkVSX1dBUk5fUFVSR0VfTE9HX0lTX0FDVElWRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODY4O1xuZXhwb3J0cy5FUl9BVVRPX0lOQ1JFTUVOVF9DT05GTElDVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTg2OTtcbmV4cG9ydHMuV0FSTl9PTl9CTE9DS0hPTEVfSU5fUkJSICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4NzA7XG5leHBvcnRzLkVSX1NMQVZFX01JX0lOSVRfUkVQT1NJVE9SWSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODcxO1xuZXhwb3J0cy5FUl9TTEFWRV9STElfSU5JVF9SRVBPU0lUT1JZICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTg3MjtcbmV4cG9ydHMuRVJfQUNDRVNTX0RFTklFRF9DSEFOR0VfVVNFUl9FUlJPUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4NzM7XG5leHBvcnRzLkVSX0lOTk9EQl9SRUFEX09OTFkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODc0O1xuZXhwb3J0cy5FUl9TVE9QX1NMQVZFX1NRTF9USFJFQURfVElNRU9VVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTg3NTtcbmV4cG9ydHMuRVJfU1RPUF9TTEFWRV9JT19USFJFQURfVElNRU9VVCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4NzY7XG5leHBvcnRzLkVSX1RBQkxFX0NPUlJVUFQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODc3O1xuZXhwb3J0cy5FUl9URU1QX0ZJTEVfV1JJVEVfRkFJTFVSRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTg3ODtcbmV4cG9ydHMuRVJfSU5OT0RCX0ZUX0FVWF9OT1RfSEVYX0lEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4Nzk7XG5leHBvcnRzLkVSX09MRF9URU1QT1JBTFNfVVBHUkFERUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxODgwO1xuZXhwb3J0cy5FUl9JTk5PREJfRk9SQ0VEX1JFQ09WRVJZICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTg4MTtcbmV4cG9ydHMuRVJfQUVTX0lOVkFMSURfSVYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDE4ODI7XG5cbi8vIExvb2t1cC1ieS1udW1iZXIgdGFibGVcbmV4cG9ydHNbMV0gICAgPSAnRUVfQ0FOVENSRUFURUZJTEUnO1xuZXhwb3J0c1syXSAgICA9ICdFRV9SRUFEJztcbmV4cG9ydHNbM10gICAgPSAnRUVfV1JJVEUnO1xuZXhwb3J0c1s0XSAgICA9ICdFRV9CQURDTE9TRSc7XG5leHBvcnRzWzVdICAgID0gJ0VFX09VVE9GTUVNT1JZJztcbmV4cG9ydHNbNl0gICAgPSAnRUVfREVMRVRFJztcbmV4cG9ydHNbN10gICAgPSAnRUVfTElOSyc7XG5leHBvcnRzWzldICAgID0gJ0VFX0VPRkVSUic7XG5leHBvcnRzWzEwXSAgID0gJ0VFX0NBTlRMT0NLJztcbmV4cG9ydHNbMTFdICAgPSAnRUVfQ0FOVFVOTE9DSyc7XG5leHBvcnRzWzEyXSAgID0gJ0VFX0RJUic7XG5leHBvcnRzWzEzXSAgID0gJ0VFX1NUQVQnO1xuZXhwb3J0c1sxNF0gICA9ICdFRV9DQU5UX0NIU0laRSc7XG5leHBvcnRzWzE1XSAgID0gJ0VFX0NBTlRfT1BFTl9TVFJFQU0nO1xuZXhwb3J0c1sxNl0gICA9ICdFRV9HRVRXRCc7XG5leHBvcnRzWzE3XSAgID0gJ0VFX1NFVFdEJztcbmV4cG9ydHNbMThdICAgPSAnRUVfTElOS19XQVJOSU5HJztcbmV4cG9ydHNbMTldICAgPSAnRUVfT1BFTl9XQVJOSU5HJztcbmV4cG9ydHNbMjBdICAgPSAnRUVfRElTS19GVUxMJztcbmV4cG9ydHNbMjFdICAgPSAnRUVfQ0FOVF9NS0RJUic7XG5leHBvcnRzWzIyXSAgID0gJ0VFX1VOS05PV05fQ0hBUlNFVCc7XG5leHBvcnRzWzIzXSAgID0gJ0VFX09VVF9PRl9GSUxFUkVTT1VSQ0VTJztcbmV4cG9ydHNbMjRdICAgPSAnRUVfQ0FOVF9SRUFETElOSyc7XG5leHBvcnRzWzI1XSAgID0gJ0VFX0NBTlRfU1lNTElOSyc7XG5leHBvcnRzWzI2XSAgID0gJ0VFX1JFQUxQQVRIJztcbmV4cG9ydHNbMjddICAgPSAnRUVfU1lOQyc7XG5leHBvcnRzWzI4XSAgID0gJ0VFX1VOS05PV05fQ09MTEFUSU9OJztcbmV4cG9ydHNbMjldICAgPSAnRUVfRklMRU5PVEZPVU5EJztcbmV4cG9ydHNbMzBdICAgPSAnRUVfRklMRV9OT1RfQ0xPU0VEJztcbmV4cG9ydHNbMzFdICAgPSAnRUVfQ0hBTkdFX09XTkVSU0hJUCc7XG5leHBvcnRzWzMyXSAgID0gJ0VFX0NIQU5HRV9QRVJNSVNTSU9OUyc7XG5leHBvcnRzWzMzXSAgID0gJ0VFX0NBTlRfU0VFSyc7XG5leHBvcnRzWzEyMF0gID0gJ0hBX0VSUl9LRVlfTk9UX0ZPVU5EJztcbmV4cG9ydHNbMTIxXSAgPSAnSEFfRVJSX0ZPVU5EX0RVUFBfS0VZJztcbmV4cG9ydHNbMTIyXSAgPSAnSEFfRVJSX0lOVEVSTkFMX0VSUk9SJztcbmV4cG9ydHNbMTIzXSAgPSAnSEFfRVJSX1JFQ09SRF9DSEFOR0VEJztcbmV4cG9ydHNbMTI0XSAgPSAnSEFfRVJSX1dST05HX0lOREVYJztcbmV4cG9ydHNbMTI2XSAgPSAnSEFfRVJSX0NSQVNIRUQnO1xuZXhwb3J0c1sxMjddICA9ICdIQV9FUlJfV1JPTkdfSU5fUkVDT1JEJztcbmV4cG9ydHNbMTI4XSAgPSAnSEFfRVJSX09VVF9PRl9NRU0nO1xuZXhwb3J0c1sxMzBdICA9ICdIQV9FUlJfTk9UX0FfVEFCTEUnO1xuZXhwb3J0c1sxMzFdICA9ICdIQV9FUlJfV1JPTkdfQ09NTUFORCc7XG5leHBvcnRzWzEzMl0gID0gJ0hBX0VSUl9PTERfRklMRSc7XG5leHBvcnRzWzEzM10gID0gJ0hBX0VSUl9OT19BQ1RJVkVfUkVDT1JEJztcbmV4cG9ydHNbMTM0XSAgPSAnSEFfRVJSX1JFQ09SRF9ERUxFVEVEJztcbmV4cG9ydHNbMTM1XSAgPSAnSEFfRVJSX1JFQ09SRF9GSUxFX0ZVTEwnO1xuZXhwb3J0c1sxMzZdICA9ICdIQV9FUlJfSU5ERVhfRklMRV9GVUxMJztcbmV4cG9ydHNbMTM3XSAgPSAnSEFfRVJSX0VORF9PRl9GSUxFJztcbmV4cG9ydHNbMTM4XSAgPSAnSEFfRVJSX1VOU1VQUE9SVEVEJztcbmV4cG9ydHNbMTM5XSAgPSAnSEFfRVJSX1RPX0JJR19ST1cnO1xuZXhwb3J0c1sxNDBdICA9ICdIQV9XUk9OR19DUkVBVEVfT1BUSU9OJztcbmV4cG9ydHNbMTQxXSAgPSAnSEFfRVJSX0ZPVU5EX0RVUFBfVU5JUVVFJztcbmV4cG9ydHNbMTQyXSAgPSAnSEFfRVJSX1VOS05PV05fQ0hBUlNFVCc7XG5leHBvcnRzWzE0M10gID0gJ0hBX0VSUl9XUk9OR19NUkdfVEFCTEVfREVGJztcbmV4cG9ydHNbMTQ0XSAgPSAnSEFfRVJSX0NSQVNIRURfT05fUkVQQUlSJztcbmV4cG9ydHNbMTQ1XSAgPSAnSEFfRVJSX0NSQVNIRURfT05fVVNBR0UnO1xuZXhwb3J0c1sxNDZdICA9ICdIQV9FUlJfTE9DS19XQUlUX1RJTUVPVVQnO1xuZXhwb3J0c1sxNDddICA9ICdIQV9FUlJfTE9DS19UQUJMRV9GVUxMJztcbmV4cG9ydHNbMTQ4XSAgPSAnSEFfRVJSX1JFQURfT05MWV9UUkFOU0FDVElPTic7XG5leHBvcnRzWzE0OV0gID0gJ0hBX0VSUl9MT0NLX0RFQURMT0NLJztcbmV4cG9ydHNbMTUwXSAgPSAnSEFfRVJSX0NBTk5PVF9BRERfRk9SRUlHTic7XG5leHBvcnRzWzE1MV0gID0gJ0hBX0VSUl9OT19SRUZFUkVOQ0VEX1JPVyc7XG5leHBvcnRzWzE1Ml0gID0gJ0hBX0VSUl9ST1dfSVNfUkVGRVJFTkNFRCc7XG5leHBvcnRzWzE1M10gID0gJ0hBX0VSUl9OT19TQVZFUE9JTlQnO1xuZXhwb3J0c1sxNTRdICA9ICdIQV9FUlJfTk9OX1VOSVFVRV9CTE9DS19TSVpFJztcbmV4cG9ydHNbMTU1XSAgPSAnSEFfRVJSX05PX1NVQ0hfVEFCTEUnO1xuZXhwb3J0c1sxNTZdICA9ICdIQV9FUlJfVEFCTEVfRVhJU1QnO1xuZXhwb3J0c1sxNTddICA9ICdIQV9FUlJfTk9fQ09OTkVDVElPTic7XG5leHBvcnRzWzE1OF0gID0gJ0hBX0VSUl9OVUxMX0lOX1NQQVRJQUwnO1xuZXhwb3J0c1sxNTldICA9ICdIQV9FUlJfVEFCTEVfREVGX0NIQU5HRUQnO1xuZXhwb3J0c1sxNjBdICA9ICdIQV9FUlJfTk9fUEFSVElUSU9OX0ZPVU5EJztcbmV4cG9ydHNbMTYxXSAgPSAnSEFfRVJSX1JCUl9MT0dHSU5HX0ZBSUxFRCc7XG5leHBvcnRzWzE2Ml0gID0gJ0hBX0VSUl9EUk9QX0lOREVYX0ZLJztcbmV4cG9ydHNbMTYzXSAgPSAnSEFfRVJSX0ZPUkVJR05fRFVQTElDQVRFX0tFWSc7XG5leHBvcnRzWzE2NF0gID0gJ0hBX0VSUl9UQUJMRV9ORUVEU19VUEdSQURFJztcbmV4cG9ydHNbMTY1XSAgPSAnSEFfRVJSX1RBQkxFX1JFQURPTkxZJztcbmV4cG9ydHNbMTY2XSAgPSAnSEFfRVJSX0FVVE9JTkNfUkVBRF9GQUlMRUQnO1xuZXhwb3J0c1sxNjddICA9ICdIQV9FUlJfQVVUT0lOQ19FUkFOR0UnO1xuZXhwb3J0c1sxNjhdICA9ICdIQV9FUlJfR0VORVJJQyc7XG5leHBvcnRzWzE2OV0gID0gJ0hBX0VSUl9SRUNPUkRfSVNfVEhFX1NBTUUnO1xuZXhwb3J0c1sxNzBdICA9ICdIQV9FUlJfTE9HR0lOR19JTVBPU1NJQkxFJztcbmV4cG9ydHNbMTcxXSAgPSAnSEFfRVJSX0NPUlJVUFRfRVZFTlQnO1xuZXhwb3J0c1sxNzJdICA9ICdIQV9FUlJfTkVXX0ZJTEUnO1xuZXhwb3J0c1sxNzNdICA9ICdIQV9FUlJfUk9XU19FVkVOVF9BUFBMWSc7XG5leHBvcnRzWzE3NF0gID0gJ0hBX0VSUl9JTklUSUFMSVpBVElPTic7XG5leHBvcnRzWzE3NV0gID0gJ0hBX0VSUl9GSUxFX1RPT19TSE9SVCc7XG5leHBvcnRzWzE3Nl0gID0gJ0hBX0VSUl9XUk9OR19DUkMnO1xuZXhwb3J0c1sxNzddICA9ICdIQV9FUlJfVE9PX01BTllfQ09OQ1VSUkVOVF9UUlhTJztcbmV4cG9ydHNbMTc4XSAgPSAnSEFfRVJSX05PVF9JTl9MT0NLX1BBUlRJVElPTlMnO1xuZXhwb3J0c1sxNzldICA9ICdIQV9FUlJfSU5ERVhfQ09MX1RPT19MT05HJztcbmV4cG9ydHNbMTgwXSAgPSAnSEFfRVJSX0lOREVYX0NPUlJVUFQnO1xuZXhwb3J0c1sxODFdICA9ICdIQV9FUlJfVU5ET19SRUNfVE9PX0JJRyc7XG5leHBvcnRzWzE4Ml0gID0gJ0hBX0ZUU19JTlZBTElEX0RPQ0lEJztcbmV4cG9ydHNbMTgzXSAgPSAnSEFfRVJSX1RBQkxFX0lOX0ZLX0NIRUNLJztcbmV4cG9ydHNbMTg0XSAgPSAnSEFfRVJSX1RBQkxFU1BBQ0VfRVhJU1RTJztcbmV4cG9ydHNbMTg1XSAgPSAnSEFfRVJSX1RPT19NQU5ZX0ZJRUxEUyc7XG5leHBvcnRzWzE4Nl0gID0gJ0hBX0VSUl9ST1dfSU5fV1JPTkdfUEFSVElUSU9OJztcbmV4cG9ydHNbMTg3XSAgPSAnSEFfRVJSX0lOTk9EQl9SRUFEX09OTFknO1xuZXhwb3J0c1sxODhdICA9ICdIQV9FUlJfRlRTX0VYQ0VFRF9SRVNVTFRfQ0FDSEVfTElNSVQnO1xuZXhwb3J0c1sxODldICA9ICdIQV9FUlJfVEVNUF9GSUxFX1dSSVRFX0ZBSUxVUkUnO1xuZXhwb3J0c1sxOTBdICA9ICdIQV9FUlJfSU5OT0RCX0ZPUkNFRF9SRUNPVkVSWSc7XG5leHBvcnRzWzE5MV0gID0gJ0hBX0VSUl9GVFNfVE9PX01BTllfV09SRFNfSU5fUEhSQVNFJztcbmV4cG9ydHNbMTAwMF0gPSAnRVJfSEFTSENISyc7XG5leHBvcnRzWzEwMDFdID0gJ0VSX05JU0FNQ0hLJztcbmV4cG9ydHNbMTAwMl0gPSAnRVJfTk8nO1xuZXhwb3J0c1sxMDAzXSA9ICdFUl9ZRVMnO1xuZXhwb3J0c1sxMDA0XSA9ICdFUl9DQU5UX0NSRUFURV9GSUxFJztcbmV4cG9ydHNbMTAwNV0gPSAnRVJfQ0FOVF9DUkVBVEVfVEFCTEUnO1xuZXhwb3J0c1sxMDA2XSA9ICdFUl9DQU5UX0NSRUFURV9EQic7XG5leHBvcnRzWzEwMDddID0gJ0VSX0RCX0NSRUFURV9FWElTVFMnO1xuZXhwb3J0c1sxMDA4XSA9ICdFUl9EQl9EUk9QX0VYSVNUUyc7XG5leHBvcnRzWzEwMDldID0gJ0VSX0RCX0RST1BfREVMRVRFJztcbmV4cG9ydHNbMTAxMF0gPSAnRVJfREJfRFJPUF9STURJUic7XG5leHBvcnRzWzEwMTFdID0gJ0VSX0NBTlRfREVMRVRFX0ZJTEUnO1xuZXhwb3J0c1sxMDEyXSA9ICdFUl9DQU5UX0ZJTkRfU1lTVEVNX1JFQyc7XG5leHBvcnRzWzEwMTNdID0gJ0VSX0NBTlRfR0VUX1NUQVQnO1xuZXhwb3J0c1sxMDE0XSA9ICdFUl9DQU5UX0dFVF9XRCc7XG5leHBvcnRzWzEwMTVdID0gJ0VSX0NBTlRfTE9DSyc7XG5leHBvcnRzWzEwMTZdID0gJ0VSX0NBTlRfT1BFTl9GSUxFJztcbmV4cG9ydHNbMTAxN10gPSAnRVJfRklMRV9OT1RfRk9VTkQnO1xuZXhwb3J0c1sxMDE4XSA9ICdFUl9DQU5UX1JFQURfRElSJztcbmV4cG9ydHNbMTAxOV0gPSAnRVJfQ0FOVF9TRVRfV0QnO1xuZXhwb3J0c1sxMDIwXSA9ICdFUl9DSEVDS1JFQUQnO1xuZXhwb3J0c1sxMDIxXSA9ICdFUl9ESVNLX0ZVTEwnO1xuZXhwb3J0c1sxMDIyXSA9ICdFUl9EVVBfS0VZJztcbmV4cG9ydHNbMTAyM10gPSAnRVJfRVJST1JfT05fQ0xPU0UnO1xuZXhwb3J0c1sxMDI0XSA9ICdFUl9FUlJPUl9PTl9SRUFEJztcbmV4cG9ydHNbMTAyNV0gPSAnRVJfRVJST1JfT05fUkVOQU1FJztcbmV4cG9ydHNbMTAyNl0gPSAnRVJfRVJST1JfT05fV1JJVEUnO1xuZXhwb3J0c1sxMDI3XSA9ICdFUl9GSUxFX1VTRUQnO1xuZXhwb3J0c1sxMDI4XSA9ICdFUl9GSUxTT1JUX0FCT1JUJztcbmV4cG9ydHNbMTAyOV0gPSAnRVJfRk9STV9OT1RfRk9VTkQnO1xuZXhwb3J0c1sxMDMwXSA9ICdFUl9HRVRfRVJSTk8nO1xuZXhwb3J0c1sxMDMxXSA9ICdFUl9JTExFR0FMX0hBJztcbmV4cG9ydHNbMTAzMl0gPSAnRVJfS0VZX05PVF9GT1VORCc7XG5leHBvcnRzWzEwMzNdID0gJ0VSX05PVF9GT1JNX0ZJTEUnO1xuZXhwb3J0c1sxMDM0XSA9ICdFUl9OT1RfS0VZRklMRSc7XG5leHBvcnRzWzEwMzVdID0gJ0VSX09MRF9LRVlGSUxFJztcbmV4cG9ydHNbMTAzNl0gPSAnRVJfT1BFTl9BU19SRUFET05MWSc7XG5leHBvcnRzWzEwMzddID0gJ0VSX09VVE9GTUVNT1JZJztcbmV4cG9ydHNbMTAzOF0gPSAnRVJfT1VUX09GX1NPUlRNRU1PUlknO1xuZXhwb3J0c1sxMDM5XSA9ICdFUl9VTkVYUEVDVEVEX0VPRic7XG5leHBvcnRzWzEwNDBdID0gJ0VSX0NPTl9DT1VOVF9FUlJPUic7XG5leHBvcnRzWzEwNDFdID0gJ0VSX09VVF9PRl9SRVNPVVJDRVMnO1xuZXhwb3J0c1sxMDQyXSA9ICdFUl9CQURfSE9TVF9FUlJPUic7XG5leHBvcnRzWzEwNDNdID0gJ0VSX0hBTkRTSEFLRV9FUlJPUic7XG5leHBvcnRzWzEwNDRdID0gJ0VSX0RCQUNDRVNTX0RFTklFRF9FUlJPUic7XG5leHBvcnRzWzEwNDVdID0gJ0VSX0FDQ0VTU19ERU5JRURfRVJST1InO1xuZXhwb3J0c1sxMDQ2XSA9ICdFUl9OT19EQl9FUlJPUic7XG5leHBvcnRzWzEwNDddID0gJ0VSX1VOS05PV05fQ09NX0VSUk9SJztcbmV4cG9ydHNbMTA0OF0gPSAnRVJfQkFEX05VTExfRVJST1InO1xuZXhwb3J0c1sxMDQ5XSA9ICdFUl9CQURfREJfRVJST1InO1xuZXhwb3J0c1sxMDUwXSA9ICdFUl9UQUJMRV9FWElTVFNfRVJST1InO1xuZXhwb3J0c1sxMDUxXSA9ICdFUl9CQURfVEFCTEVfRVJST1InO1xuZXhwb3J0c1sxMDUyXSA9ICdFUl9OT05fVU5JUV9FUlJPUic7XG5leHBvcnRzWzEwNTNdID0gJ0VSX1NFUlZFUl9TSFVURE9XTic7XG5leHBvcnRzWzEwNTRdID0gJ0VSX0JBRF9GSUVMRF9FUlJPUic7XG5leHBvcnRzWzEwNTVdID0gJ0VSX1dST05HX0ZJRUxEX1dJVEhfR1JPVVAnO1xuZXhwb3J0c1sxMDU2XSA9ICdFUl9XUk9OR19HUk9VUF9GSUVMRCc7XG5leHBvcnRzWzEwNTddID0gJ0VSX1dST05HX1NVTV9TRUxFQ1QnO1xuZXhwb3J0c1sxMDU4XSA9ICdFUl9XUk9OR19WQUxVRV9DT1VOVCc7XG5leHBvcnRzWzEwNTldID0gJ0VSX1RPT19MT05HX0lERU5UJztcbmV4cG9ydHNbMTA2MF0gPSAnRVJfRFVQX0ZJRUxETkFNRSc7XG5leHBvcnRzWzEwNjFdID0gJ0VSX0RVUF9LRVlOQU1FJztcbmV4cG9ydHNbMTA2Ml0gPSAnRVJfRFVQX0VOVFJZJztcbmV4cG9ydHNbMTA2M10gPSAnRVJfV1JPTkdfRklFTERfU1BFQyc7XG5leHBvcnRzWzEwNjRdID0gJ0VSX1BBUlNFX0VSUk9SJztcbmV4cG9ydHNbMTA2NV0gPSAnRVJfRU1QVFlfUVVFUlknO1xuZXhwb3J0c1sxMDY2XSA9ICdFUl9OT05VTklRX1RBQkxFJztcbmV4cG9ydHNbMTA2N10gPSAnRVJfSU5WQUxJRF9ERUZBVUxUJztcbmV4cG9ydHNbMTA2OF0gPSAnRVJfTVVMVElQTEVfUFJJX0tFWSc7XG5leHBvcnRzWzEwNjldID0gJ0VSX1RPT19NQU5ZX0tFWVMnO1xuZXhwb3J0c1sxMDcwXSA9ICdFUl9UT09fTUFOWV9LRVlfUEFSVFMnO1xuZXhwb3J0c1sxMDcxXSA9ICdFUl9UT09fTE9OR19LRVknO1xuZXhwb3J0c1sxMDcyXSA9ICdFUl9LRVlfQ09MVU1OX0RPRVNfTk9UX0VYSVRTJztcbmV4cG9ydHNbMTA3M10gPSAnRVJfQkxPQl9VU0VEX0FTX0tFWSc7XG5leHBvcnRzWzEwNzRdID0gJ0VSX1RPT19CSUdfRklFTERMRU5HVEgnO1xuZXhwb3J0c1sxMDc1XSA9ICdFUl9XUk9OR19BVVRPX0tFWSc7XG5leHBvcnRzWzEwNzZdID0gJ0VSX1JFQURZJztcbmV4cG9ydHNbMTA3N10gPSAnRVJfTk9STUFMX1NIVVRET1dOJztcbmV4cG9ydHNbMTA3OF0gPSAnRVJfR09UX1NJR05BTCc7XG5leHBvcnRzWzEwNzldID0gJ0VSX1NIVVRET1dOX0NPTVBMRVRFJztcbmV4cG9ydHNbMTA4MF0gPSAnRVJfRk9SQ0lOR19DTE9TRSc7XG5leHBvcnRzWzEwODFdID0gJ0VSX0lQU09DS19FUlJPUic7XG5leHBvcnRzWzEwODJdID0gJ0VSX05PX1NVQ0hfSU5ERVgnO1xuZXhwb3J0c1sxMDgzXSA9ICdFUl9XUk9OR19GSUVMRF9URVJNSU5BVE9SUyc7XG5leHBvcnRzWzEwODRdID0gJ0VSX0JMT0JTX0FORF9OT19URVJNSU5BVEVEJztcbmV4cG9ydHNbMTA4NV0gPSAnRVJfVEVYVEZJTEVfTk9UX1JFQURBQkxFJztcbmV4cG9ydHNbMTA4Nl0gPSAnRVJfRklMRV9FWElTVFNfRVJST1InO1xuZXhwb3J0c1sxMDg3XSA9ICdFUl9MT0FEX0lORk8nO1xuZXhwb3J0c1sxMDg4XSA9ICdFUl9BTFRFUl9JTkZPJztcbmV4cG9ydHNbMTA4OV0gPSAnRVJfV1JPTkdfU1VCX0tFWSc7XG5leHBvcnRzWzEwOTBdID0gJ0VSX0NBTlRfUkVNT1ZFX0FMTF9GSUVMRFMnO1xuZXhwb3J0c1sxMDkxXSA9ICdFUl9DQU5UX0RST1BfRklFTERfT1JfS0VZJztcbmV4cG9ydHNbMTA5Ml0gPSAnRVJfSU5TRVJUX0lORk8nO1xuZXhwb3J0c1sxMDkzXSA9ICdFUl9VUERBVEVfVEFCTEVfVVNFRCc7XG5leHBvcnRzWzEwOTRdID0gJ0VSX05PX1NVQ0hfVEhSRUFEJztcbmV4cG9ydHNbMTA5NV0gPSAnRVJfS0lMTF9ERU5JRURfRVJST1InO1xuZXhwb3J0c1sxMDk2XSA9ICdFUl9OT19UQUJMRVNfVVNFRCc7XG5leHBvcnRzWzEwOTddID0gJ0VSX1RPT19CSUdfU0VUJztcbmV4cG9ydHNbMTA5OF0gPSAnRVJfTk9fVU5JUVVFX0xPR0ZJTEUnO1xuZXhwb3J0c1sxMDk5XSA9ICdFUl9UQUJMRV9OT1RfTE9DS0VEX0ZPUl9XUklURSc7XG5leHBvcnRzWzExMDBdID0gJ0VSX1RBQkxFX05PVF9MT0NLRUQnO1xuZXhwb3J0c1sxMTAxXSA9ICdFUl9CTE9CX0NBTlRfSEFWRV9ERUZBVUxUJztcbmV4cG9ydHNbMTEwMl0gPSAnRVJfV1JPTkdfREJfTkFNRSc7XG5leHBvcnRzWzExMDNdID0gJ0VSX1dST05HX1RBQkxFX05BTUUnO1xuZXhwb3J0c1sxMTA0XSA9ICdFUl9UT09fQklHX1NFTEVDVCc7XG5leHBvcnRzWzExMDVdID0gJ0VSX1VOS05PV05fRVJST1InO1xuZXhwb3J0c1sxMTA2XSA9ICdFUl9VTktOT1dOX1BST0NFRFVSRSc7XG5leHBvcnRzWzExMDddID0gJ0VSX1dST05HX1BBUkFNQ09VTlRfVE9fUFJPQ0VEVVJFJztcbmV4cG9ydHNbMTEwOF0gPSAnRVJfV1JPTkdfUEFSQU1FVEVSU19UT19QUk9DRURVUkUnO1xuZXhwb3J0c1sxMTA5XSA9ICdFUl9VTktOT1dOX1RBQkxFJztcbmV4cG9ydHNbMTExMF0gPSAnRVJfRklFTERfU1BFQ0lGSUVEX1RXSUNFJztcbmV4cG9ydHNbMTExMV0gPSAnRVJfSU5WQUxJRF9HUk9VUF9GVU5DX1VTRSc7XG5leHBvcnRzWzExMTJdID0gJ0VSX1VOU1VQUE9SVEVEX0VYVEVOU0lPTic7XG5leHBvcnRzWzExMTNdID0gJ0VSX1RBQkxFX01VU1RfSEFWRV9DT0xVTU5TJztcbmV4cG9ydHNbMTExNF0gPSAnRVJfUkVDT1JEX0ZJTEVfRlVMTCc7XG5leHBvcnRzWzExMTVdID0gJ0VSX1VOS05PV05fQ0hBUkFDVEVSX1NFVCc7XG5leHBvcnRzWzExMTZdID0gJ0VSX1RPT19NQU5ZX1RBQkxFUyc7XG5leHBvcnRzWzExMTddID0gJ0VSX1RPT19NQU5ZX0ZJRUxEUyc7XG5leHBvcnRzWzExMThdID0gJ0VSX1RPT19CSUdfUk9XU0laRSc7XG5leHBvcnRzWzExMTldID0gJ0VSX1NUQUNLX09WRVJSVU4nO1xuZXhwb3J0c1sxMTIwXSA9ICdFUl9XUk9OR19PVVRFUl9KT0lOJztcbmV4cG9ydHNbMTEyMV0gPSAnRVJfTlVMTF9DT0xVTU5fSU5fSU5ERVgnO1xuZXhwb3J0c1sxMTIyXSA9ICdFUl9DQU5UX0ZJTkRfVURGJztcbmV4cG9ydHNbMTEyM10gPSAnRVJfQ0FOVF9JTklUSUFMSVpFX1VERic7XG5leHBvcnRzWzExMjRdID0gJ0VSX1VERl9OT19QQVRIUyc7XG5leHBvcnRzWzExMjVdID0gJ0VSX1VERl9FWElTVFMnO1xuZXhwb3J0c1sxMTI2XSA9ICdFUl9DQU5UX09QRU5fTElCUkFSWSc7XG5leHBvcnRzWzExMjddID0gJ0VSX0NBTlRfRklORF9ETF9FTlRSWSc7XG5leHBvcnRzWzExMjhdID0gJ0VSX0ZVTkNUSU9OX05PVF9ERUZJTkVEJztcbmV4cG9ydHNbMTEyOV0gPSAnRVJfSE9TVF9JU19CTE9DS0VEJztcbmV4cG9ydHNbMTEzMF0gPSAnRVJfSE9TVF9OT1RfUFJJVklMRUdFRCc7XG5leHBvcnRzWzExMzFdID0gJ0VSX1BBU1NXT1JEX0FOT05ZTU9VU19VU0VSJztcbmV4cG9ydHNbMTEzMl0gPSAnRVJfUEFTU1dPUkRfTk9UX0FMTE9XRUQnO1xuZXhwb3J0c1sxMTMzXSA9ICdFUl9QQVNTV09SRF9OT19NQVRDSCc7XG5leHBvcnRzWzExMzRdID0gJ0VSX1VQREFURV9JTkZPJztcbmV4cG9ydHNbMTEzNV0gPSAnRVJfQ0FOVF9DUkVBVEVfVEhSRUFEJztcbmV4cG9ydHNbMTEzNl0gPSAnRVJfV1JPTkdfVkFMVUVfQ09VTlRfT05fUk9XJztcbmV4cG9ydHNbMTEzN10gPSAnRVJfQ0FOVF9SRU9QRU5fVEFCTEUnO1xuZXhwb3J0c1sxMTM4XSA9ICdFUl9JTlZBTElEX1VTRV9PRl9OVUxMJztcbmV4cG9ydHNbMTEzOV0gPSAnRVJfUkVHRVhQX0VSUk9SJztcbmV4cG9ydHNbMTE0MF0gPSAnRVJfTUlYX09GX0dST1VQX0ZVTkNfQU5EX0ZJRUxEUyc7XG5leHBvcnRzWzExNDFdID0gJ0VSX05PTkVYSVNUSU5HX0dSQU5UJztcbmV4cG9ydHNbMTE0Ml0gPSAnRVJfVEFCTEVBQ0NFU1NfREVOSUVEX0VSUk9SJztcbmV4cG9ydHNbMTE0M10gPSAnRVJfQ09MVU1OQUNDRVNTX0RFTklFRF9FUlJPUic7XG5leHBvcnRzWzExNDRdID0gJ0VSX0lMTEVHQUxfR1JBTlRfRk9SX1RBQkxFJztcbmV4cG9ydHNbMTE0NV0gPSAnRVJfR1JBTlRfV1JPTkdfSE9TVF9PUl9VU0VSJztcbmV4cG9ydHNbMTE0Nl0gPSAnRVJfTk9fU1VDSF9UQUJMRSc7XG5leHBvcnRzWzExNDddID0gJ0VSX05PTkVYSVNUSU5HX1RBQkxFX0dSQU5UJztcbmV4cG9ydHNbMTE0OF0gPSAnRVJfTk9UX0FMTE9XRURfQ09NTUFORCc7XG5leHBvcnRzWzExNDldID0gJ0VSX1NZTlRBWF9FUlJPUic7XG5leHBvcnRzWzExNTBdID0gJ0VSX0RFTEFZRURfQ0FOVF9DSEFOR0VfTE9DSyc7XG5leHBvcnRzWzExNTFdID0gJ0VSX1RPT19NQU5ZX0RFTEFZRURfVEhSRUFEUyc7XG5leHBvcnRzWzExNTJdID0gJ0VSX0FCT1JUSU5HX0NPTk5FQ1RJT04nO1xuZXhwb3J0c1sxMTUzXSA9ICdFUl9ORVRfUEFDS0VUX1RPT19MQVJHRSc7XG5leHBvcnRzWzExNTRdID0gJ0VSX05FVF9SRUFEX0VSUk9SX0ZST01fUElQRSc7XG5leHBvcnRzWzExNTVdID0gJ0VSX05FVF9GQ05UTF9FUlJPUic7XG5leHBvcnRzWzExNTZdID0gJ0VSX05FVF9QQUNLRVRTX09VVF9PRl9PUkRFUic7XG5leHBvcnRzWzExNTddID0gJ0VSX05FVF9VTkNPTVBSRVNTX0VSUk9SJztcbmV4cG9ydHNbMTE1OF0gPSAnRVJfTkVUX1JFQURfRVJST1InO1xuZXhwb3J0c1sxMTU5XSA9ICdFUl9ORVRfUkVBRF9JTlRFUlJVUFRFRCc7XG5leHBvcnRzWzExNjBdID0gJ0VSX05FVF9FUlJPUl9PTl9XUklURSc7XG5leHBvcnRzWzExNjFdID0gJ0VSX05FVF9XUklURV9JTlRFUlJVUFRFRCc7XG5leHBvcnRzWzExNjJdID0gJ0VSX1RPT19MT05HX1NUUklORyc7XG5leHBvcnRzWzExNjNdID0gJ0VSX1RBQkxFX0NBTlRfSEFORExFX0JMT0InO1xuZXhwb3J0c1sxMTY0XSA9ICdFUl9UQUJMRV9DQU5UX0hBTkRMRV9BVVRPX0lOQ1JFTUVOVCc7XG5leHBvcnRzWzExNjVdID0gJ0VSX0RFTEFZRURfSU5TRVJUX1RBQkxFX0xPQ0tFRCc7XG5leHBvcnRzWzExNjZdID0gJ0VSX1dST05HX0NPTFVNTl9OQU1FJztcbmV4cG9ydHNbMTE2N10gPSAnRVJfV1JPTkdfS0VZX0NPTFVNTic7XG5leHBvcnRzWzExNjhdID0gJ0VSX1dST05HX01SR19UQUJMRSc7XG5leHBvcnRzWzExNjldID0gJ0VSX0RVUF9VTklRVUUnO1xuZXhwb3J0c1sxMTcwXSA9ICdFUl9CTE9CX0tFWV9XSVRIT1VUX0xFTkdUSCc7XG5leHBvcnRzWzExNzFdID0gJ0VSX1BSSU1BUllfQ0FOVF9IQVZFX05VTEwnO1xuZXhwb3J0c1sxMTcyXSA9ICdFUl9UT09fTUFOWV9ST1dTJztcbmV4cG9ydHNbMTE3M10gPSAnRVJfUkVRVUlSRVNfUFJJTUFSWV9LRVknO1xuZXhwb3J0c1sxMTc0XSA9ICdFUl9OT19SQUlEX0NPTVBJTEVEJztcbmV4cG9ydHNbMTE3NV0gPSAnRVJfVVBEQVRFX1dJVEhPVVRfS0VZX0lOX1NBRkVfTU9ERSc7XG5leHBvcnRzWzExNzZdID0gJ0VSX0tFWV9ET0VTX05PVF9FWElUUyc7XG5leHBvcnRzWzExNzddID0gJ0VSX0NIRUNLX05PX1NVQ0hfVEFCTEUnO1xuZXhwb3J0c1sxMTc4XSA9ICdFUl9DSEVDS19OT1RfSU1QTEVNRU5URUQnO1xuZXhwb3J0c1sxMTc5XSA9ICdFUl9DQU5UX0RPX1RISVNfRFVSSU5HX0FOX1RSQU5TQUNUSU9OJztcbmV4cG9ydHNbMTE4MF0gPSAnRVJfRVJST1JfRFVSSU5HX0NPTU1JVCc7XG5leHBvcnRzWzExODFdID0gJ0VSX0VSUk9SX0RVUklOR19ST0xMQkFDSyc7XG5leHBvcnRzWzExODJdID0gJ0VSX0VSUk9SX0RVUklOR19GTFVTSF9MT0dTJztcbmV4cG9ydHNbMTE4M10gPSAnRVJfRVJST1JfRFVSSU5HX0NIRUNLUE9JTlQnO1xuZXhwb3J0c1sxMTg0XSA9ICdFUl9ORVdfQUJPUlRJTkdfQ09OTkVDVElPTic7XG5leHBvcnRzWzExODVdID0gJ0VSX0RVTVBfTk9UX0lNUExFTUVOVEVEJztcbmV4cG9ydHNbMTE4Nl0gPSAnRVJfRkxVU0hfTUFTVEVSX0JJTkxPR19DTE9TRUQnO1xuZXhwb3J0c1sxMTg3XSA9ICdFUl9JTkRFWF9SRUJVSUxEJztcbmV4cG9ydHNbMTE4OF0gPSAnRVJfTUFTVEVSJztcbmV4cG9ydHNbMTE4OV0gPSAnRVJfTUFTVEVSX05FVF9SRUFEJztcbmV4cG9ydHNbMTE5MF0gPSAnRVJfTUFTVEVSX05FVF9XUklURSc7XG5leHBvcnRzWzExOTFdID0gJ0VSX0ZUX01BVENISU5HX0tFWV9OT1RfRk9VTkQnO1xuZXhwb3J0c1sxMTkyXSA9ICdFUl9MT0NLX09SX0FDVElWRV9UUkFOU0FDVElPTic7XG5leHBvcnRzWzExOTNdID0gJ0VSX1VOS05PV05fU1lTVEVNX1ZBUklBQkxFJztcbmV4cG9ydHNbMTE5NF0gPSAnRVJfQ1JBU0hFRF9PTl9VU0FHRSc7XG5leHBvcnRzWzExOTVdID0gJ0VSX0NSQVNIRURfT05fUkVQQUlSJztcbmV4cG9ydHNbMTE5Nl0gPSAnRVJfV0FSTklOR19OT1RfQ09NUExFVEVfUk9MTEJBQ0snO1xuZXhwb3J0c1sxMTk3XSA9ICdFUl9UUkFOU19DQUNIRV9GVUxMJztcbmV4cG9ydHNbMTE5OF0gPSAnRVJfU0xBVkVfTVVTVF9TVE9QJztcbmV4cG9ydHNbMTE5OV0gPSAnRVJfU0xBVkVfTk9UX1JVTk5JTkcnO1xuZXhwb3J0c1sxMjAwXSA9ICdFUl9CQURfU0xBVkUnO1xuZXhwb3J0c1sxMjAxXSA9ICdFUl9NQVNURVJfSU5GTyc7XG5leHBvcnRzWzEyMDJdID0gJ0VSX1NMQVZFX1RIUkVBRCc7XG5leHBvcnRzWzEyMDNdID0gJ0VSX1RPT19NQU5ZX1VTRVJfQ09OTkVDVElPTlMnO1xuZXhwb3J0c1sxMjA0XSA9ICdFUl9TRVRfQ09OU1RBTlRTX09OTFknO1xuZXhwb3J0c1sxMjA1XSA9ICdFUl9MT0NLX1dBSVRfVElNRU9VVCc7XG5leHBvcnRzWzEyMDZdID0gJ0VSX0xPQ0tfVEFCTEVfRlVMTCc7XG5leHBvcnRzWzEyMDddID0gJ0VSX1JFQURfT05MWV9UUkFOU0FDVElPTic7XG5leHBvcnRzWzEyMDhdID0gJ0VSX0RST1BfREJfV0lUSF9SRUFEX0xPQ0snO1xuZXhwb3J0c1sxMjA5XSA9ICdFUl9DUkVBVEVfREJfV0lUSF9SRUFEX0xPQ0snO1xuZXhwb3J0c1sxMjEwXSA9ICdFUl9XUk9OR19BUkdVTUVOVFMnO1xuZXhwb3J0c1sxMjExXSA9ICdFUl9OT19QRVJNSVNTSU9OX1RPX0NSRUFURV9VU0VSJztcbmV4cG9ydHNbMTIxMl0gPSAnRVJfVU5JT05fVEFCTEVTX0lOX0RJRkZFUkVOVF9ESVInO1xuZXhwb3J0c1sxMjEzXSA9ICdFUl9MT0NLX0RFQURMT0NLJztcbmV4cG9ydHNbMTIxNF0gPSAnRVJfVEFCTEVfQ0FOVF9IQU5ETEVfRlQnO1xuZXhwb3J0c1sxMjE1XSA9ICdFUl9DQU5OT1RfQUREX0ZPUkVJR04nO1xuZXhwb3J0c1sxMjE2XSA9ICdFUl9OT19SRUZFUkVOQ0VEX1JPVyc7XG5leHBvcnRzWzEyMTddID0gJ0VSX1JPV19JU19SRUZFUkVOQ0VEJztcbmV4cG9ydHNbMTIxOF0gPSAnRVJfQ09OTkVDVF9UT19NQVNURVInO1xuZXhwb3J0c1sxMjE5XSA9ICdFUl9RVUVSWV9PTl9NQVNURVInO1xuZXhwb3J0c1sxMjIwXSA9ICdFUl9FUlJPUl9XSEVOX0VYRUNVVElOR19DT01NQU5EJztcbmV4cG9ydHNbMTIyMV0gPSAnRVJfV1JPTkdfVVNBR0UnO1xuZXhwb3J0c1sxMjIyXSA9ICdFUl9XUk9OR19OVU1CRVJfT0ZfQ09MVU1OU19JTl9TRUxFQ1QnO1xuZXhwb3J0c1sxMjIzXSA9ICdFUl9DQU5UX1VQREFURV9XSVRIX1JFQURMT0NLJztcbmV4cG9ydHNbMTIyNF0gPSAnRVJfTUlYSU5HX05PVF9BTExPV0VEJztcbmV4cG9ydHNbMTIyNV0gPSAnRVJfRFVQX0FSR1VNRU5UJztcbmV4cG9ydHNbMTIyNl0gPSAnRVJfVVNFUl9MSU1JVF9SRUFDSEVEJztcbmV4cG9ydHNbMTIyN10gPSAnRVJfU1BFQ0lGSUNfQUNDRVNTX0RFTklFRF9FUlJPUic7XG5leHBvcnRzWzEyMjhdID0gJ0VSX0xPQ0FMX1ZBUklBQkxFJztcbmV4cG9ydHNbMTIyOV0gPSAnRVJfR0xPQkFMX1ZBUklBQkxFJztcbmV4cG9ydHNbMTIzMF0gPSAnRVJfTk9fREVGQVVMVCc7XG5leHBvcnRzWzEyMzFdID0gJ0VSX1dST05HX1ZBTFVFX0ZPUl9WQVInO1xuZXhwb3J0c1sxMjMyXSA9ICdFUl9XUk9OR19UWVBFX0ZPUl9WQVInO1xuZXhwb3J0c1sxMjMzXSA9ICdFUl9WQVJfQ0FOVF9CRV9SRUFEJztcbmV4cG9ydHNbMTIzNF0gPSAnRVJfQ0FOVF9VU0VfT1BUSU9OX0hFUkUnO1xuZXhwb3J0c1sxMjM1XSA9ICdFUl9OT1RfU1VQUE9SVEVEX1lFVCc7XG5leHBvcnRzWzEyMzZdID0gJ0VSX01BU1RFUl9GQVRBTF9FUlJPUl9SRUFESU5HX0JJTkxPRyc7XG5leHBvcnRzWzEyMzddID0gJ0VSX1NMQVZFX0lHTk9SRURfVEFCTEUnO1xuZXhwb3J0c1sxMjM4XSA9ICdFUl9JTkNPUlJFQ1RfR0xPQkFMX0xPQ0FMX1ZBUic7XG5leHBvcnRzWzEyMzldID0gJ0VSX1dST05HX0ZLX0RFRic7XG5leHBvcnRzWzEyNDBdID0gJ0VSX0tFWV9SRUZfRE9fTk9UX01BVENIX1RBQkxFX1JFRic7XG5leHBvcnRzWzEyNDFdID0gJ0VSX09QRVJBTkRfQ09MVU1OUyc7XG5leHBvcnRzWzEyNDJdID0gJ0VSX1NVQlFVRVJZX05PXzFfUk9XJztcbmV4cG9ydHNbMTI0M10gPSAnRVJfVU5LTk9XTl9TVE1UX0hBTkRMRVInO1xuZXhwb3J0c1sxMjQ0XSA9ICdFUl9DT1JSVVBUX0hFTFBfREInO1xuZXhwb3J0c1sxMjQ1XSA9ICdFUl9DWUNMSUNfUkVGRVJFTkNFJztcbmV4cG9ydHNbMTI0Nl0gPSAnRVJfQVVUT19DT05WRVJUJztcbmV4cG9ydHNbMTI0N10gPSAnRVJfSUxMRUdBTF9SRUZFUkVOQ0UnO1xuZXhwb3J0c1sxMjQ4XSA9ICdFUl9ERVJJVkVEX01VU1RfSEFWRV9BTElBUyc7XG5leHBvcnRzWzEyNDldID0gJ0VSX1NFTEVDVF9SRURVQ0VEJztcbmV4cG9ydHNbMTI1MF0gPSAnRVJfVEFCTEVOQU1FX05PVF9BTExPV0VEX0hFUkUnO1xuZXhwb3J0c1sxMjUxXSA9ICdFUl9OT1RfU1VQUE9SVEVEX0FVVEhfTU9ERSc7XG5leHBvcnRzWzEyNTJdID0gJ0VSX1NQQVRJQUxfQ0FOVF9IQVZFX05VTEwnO1xuZXhwb3J0c1sxMjUzXSA9ICdFUl9DT0xMQVRJT05fQ0hBUlNFVF9NSVNNQVRDSCc7XG5leHBvcnRzWzEyNTRdID0gJ0VSX1NMQVZFX1dBU19SVU5OSU5HJztcbmV4cG9ydHNbMTI1NV0gPSAnRVJfU0xBVkVfV0FTX05PVF9SVU5OSU5HJztcbmV4cG9ydHNbMTI1Nl0gPSAnRVJfVE9PX0JJR19GT1JfVU5DT01QUkVTUyc7XG5leHBvcnRzWzEyNTddID0gJ0VSX1pMSUJfWl9NRU1fRVJST1InO1xuZXhwb3J0c1sxMjU4XSA9ICdFUl9aTElCX1pfQlVGX0VSUk9SJztcbmV4cG9ydHNbMTI1OV0gPSAnRVJfWkxJQl9aX0RBVEFfRVJST1InO1xuZXhwb3J0c1sxMjYwXSA9ICdFUl9DVVRfVkFMVUVfR1JPVVBfQ09OQ0FUJztcbmV4cG9ydHNbMTI2MV0gPSAnRVJfV0FSTl9UT09fRkVXX1JFQ09SRFMnO1xuZXhwb3J0c1sxMjYyXSA9ICdFUl9XQVJOX1RPT19NQU5ZX1JFQ09SRFMnO1xuZXhwb3J0c1sxMjYzXSA9ICdFUl9XQVJOX05VTExfVE9fTk9UTlVMTCc7XG5leHBvcnRzWzEyNjRdID0gJ0VSX1dBUk5fREFUQV9PVVRfT0ZfUkFOR0UnO1xuZXhwb3J0c1sxMjY1XSA9ICdXQVJOX0RBVEFfVFJVTkNBVEVEJztcbmV4cG9ydHNbMTI2Nl0gPSAnRVJfV0FSTl9VU0lOR19PVEhFUl9IQU5ETEVSJztcbmV4cG9ydHNbMTI2N10gPSAnRVJfQ0FOVF9BR0dSRUdBVEVfMkNPTExBVElPTlMnO1xuZXhwb3J0c1sxMjY4XSA9ICdFUl9EUk9QX1VTRVInO1xuZXhwb3J0c1sxMjY5XSA9ICdFUl9SRVZPS0VfR1JBTlRTJztcbmV4cG9ydHNbMTI3MF0gPSAnRVJfQ0FOVF9BR0dSRUdBVEVfM0NPTExBVElPTlMnO1xuZXhwb3J0c1sxMjcxXSA9ICdFUl9DQU5UX0FHR1JFR0FURV9OQ09MTEFUSU9OUyc7XG5leHBvcnRzWzEyNzJdID0gJ0VSX1ZBUklBQkxFX0lTX05PVF9TVFJVQ1QnO1xuZXhwb3J0c1sxMjczXSA9ICdFUl9VTktOT1dOX0NPTExBVElPTic7XG5leHBvcnRzWzEyNzRdID0gJ0VSX1NMQVZFX0lHTk9SRURfU1NMX1BBUkFNUyc7XG5leHBvcnRzWzEyNzVdID0gJ0VSX1NFUlZFUl9JU19JTl9TRUNVUkVfQVVUSF9NT0RFJztcbmV4cG9ydHNbMTI3Nl0gPSAnRVJfV0FSTl9GSUVMRF9SRVNPTFZFRCc7XG5leHBvcnRzWzEyNzddID0gJ0VSX0JBRF9TTEFWRV9VTlRJTF9DT05EJztcbmV4cG9ydHNbMTI3OF0gPSAnRVJfTUlTU0lOR19TS0lQX1NMQVZFJztcbmV4cG9ydHNbMTI3OV0gPSAnRVJfVU5USUxfQ09ORF9JR05PUkVEJztcbmV4cG9ydHNbMTI4MF0gPSAnRVJfV1JPTkdfTkFNRV9GT1JfSU5ERVgnO1xuZXhwb3J0c1sxMjgxXSA9ICdFUl9XUk9OR19OQU1FX0ZPUl9DQVRBTE9HJztcbmV4cG9ydHNbMTI4Ml0gPSAnRVJfV0FSTl9RQ19SRVNJWkUnO1xuZXhwb3J0c1sxMjgzXSA9ICdFUl9CQURfRlRfQ09MVU1OJztcbmV4cG9ydHNbMTI4NF0gPSAnRVJfVU5LTk9XTl9LRVlfQ0FDSEUnO1xuZXhwb3J0c1sxMjg1XSA9ICdFUl9XQVJOX0hPU1ROQU1FX1dPTlRfV09SSyc7XG5leHBvcnRzWzEyODZdID0gJ0VSX1VOS05PV05fU1RPUkFHRV9FTkdJTkUnO1xuZXhwb3J0c1sxMjg3XSA9ICdFUl9XQVJOX0RFUFJFQ0FURURfU1lOVEFYJztcbmV4cG9ydHNbMTI4OF0gPSAnRVJfTk9OX1VQREFUQUJMRV9UQUJMRSc7XG5leHBvcnRzWzEyODldID0gJ0VSX0ZFQVRVUkVfRElTQUJMRUQnO1xuZXhwb3J0c1sxMjkwXSA9ICdFUl9PUFRJT05fUFJFVkVOVFNfU1RBVEVNRU5UJztcbmV4cG9ydHNbMTI5MV0gPSAnRVJfRFVQTElDQVRFRF9WQUxVRV9JTl9UWVBFJztcbmV4cG9ydHNbMTI5Ml0gPSAnRVJfVFJVTkNBVEVEX1dST05HX1ZBTFVFJztcbmV4cG9ydHNbMTI5M10gPSAnRVJfVE9PX01VQ0hfQVVUT19USU1FU1RBTVBfQ09MUyc7XG5leHBvcnRzWzEyOTRdID0gJ0VSX0lOVkFMSURfT05fVVBEQVRFJztcbmV4cG9ydHNbMTI5NV0gPSAnRVJfVU5TVVBQT1JURURfUFMnO1xuZXhwb3J0c1sxMjk2XSA9ICdFUl9HRVRfRVJSTVNHJztcbmV4cG9ydHNbMTI5N10gPSAnRVJfR0VUX1RFTVBPUkFSWV9FUlJNU0cnO1xuZXhwb3J0c1sxMjk4XSA9ICdFUl9VTktOT1dOX1RJTUVfWk9ORSc7XG5leHBvcnRzWzEyOTldID0gJ0VSX1dBUk5fSU5WQUxJRF9USU1FU1RBTVAnO1xuZXhwb3J0c1sxMzAwXSA9ICdFUl9JTlZBTElEX0NIQVJBQ1RFUl9TVFJJTkcnO1xuZXhwb3J0c1sxMzAxXSA9ICdFUl9XQVJOX0FMTE9XRURfUEFDS0VUX09WRVJGTE9XRUQnO1xuZXhwb3J0c1sxMzAyXSA9ICdFUl9DT05GTElDVElOR19ERUNMQVJBVElPTlMnO1xuZXhwb3J0c1sxMzAzXSA9ICdFUl9TUF9OT19SRUNVUlNJVkVfQ1JFQVRFJztcbmV4cG9ydHNbMTMwNF0gPSAnRVJfU1BfQUxSRUFEWV9FWElTVFMnO1xuZXhwb3J0c1sxMzA1XSA9ICdFUl9TUF9ET0VTX05PVF9FWElTVCc7XG5leHBvcnRzWzEzMDZdID0gJ0VSX1NQX0RST1BfRkFJTEVEJztcbmV4cG9ydHNbMTMwN10gPSAnRVJfU1BfU1RPUkVfRkFJTEVEJztcbmV4cG9ydHNbMTMwOF0gPSAnRVJfU1BfTElMQUJFTF9NSVNNQVRDSCc7XG5leHBvcnRzWzEzMDldID0gJ0VSX1NQX0xBQkVMX1JFREVGSU5FJztcbmV4cG9ydHNbMTMxMF0gPSAnRVJfU1BfTEFCRUxfTUlTTUFUQ0gnO1xuZXhwb3J0c1sxMzExXSA9ICdFUl9TUF9VTklOSVRfVkFSJztcbmV4cG9ydHNbMTMxMl0gPSAnRVJfU1BfQkFEU0VMRUNUJztcbmV4cG9ydHNbMTMxM10gPSAnRVJfU1BfQkFEUkVUVVJOJztcbmV4cG9ydHNbMTMxNF0gPSAnRVJfU1BfQkFEU1RBVEVNRU5UJztcbmV4cG9ydHNbMTMxNV0gPSAnRVJfVVBEQVRFX0xPR19ERVBSRUNBVEVEX0lHTk9SRUQnO1xuZXhwb3J0c1sxMzE2XSA9ICdFUl9VUERBVEVfTE9HX0RFUFJFQ0FURURfVFJBTlNMQVRFRCc7XG5leHBvcnRzWzEzMTddID0gJ0VSX1FVRVJZX0lOVEVSUlVQVEVEJztcbmV4cG9ydHNbMTMxOF0gPSAnRVJfU1BfV1JPTkdfTk9fT0ZfQVJHUyc7XG5leHBvcnRzWzEzMTldID0gJ0VSX1NQX0NPTkRfTUlTTUFUQ0gnO1xuZXhwb3J0c1sxMzIwXSA9ICdFUl9TUF9OT1JFVFVSTic7XG5leHBvcnRzWzEzMjFdID0gJ0VSX1NQX05PUkVUVVJORU5EJztcbmV4cG9ydHNbMTMyMl0gPSAnRVJfU1BfQkFEX0NVUlNPUl9RVUVSWSc7XG5leHBvcnRzWzEzMjNdID0gJ0VSX1NQX0JBRF9DVVJTT1JfU0VMRUNUJztcbmV4cG9ydHNbMTMyNF0gPSAnRVJfU1BfQ1VSU09SX01JU01BVENIJztcbmV4cG9ydHNbMTMyNV0gPSAnRVJfU1BfQ1VSU09SX0FMUkVBRFlfT1BFTic7XG5leHBvcnRzWzEzMjZdID0gJ0VSX1NQX0NVUlNPUl9OT1RfT1BFTic7XG5leHBvcnRzWzEzMjddID0gJ0VSX1NQX1VOREVDTEFSRURfVkFSJztcbmV4cG9ydHNbMTMyOF0gPSAnRVJfU1BfV1JPTkdfTk9fT0ZfRkVUQ0hfQVJHUyc7XG5leHBvcnRzWzEzMjldID0gJ0VSX1NQX0ZFVENIX05PX0RBVEEnO1xuZXhwb3J0c1sxMzMwXSA9ICdFUl9TUF9EVVBfUEFSQU0nO1xuZXhwb3J0c1sxMzMxXSA9ICdFUl9TUF9EVVBfVkFSJztcbmV4cG9ydHNbMTMzMl0gPSAnRVJfU1BfRFVQX0NPTkQnO1xuZXhwb3J0c1sxMzMzXSA9ICdFUl9TUF9EVVBfQ1VSUyc7XG5leHBvcnRzWzEzMzRdID0gJ0VSX1NQX0NBTlRfQUxURVInO1xuZXhwb3J0c1sxMzM1XSA9ICdFUl9TUF9TVUJTRUxFQ1RfTllJJztcbmV4cG9ydHNbMTMzNl0gPSAnRVJfU1RNVF9OT1RfQUxMT1dFRF9JTl9TRl9PUl9UUkcnO1xuZXhwb3J0c1sxMzM3XSA9ICdFUl9TUF9WQVJDT05EX0FGVEVSX0NVUlNITkRMUic7XG5leHBvcnRzWzEzMzhdID0gJ0VSX1NQX0NVUlNPUl9BRlRFUl9IQU5ETEVSJztcbmV4cG9ydHNbMTMzOV0gPSAnRVJfU1BfQ0FTRV9OT1RfRk9VTkQnO1xuZXhwb3J0c1sxMzQwXSA9ICdFUl9GUEFSU0VSX1RPT19CSUdfRklMRSc7XG5leHBvcnRzWzEzNDFdID0gJ0VSX0ZQQVJTRVJfQkFEX0hFQURFUic7XG5leHBvcnRzWzEzNDJdID0gJ0VSX0ZQQVJTRVJfRU9GX0lOX0NPTU1FTlQnO1xuZXhwb3J0c1sxMzQzXSA9ICdFUl9GUEFSU0VSX0VSUk9SX0lOX1BBUkFNRVRFUic7XG5leHBvcnRzWzEzNDRdID0gJ0VSX0ZQQVJTRVJfRU9GX0lOX1VOS05PV05fUEFSQU1FVEVSJztcbmV4cG9ydHNbMTM0NV0gPSAnRVJfVklFV19OT19FWFBMQUlOJztcbmV4cG9ydHNbMTM0Nl0gPSAnRVJfRlJNX1VOS05PV05fVFlQRSc7XG5leHBvcnRzWzEzNDddID0gJ0VSX1dST05HX09CSkVDVCc7XG5leHBvcnRzWzEzNDhdID0gJ0VSX05PTlVQREFURUFCTEVfQ09MVU1OJztcbmV4cG9ydHNbMTM0OV0gPSAnRVJfVklFV19TRUxFQ1RfREVSSVZFRCc7XG5leHBvcnRzWzEzNTBdID0gJ0VSX1ZJRVdfU0VMRUNUX0NMQVVTRSc7XG5leHBvcnRzWzEzNTFdID0gJ0VSX1ZJRVdfU0VMRUNUX1ZBUklBQkxFJztcbmV4cG9ydHNbMTM1Ml0gPSAnRVJfVklFV19TRUxFQ1RfVE1QVEFCTEUnO1xuZXhwb3J0c1sxMzUzXSA9ICdFUl9WSUVXX1dST05HX0xJU1QnO1xuZXhwb3J0c1sxMzU0XSA9ICdFUl9XQVJOX1ZJRVdfTUVSR0UnO1xuZXhwb3J0c1sxMzU1XSA9ICdFUl9XQVJOX1ZJRVdfV0lUSE9VVF9LRVknO1xuZXhwb3J0c1sxMzU2XSA9ICdFUl9WSUVXX0lOVkFMSUQnO1xuZXhwb3J0c1sxMzU3XSA9ICdFUl9TUF9OT19EUk9QX1NQJztcbmV4cG9ydHNbMTM1OF0gPSAnRVJfU1BfR09UT19JTl9ITkRMUic7XG5leHBvcnRzWzEzNTldID0gJ0VSX1RSR19BTFJFQURZX0VYSVNUUyc7XG5leHBvcnRzWzEzNjBdID0gJ0VSX1RSR19ET0VTX05PVF9FWElTVCc7XG5leHBvcnRzWzEzNjFdID0gJ0VSX1RSR19PTl9WSUVXX09SX1RFTVBfVEFCTEUnO1xuZXhwb3J0c1sxMzYyXSA9ICdFUl9UUkdfQ0FOVF9DSEFOR0VfUk9XJztcbmV4cG9ydHNbMTM2M10gPSAnRVJfVFJHX05PX1NVQ0hfUk9XX0lOX1RSRyc7XG5leHBvcnRzWzEzNjRdID0gJ0VSX05PX0RFRkFVTFRfRk9SX0ZJRUxEJztcbmV4cG9ydHNbMTM2NV0gPSAnRVJfRElWSVNJT05fQllfWkVSTyc7XG5leHBvcnRzWzEzNjZdID0gJ0VSX1RSVU5DQVRFRF9XUk9OR19WQUxVRV9GT1JfRklFTEQnO1xuZXhwb3J0c1sxMzY3XSA9ICdFUl9JTExFR0FMX1ZBTFVFX0ZPUl9UWVBFJztcbmV4cG9ydHNbMTM2OF0gPSAnRVJfVklFV19OT05VUERfQ0hFQ0snO1xuZXhwb3J0c1sxMzY5XSA9ICdFUl9WSUVXX0NIRUNLX0ZBSUxFRCc7XG5leHBvcnRzWzEzNzBdID0gJ0VSX1BST0NBQ0NFU1NfREVOSUVEX0VSUk9SJztcbmV4cG9ydHNbMTM3MV0gPSAnRVJfUkVMQVlfTE9HX0ZBSUwnO1xuZXhwb3J0c1sxMzcyXSA9ICdFUl9QQVNTV0RfTEVOR1RIJztcbmV4cG9ydHNbMTM3M10gPSAnRVJfVU5LTk9XTl9UQVJHRVRfQklOTE9HJztcbmV4cG9ydHNbMTM3NF0gPSAnRVJfSU9fRVJSX0xPR19JTkRFWF9SRUFEJztcbmV4cG9ydHNbMTM3NV0gPSAnRVJfQklOTE9HX1BVUkdFX1BST0hJQklURUQnO1xuZXhwb3J0c1sxMzc2XSA9ICdFUl9GU0VFS19GQUlMJztcbmV4cG9ydHNbMTM3N10gPSAnRVJfQklOTE9HX1BVUkdFX0ZBVEFMX0VSUic7XG5leHBvcnRzWzEzNzhdID0gJ0VSX0xPR19JTl9VU0UnO1xuZXhwb3J0c1sxMzc5XSA9ICdFUl9MT0dfUFVSR0VfVU5LTk9XTl9FUlInO1xuZXhwb3J0c1sxMzgwXSA9ICdFUl9SRUxBWV9MT0dfSU5JVCc7XG5leHBvcnRzWzEzODFdID0gJ0VSX05PX0JJTkFSWV9MT0dHSU5HJztcbmV4cG9ydHNbMTM4Ml0gPSAnRVJfUkVTRVJWRURfU1lOVEFYJztcbmV4cG9ydHNbMTM4M10gPSAnRVJfV1NBU19GQUlMRUQnO1xuZXhwb3J0c1sxMzg0XSA9ICdFUl9ESUZGX0dST1VQU19QUk9DJztcbmV4cG9ydHNbMTM4NV0gPSAnRVJfTk9fR1JPVVBfRk9SX1BST0MnO1xuZXhwb3J0c1sxMzg2XSA9ICdFUl9PUkRFUl9XSVRIX1BST0MnO1xuZXhwb3J0c1sxMzg3XSA9ICdFUl9MT0dHSU5HX1BST0hJQklUX0NIQU5HSU5HX09GJztcbmV4cG9ydHNbMTM4OF0gPSAnRVJfTk9fRklMRV9NQVBQSU5HJztcbmV4cG9ydHNbMTM4OV0gPSAnRVJfV1JPTkdfTUFHSUMnO1xuZXhwb3J0c1sxMzkwXSA9ICdFUl9QU19NQU5ZX1BBUkFNJztcbmV4cG9ydHNbMTM5MV0gPSAnRVJfS0VZX1BBUlRfMCc7XG5leHBvcnRzWzEzOTJdID0gJ0VSX1ZJRVdfQ0hFQ0tTVU0nO1xuZXhwb3J0c1sxMzkzXSA9ICdFUl9WSUVXX01VTFRJVVBEQVRFJztcbmV4cG9ydHNbMTM5NF0gPSAnRVJfVklFV19OT19JTlNFUlRfRklFTERfTElTVCc7XG5leHBvcnRzWzEzOTVdID0gJ0VSX1ZJRVdfREVMRVRFX01FUkdFX1ZJRVcnO1xuZXhwb3J0c1sxMzk2XSA9ICdFUl9DQU5OT1RfVVNFUic7XG5leHBvcnRzWzEzOTddID0gJ0VSX1hBRVJfTk9UQSc7XG5leHBvcnRzWzEzOThdID0gJ0VSX1hBRVJfSU5WQUwnO1xuZXhwb3J0c1sxMzk5XSA9ICdFUl9YQUVSX1JNRkFJTCc7XG5leHBvcnRzWzE0MDBdID0gJ0VSX1hBRVJfT1VUU0lERSc7XG5leHBvcnRzWzE0MDFdID0gJ0VSX1hBRVJfUk1FUlInO1xuZXhwb3J0c1sxNDAyXSA9ICdFUl9YQV9SQlJPTExCQUNLJztcbmV4cG9ydHNbMTQwM10gPSAnRVJfTk9ORVhJU1RJTkdfUFJPQ19HUkFOVCc7XG5leHBvcnRzWzE0MDRdID0gJ0VSX1BST0NfQVVUT19HUkFOVF9GQUlMJztcbmV4cG9ydHNbMTQwNV0gPSAnRVJfUFJPQ19BVVRPX1JFVk9LRV9GQUlMJztcbmV4cG9ydHNbMTQwNl0gPSAnRVJfREFUQV9UT09fTE9ORyc7XG5leHBvcnRzWzE0MDddID0gJ0VSX1NQX0JBRF9TUUxTVEFURSc7XG5leHBvcnRzWzE0MDhdID0gJ0VSX1NUQVJUVVAnO1xuZXhwb3J0c1sxNDA5XSA9ICdFUl9MT0FEX0ZST01fRklYRURfU0laRV9ST1dTX1RPX1ZBUic7XG5leHBvcnRzWzE0MTBdID0gJ0VSX0NBTlRfQ1JFQVRFX1VTRVJfV0lUSF9HUkFOVCc7XG5leHBvcnRzWzE0MTFdID0gJ0VSX1dST05HX1ZBTFVFX0ZPUl9UWVBFJztcbmV4cG9ydHNbMTQxMl0gPSAnRVJfVEFCTEVfREVGX0NIQU5HRUQnO1xuZXhwb3J0c1sxNDEzXSA9ICdFUl9TUF9EVVBfSEFORExFUic7XG5leHBvcnRzWzE0MTRdID0gJ0VSX1NQX05PVF9WQVJfQVJHJztcbmV4cG9ydHNbMTQxNV0gPSAnRVJfU1BfTk9fUkVUU0VUJztcbmV4cG9ydHNbMTQxNl0gPSAnRVJfQ0FOVF9DUkVBVEVfR0VPTUVUUllfT0JKRUNUJztcbmV4cG9ydHNbMTQxN10gPSAnRVJfRkFJTEVEX1JPVVRJTkVfQlJFQUtfQklOTE9HJztcbmV4cG9ydHNbMTQxOF0gPSAnRVJfQklOTE9HX1VOU0FGRV9ST1VUSU5FJztcbmV4cG9ydHNbMTQxOV0gPSAnRVJfQklOTE9HX0NSRUFURV9ST1VUSU5FX05FRURfU1VQRVInO1xuZXhwb3J0c1sxNDIwXSA9ICdFUl9FWEVDX1NUTVRfV0lUSF9PUEVOX0NVUlNPUic7XG5leHBvcnRzWzE0MjFdID0gJ0VSX1NUTVRfSEFTX05PX09QRU5fQ1VSU09SJztcbmV4cG9ydHNbMTQyMl0gPSAnRVJfQ09NTUlUX05PVF9BTExPV0VEX0lOX1NGX09SX1RSRyc7XG5leHBvcnRzWzE0MjNdID0gJ0VSX05PX0RFRkFVTFRfRk9SX1ZJRVdfRklFTEQnO1xuZXhwb3J0c1sxNDI0XSA9ICdFUl9TUF9OT19SRUNVUlNJT04nO1xuZXhwb3J0c1sxNDI1XSA9ICdFUl9UT09fQklHX1NDQUxFJztcbmV4cG9ydHNbMTQyNl0gPSAnRVJfVE9PX0JJR19QUkVDSVNJT04nO1xuZXhwb3J0c1sxNDI3XSA9ICdFUl9NX0JJR0dFUl9USEFOX0QnO1xuZXhwb3J0c1sxNDI4XSA9ICdFUl9XUk9OR19MT0NLX09GX1NZU1RFTV9UQUJMRSc7XG5leHBvcnRzWzE0MjldID0gJ0VSX0NPTk5FQ1RfVE9fRk9SRUlHTl9EQVRBX1NPVVJDRSc7XG5leHBvcnRzWzE0MzBdID0gJ0VSX1FVRVJZX09OX0ZPUkVJR05fREFUQV9TT1VSQ0UnO1xuZXhwb3J0c1sxNDMxXSA9ICdFUl9GT1JFSUdOX0RBVEFfU09VUkNFX0RPRVNOVF9FWElTVCc7XG5leHBvcnRzWzE0MzJdID0gJ0VSX0ZPUkVJR05fREFUQV9TVFJJTkdfSU5WQUxJRF9DQU5UX0NSRUFURSc7XG5leHBvcnRzWzE0MzNdID0gJ0VSX0ZPUkVJR05fREFUQV9TVFJJTkdfSU5WQUxJRCc7XG5leHBvcnRzWzE0MzRdID0gJ0VSX0NBTlRfQ1JFQVRFX0ZFREVSQVRFRF9UQUJMRSc7XG5leHBvcnRzWzE0MzVdID0gJ0VSX1RSR19JTl9XUk9OR19TQ0hFTUEnO1xuZXhwb3J0c1sxNDM2XSA9ICdFUl9TVEFDS19PVkVSUlVOX05FRURfTU9SRSc7XG5leHBvcnRzWzE0MzddID0gJ0VSX1RPT19MT05HX0JPRFknO1xuZXhwb3J0c1sxNDM4XSA9ICdFUl9XQVJOX0NBTlRfRFJPUF9ERUZBVUxUX0tFWUNBQ0hFJztcbmV4cG9ydHNbMTQzOV0gPSAnRVJfVE9PX0JJR19ESVNQTEFZV0lEVEgnO1xuZXhwb3J0c1sxNDQwXSA9ICdFUl9YQUVSX0RVUElEJztcbmV4cG9ydHNbMTQ0MV0gPSAnRVJfREFURVRJTUVfRlVOQ1RJT05fT1ZFUkZMT1cnO1xuZXhwb3J0c1sxNDQyXSA9ICdFUl9DQU5UX1VQREFURV9VU0VEX1RBQkxFX0lOX1NGX09SX1RSRyc7XG5leHBvcnRzWzE0NDNdID0gJ0VSX1ZJRVdfUFJFVkVOVF9VUERBVEUnO1xuZXhwb3J0c1sxNDQ0XSA9ICdFUl9QU19OT19SRUNVUlNJT04nO1xuZXhwb3J0c1sxNDQ1XSA9ICdFUl9TUF9DQU5UX1NFVF9BVVRPQ09NTUlUJztcbmV4cG9ydHNbMTQ0Nl0gPSAnRVJfTUFMRk9STUVEX0RFRklORVInO1xuZXhwb3J0c1sxNDQ3XSA9ICdFUl9WSUVXX0ZSTV9OT19VU0VSJztcbmV4cG9ydHNbMTQ0OF0gPSAnRVJfVklFV19PVEhFUl9VU0VSJztcbmV4cG9ydHNbMTQ0OV0gPSAnRVJfTk9fU1VDSF9VU0VSJztcbmV4cG9ydHNbMTQ1MF0gPSAnRVJfRk9SQklEX1NDSEVNQV9DSEFOR0UnO1xuZXhwb3J0c1sxNDUxXSA9ICdFUl9ST1dfSVNfUkVGRVJFTkNFRF8yJztcbmV4cG9ydHNbMTQ1Ml0gPSAnRVJfTk9fUkVGRVJFTkNFRF9ST1dfMic7XG5leHBvcnRzWzE0NTNdID0gJ0VSX1NQX0JBRF9WQVJfU0hBRE9XJztcbmV4cG9ydHNbMTQ1NF0gPSAnRVJfVFJHX05PX0RFRklORVInO1xuZXhwb3J0c1sxNDU1XSA9ICdFUl9PTERfRklMRV9GT1JNQVQnO1xuZXhwb3J0c1sxNDU2XSA9ICdFUl9TUF9SRUNVUlNJT05fTElNSVQnO1xuZXhwb3J0c1sxNDU3XSA9ICdFUl9TUF9QUk9DX1RBQkxFX0NPUlJVUFQnO1xuZXhwb3J0c1sxNDU4XSA9ICdFUl9TUF9XUk9OR19OQU1FJztcbmV4cG9ydHNbMTQ1OV0gPSAnRVJfVEFCTEVfTkVFRFNfVVBHUkFERSc7XG5leHBvcnRzWzE0NjBdID0gJ0VSX1NQX05PX0FHR1JFR0FURSc7XG5leHBvcnRzWzE0NjFdID0gJ0VSX01BWF9QUkVQQVJFRF9TVE1UX0NPVU5UX1JFQUNIRUQnO1xuZXhwb3J0c1sxNDYyXSA9ICdFUl9WSUVXX1JFQ1VSU0lWRSc7XG5leHBvcnRzWzE0NjNdID0gJ0VSX05PTl9HUk9VUElOR19GSUVMRF9VU0VEJztcbmV4cG9ydHNbMTQ2NF0gPSAnRVJfVEFCTEVfQ0FOVF9IQU5ETEVfU1BLRVlTJztcbmV4cG9ydHNbMTQ2NV0gPSAnRVJfTk9fVFJJR0dFUlNfT05fU1lTVEVNX1NDSEVNQSc7XG5leHBvcnRzWzE0NjZdID0gJ0VSX1JFTU9WRURfU1BBQ0VTJztcbmV4cG9ydHNbMTQ2N10gPSAnRVJfQVVUT0lOQ19SRUFEX0ZBSUxFRCc7XG5leHBvcnRzWzE0NjhdID0gJ0VSX1VTRVJOQU1FJztcbmV4cG9ydHNbMTQ2OV0gPSAnRVJfSE9TVE5BTUUnO1xuZXhwb3J0c1sxNDcwXSA9ICdFUl9XUk9OR19TVFJJTkdfTEVOR1RIJztcbmV4cG9ydHNbMTQ3MV0gPSAnRVJfTk9OX0lOU0VSVEFCTEVfVEFCTEUnO1xuZXhwb3J0c1sxNDcyXSA9ICdFUl9BRE1JTl9XUk9OR19NUkdfVEFCTEUnO1xuZXhwb3J0c1sxNDczXSA9ICdFUl9UT09fSElHSF9MRVZFTF9PRl9ORVNUSU5HX0ZPUl9TRUxFQ1QnO1xuZXhwb3J0c1sxNDc0XSA9ICdFUl9OQU1FX0JFQ09NRVNfRU1QVFknO1xuZXhwb3J0c1sxNDc1XSA9ICdFUl9BTUJJR1VPVVNfRklFTERfVEVSTSc7XG5leHBvcnRzWzE0NzZdID0gJ0VSX0ZPUkVJR05fU0VSVkVSX0VYSVNUUyc7XG5leHBvcnRzWzE0NzddID0gJ0VSX0ZPUkVJR05fU0VSVkVSX0RPRVNOVF9FWElTVCc7XG5leHBvcnRzWzE0NzhdID0gJ0VSX0lMTEVHQUxfSEFfQ1JFQVRFX09QVElPTic7XG5leHBvcnRzWzE0NzldID0gJ0VSX1BBUlRJVElPTl9SRVFVSVJFU19WQUxVRVNfRVJST1InO1xuZXhwb3J0c1sxNDgwXSA9ICdFUl9QQVJUSVRJT05fV1JPTkdfVkFMVUVTX0VSUk9SJztcbmV4cG9ydHNbMTQ4MV0gPSAnRVJfUEFSVElUSU9OX01BWFZBTFVFX0VSUk9SJztcbmV4cG9ydHNbMTQ4Ml0gPSAnRVJfUEFSVElUSU9OX1NVQlBBUlRJVElPTl9FUlJPUic7XG5leHBvcnRzWzE0ODNdID0gJ0VSX1BBUlRJVElPTl9TVUJQQVJUX01JWF9FUlJPUic7XG5leHBvcnRzWzE0ODRdID0gJ0VSX1BBUlRJVElPTl9XUk9OR19OT19QQVJUX0VSUk9SJztcbmV4cG9ydHNbMTQ4NV0gPSAnRVJfUEFSVElUSU9OX1dST05HX05PX1NVQlBBUlRfRVJST1InO1xuZXhwb3J0c1sxNDg2XSA9ICdFUl9XUk9OR19FWFBSX0lOX1BBUlRJVElPTl9GVU5DX0VSUk9SJztcbmV4cG9ydHNbMTQ4N10gPSAnRVJfTk9fQ09OU1RfRVhQUl9JTl9SQU5HRV9PUl9MSVNUX0VSUk9SJztcbmV4cG9ydHNbMTQ4OF0gPSAnRVJfRklFTERfTk9UX0ZPVU5EX1BBUlRfRVJST1InO1xuZXhwb3J0c1sxNDg5XSA9ICdFUl9MSVNUX09GX0ZJRUxEU19PTkxZX0lOX0hBU0hfRVJST1InO1xuZXhwb3J0c1sxNDkwXSA9ICdFUl9JTkNPTlNJU1RFTlRfUEFSVElUSU9OX0lORk9fRVJST1InO1xuZXhwb3J0c1sxNDkxXSA9ICdFUl9QQVJUSVRJT05fRlVOQ19OT1RfQUxMT1dFRF9FUlJPUic7XG5leHBvcnRzWzE0OTJdID0gJ0VSX1BBUlRJVElPTlNfTVVTVF9CRV9ERUZJTkVEX0VSUk9SJztcbmV4cG9ydHNbMTQ5M10gPSAnRVJfUkFOR0VfTk9UX0lOQ1JFQVNJTkdfRVJST1InO1xuZXhwb3J0c1sxNDk0XSA9ICdFUl9JTkNPTlNJU1RFTlRfVFlQRV9PRl9GVU5DVElPTlNfRVJST1InO1xuZXhwb3J0c1sxNDk1XSA9ICdFUl9NVUxUSVBMRV9ERUZfQ09OU1RfSU5fTElTVF9QQVJUX0VSUk9SJztcbmV4cG9ydHNbMTQ5Nl0gPSAnRVJfUEFSVElUSU9OX0VOVFJZX0VSUk9SJztcbmV4cG9ydHNbMTQ5N10gPSAnRVJfTUlYX0hBTkRMRVJfRVJST1InO1xuZXhwb3J0c1sxNDk4XSA9ICdFUl9QQVJUSVRJT05fTk9UX0RFRklORURfRVJST1InO1xuZXhwb3J0c1sxNDk5XSA9ICdFUl9UT09fTUFOWV9QQVJUSVRJT05TX0VSUk9SJztcbmV4cG9ydHNbMTUwMF0gPSAnRVJfU1VCUEFSVElUSU9OX0VSUk9SJztcbmV4cG9ydHNbMTUwMV0gPSAnRVJfQ0FOVF9DUkVBVEVfSEFORExFUl9GSUxFJztcbmV4cG9ydHNbMTUwMl0gPSAnRVJfQkxPQl9GSUVMRF9JTl9QQVJUX0ZVTkNfRVJST1InO1xuZXhwb3J0c1sxNTAzXSA9ICdFUl9VTklRVUVfS0VZX05FRURfQUxMX0ZJRUxEU19JTl9QRic7XG5leHBvcnRzWzE1MDRdID0gJ0VSX05PX1BBUlRTX0VSUk9SJztcbmV4cG9ydHNbMTUwNV0gPSAnRVJfUEFSVElUSU9OX01HTVRfT05fTk9OUEFSVElUSU9ORUQnO1xuZXhwb3J0c1sxNTA2XSA9ICdFUl9GT1JFSUdOX0tFWV9PTl9QQVJUSVRJT05FRCc7XG5leHBvcnRzWzE1MDddID0gJ0VSX0RST1BfUEFSVElUSU9OX05PTl9FWElTVEVOVCc7XG5leHBvcnRzWzE1MDhdID0gJ0VSX0RST1BfTEFTVF9QQVJUSVRJT04nO1xuZXhwb3J0c1sxNTA5XSA9ICdFUl9DT0FMRVNDRV9PTkxZX09OX0hBU0hfUEFSVElUSU9OJztcbmV4cG9ydHNbMTUxMF0gPSAnRVJfUkVPUkdfSEFTSF9PTkxZX09OX1NBTUVfTk8nO1xuZXhwb3J0c1sxNTExXSA9ICdFUl9SRU9SR19OT19QQVJBTV9FUlJPUic7XG5leHBvcnRzWzE1MTJdID0gJ0VSX09OTFlfT05fUkFOR0VfTElTVF9QQVJUSVRJT04nO1xuZXhwb3J0c1sxNTEzXSA9ICdFUl9BRERfUEFSVElUSU9OX1NVQlBBUlRfRVJST1InO1xuZXhwb3J0c1sxNTE0XSA9ICdFUl9BRERfUEFSVElUSU9OX05PX05FV19QQVJUSVRJT04nO1xuZXhwb3J0c1sxNTE1XSA9ICdFUl9DT0FMRVNDRV9QQVJUSVRJT05fTk9fUEFSVElUSU9OJztcbmV4cG9ydHNbMTUxNl0gPSAnRVJfUkVPUkdfUEFSVElUSU9OX05PVF9FWElTVCc7XG5leHBvcnRzWzE1MTddID0gJ0VSX1NBTUVfTkFNRV9QQVJUSVRJT04nO1xuZXhwb3J0c1sxNTE4XSA9ICdFUl9OT19CSU5MT0dfRVJST1InO1xuZXhwb3J0c1sxNTE5XSA9ICdFUl9DT05TRUNVVElWRV9SRU9SR19QQVJUSVRJT05TJztcbmV4cG9ydHNbMTUyMF0gPSAnRVJfUkVPUkdfT1VUU0lERV9SQU5HRSc7XG5leHBvcnRzWzE1MjFdID0gJ0VSX1BBUlRJVElPTl9GVU5DVElPTl9GQUlMVVJFJztcbmV4cG9ydHNbMTUyMl0gPSAnRVJfUEFSVF9TVEFURV9FUlJPUic7XG5leHBvcnRzWzE1MjNdID0gJ0VSX0xJTUlURURfUEFSVF9SQU5HRSc7XG5leHBvcnRzWzE1MjRdID0gJ0VSX1BMVUdJTl9JU19OT1RfTE9BREVEJztcbmV4cG9ydHNbMTUyNV0gPSAnRVJfV1JPTkdfVkFMVUUnO1xuZXhwb3J0c1sxNTI2XSA9ICdFUl9OT19QQVJUSVRJT05fRk9SX0dJVkVOX1ZBTFVFJztcbmV4cG9ydHNbMTUyN10gPSAnRVJfRklMRUdST1VQX09QVElPTl9PTkxZX09OQ0UnO1xuZXhwb3J0c1sxNTI4XSA9ICdFUl9DUkVBVEVfRklMRUdST1VQX0ZBSUxFRCc7XG5leHBvcnRzWzE1MjldID0gJ0VSX0RST1BfRklMRUdST1VQX0ZBSUxFRCc7XG5leHBvcnRzWzE1MzBdID0gJ0VSX1RBQkxFU1BBQ0VfQVVUT19FWFRFTkRfRVJST1InO1xuZXhwb3J0c1sxNTMxXSA9ICdFUl9XUk9OR19TSVpFX05VTUJFUic7XG5leHBvcnRzWzE1MzJdID0gJ0VSX1NJWkVfT1ZFUkZMT1dfRVJST1InO1xuZXhwb3J0c1sxNTMzXSA9ICdFUl9BTFRFUl9GSUxFR1JPVVBfRkFJTEVEJztcbmV4cG9ydHNbMTUzNF0gPSAnRVJfQklOTE9HX1JPV19MT0dHSU5HX0ZBSUxFRCc7XG5leHBvcnRzWzE1MzVdID0gJ0VSX0JJTkxPR19ST1dfV1JPTkdfVEFCTEVfREVGJztcbmV4cG9ydHNbMTUzNl0gPSAnRVJfQklOTE9HX1JPV19SQlJfVE9fU0JSJztcbmV4cG9ydHNbMTUzN10gPSAnRVJfRVZFTlRfQUxSRUFEWV9FWElTVFMnO1xuZXhwb3J0c1sxNTM4XSA9ICdFUl9FVkVOVF9TVE9SRV9GQUlMRUQnO1xuZXhwb3J0c1sxNTM5XSA9ICdFUl9FVkVOVF9ET0VTX05PVF9FWElTVCc7XG5leHBvcnRzWzE1NDBdID0gJ0VSX0VWRU5UX0NBTlRfQUxURVInO1xuZXhwb3J0c1sxNTQxXSA9ICdFUl9FVkVOVF9EUk9QX0ZBSUxFRCc7XG5leHBvcnRzWzE1NDJdID0gJ0VSX0VWRU5UX0lOVEVSVkFMX05PVF9QT1NJVElWRV9PUl9UT09fQklHJztcbmV4cG9ydHNbMTU0M10gPSAnRVJfRVZFTlRfRU5EU19CRUZPUkVfU1RBUlRTJztcbmV4cG9ydHNbMTU0NF0gPSAnRVJfRVZFTlRfRVhFQ19USU1FX0lOX1RIRV9QQVNUJztcbmV4cG9ydHNbMTU0NV0gPSAnRVJfRVZFTlRfT1BFTl9UQUJMRV9GQUlMRUQnO1xuZXhwb3J0c1sxNTQ2XSA9ICdFUl9FVkVOVF9ORUlUSEVSX01fRVhQUl9OT1JfTV9BVCc7XG5leHBvcnRzWzE1NDddID0gJ0VSX0NPTF9DT1VOVF9ET0VTTlRfTUFUQ0hfQ09SUlVQVEVEJztcbmV4cG9ydHNbMTU0OF0gPSAnRVJfQ0FOTk9UX0xPQURfRlJPTV9UQUJMRSc7XG5leHBvcnRzWzE1NDldID0gJ0VSX0VWRU5UX0NBTk5PVF9ERUxFVEUnO1xuZXhwb3J0c1sxNTUwXSA9ICdFUl9FVkVOVF9DT01QSUxFX0VSUk9SJztcbmV4cG9ydHNbMTU1MV0gPSAnRVJfRVZFTlRfU0FNRV9OQU1FJztcbmV4cG9ydHNbMTU1Ml0gPSAnRVJfRVZFTlRfREFUQV9UT09fTE9ORyc7XG5leHBvcnRzWzE1NTNdID0gJ0VSX0RST1BfSU5ERVhfRksnO1xuZXhwb3J0c1sxNTU0XSA9ICdFUl9XQVJOX0RFUFJFQ0FURURfU1lOVEFYX1dJVEhfVkVSJztcbmV4cG9ydHNbMTU1NV0gPSAnRVJfQ0FOVF9XUklURV9MT0NLX0xPR19UQUJMRSc7XG5leHBvcnRzWzE1NTZdID0gJ0VSX0NBTlRfTE9DS19MT0dfVEFCTEUnO1xuZXhwb3J0c1sxNTU3XSA9ICdFUl9GT1JFSUdOX0RVUExJQ0FURV9LRVknO1xuZXhwb3J0c1sxNTU4XSA9ICdFUl9DT0xfQ09VTlRfRE9FU05UX01BVENIX1BMRUFTRV9VUERBVEUnO1xuZXhwb3J0c1sxNTU5XSA9ICdFUl9URU1QX1RBQkxFX1BSRVZFTlRTX1NXSVRDSF9PVVRfT0ZfUkJSJztcbmV4cG9ydHNbMTU2MF0gPSAnRVJfU1RPUkVEX0ZVTkNUSU9OX1BSRVZFTlRTX1NXSVRDSF9CSU5MT0dfRk9STUFUJztcbmV4cG9ydHNbMTU2MV0gPSAnRVJfTkRCX0NBTlRfU1dJVENIX0JJTkxPR19GT1JNQVQnO1xuZXhwb3J0c1sxNTYyXSA9ICdFUl9QQVJUSVRJT05fTk9fVEVNUE9SQVJZJztcbmV4cG9ydHNbMTU2M10gPSAnRVJfUEFSVElUSU9OX0NPTlNUX0RPTUFJTl9FUlJPUic7XG5leHBvcnRzWzE1NjRdID0gJ0VSX1BBUlRJVElPTl9GVU5DVElPTl9JU19OT1RfQUxMT1dFRCc7XG5leHBvcnRzWzE1NjVdID0gJ0VSX0RETF9MT0dfRVJST1InO1xuZXhwb3J0c1sxNTY2XSA9ICdFUl9OVUxMX0lOX1ZBTFVFU19MRVNTX1RIQU4nO1xuZXhwb3J0c1sxNTY3XSA9ICdFUl9XUk9OR19QQVJUSVRJT05fTkFNRSc7XG5leHBvcnRzWzE1NjhdID0gJ0VSX0NBTlRfQ0hBTkdFX1RYX0NIQVJBQ1RFUklTVElDUyc7XG5leHBvcnRzWzE1NjldID0gJ0VSX0RVUF9FTlRSWV9BVVRPSU5DUkVNRU5UX0NBU0UnO1xuZXhwb3J0c1sxNTcwXSA9ICdFUl9FVkVOVF9NT0RJRllfUVVFVUVfRVJST1InO1xuZXhwb3J0c1sxNTcxXSA9ICdFUl9FVkVOVF9TRVRfVkFSX0VSUk9SJztcbmV4cG9ydHNbMTU3Ml0gPSAnRVJfUEFSVElUSU9OX01FUkdFX0VSUk9SJztcbmV4cG9ydHNbMTU3M10gPSAnRVJfQ0FOVF9BQ1RJVkFURV9MT0cnO1xuZXhwb3J0c1sxNTc0XSA9ICdFUl9SQlJfTk9UX0FWQUlMQUJMRSc7XG5leHBvcnRzWzE1NzVdID0gJ0VSX0JBU0U2NF9ERUNPREVfRVJST1InO1xuZXhwb3J0c1sxNTc2XSA9ICdFUl9FVkVOVF9SRUNVUlNJT05fRk9SQklEREVOJztcbmV4cG9ydHNbMTU3N10gPSAnRVJfRVZFTlRTX0RCX0VSUk9SJztcbmV4cG9ydHNbMTU3OF0gPSAnRVJfT05MWV9JTlRFR0VSU19BTExPV0VEJztcbmV4cG9ydHNbMTU3OV0gPSAnRVJfVU5TVVBPUlRFRF9MT0dfRU5HSU5FJztcbmV4cG9ydHNbMTU4MF0gPSAnRVJfQkFEX0xPR19TVEFURU1FTlQnO1xuZXhwb3J0c1sxNTgxXSA9ICdFUl9DQU5UX1JFTkFNRV9MT0dfVEFCTEUnO1xuZXhwb3J0c1sxNTgyXSA9ICdFUl9XUk9OR19QQVJBTUNPVU5UX1RPX05BVElWRV9GQ1QnO1xuZXhwb3J0c1sxNTgzXSA9ICdFUl9XUk9OR19QQVJBTUVURVJTX1RPX05BVElWRV9GQ1QnO1xuZXhwb3J0c1sxNTg0XSA9ICdFUl9XUk9OR19QQVJBTUVURVJTX1RPX1NUT1JFRF9GQ1QnO1xuZXhwb3J0c1sxNTg1XSA9ICdFUl9OQVRJVkVfRkNUX05BTUVfQ09MTElTSU9OJztcbmV4cG9ydHNbMTU4Nl0gPSAnRVJfRFVQX0VOVFJZX1dJVEhfS0VZX05BTUUnO1xuZXhwb3J0c1sxNTg3XSA9ICdFUl9CSU5MT0dfUFVSR0VfRU1GSUxFJztcbmV4cG9ydHNbMTU4OF0gPSAnRVJfRVZFTlRfQ0FOTk9UX0NSRUFURV9JTl9USEVfUEFTVCc7XG5leHBvcnRzWzE1ODldID0gJ0VSX0VWRU5UX0NBTk5PVF9BTFRFUl9JTl9USEVfUEFTVCc7XG5leHBvcnRzWzE1OTBdID0gJ0VSX1NMQVZFX0lOQ0lERU5UJztcbmV4cG9ydHNbMTU5MV0gPSAnRVJfTk9fUEFSVElUSU9OX0ZPUl9HSVZFTl9WQUxVRV9TSUxFTlQnO1xuZXhwb3J0c1sxNTkyXSA9ICdFUl9CSU5MT0dfVU5TQUZFX1NUQVRFTUVOVCc7XG5leHBvcnRzWzE1OTNdID0gJ0VSX1NMQVZFX0ZBVEFMX0VSUk9SJztcbmV4cG9ydHNbMTU5NF0gPSAnRVJfU0xBVkVfUkVMQVlfTE9HX1JFQURfRkFJTFVSRSc7XG5leHBvcnRzWzE1OTVdID0gJ0VSX1NMQVZFX1JFTEFZX0xPR19XUklURV9GQUlMVVJFJztcbmV4cG9ydHNbMTU5Nl0gPSAnRVJfU0xBVkVfQ1JFQVRFX0VWRU5UX0ZBSUxVUkUnO1xuZXhwb3J0c1sxNTk3XSA9ICdFUl9TTEFWRV9NQVNURVJfQ09NX0ZBSUxVUkUnO1xuZXhwb3J0c1sxNTk4XSA9ICdFUl9CSU5MT0dfTE9HR0lOR19JTVBPU1NJQkxFJztcbmV4cG9ydHNbMTU5OV0gPSAnRVJfVklFV19OT19DUkVBVElPTl9DVFgnO1xuZXhwb3J0c1sxNjAwXSA9ICdFUl9WSUVXX0lOVkFMSURfQ1JFQVRJT05fQ1RYJztcbmV4cG9ydHNbMTYwMV0gPSAnRVJfU1JfSU5WQUxJRF9DUkVBVElPTl9DVFgnO1xuZXhwb3J0c1sxNjAyXSA9ICdFUl9UUkdfQ09SUlVQVEVEX0ZJTEUnO1xuZXhwb3J0c1sxNjAzXSA9ICdFUl9UUkdfTk9fQ1JFQVRJT05fQ1RYJztcbmV4cG9ydHNbMTYwNF0gPSAnRVJfVFJHX0lOVkFMSURfQ1JFQVRJT05fQ1RYJztcbmV4cG9ydHNbMTYwNV0gPSAnRVJfRVZFTlRfSU5WQUxJRF9DUkVBVElPTl9DVFgnO1xuZXhwb3J0c1sxNjA2XSA9ICdFUl9UUkdfQ0FOVF9PUEVOX1RBQkxFJztcbmV4cG9ydHNbMTYwN10gPSAnRVJfQ0FOVF9DUkVBVEVfU1JPVVRJTkUnO1xuZXhwb3J0c1sxNjA4XSA9ICdFUl9ORVZFUl9VU0VEJztcbmV4cG9ydHNbMTYwOV0gPSAnRVJfTk9fRk9STUFUX0RFU0NSSVBUSU9OX0VWRU5UX0JFRk9SRV9CSU5MT0dfU1RBVEVNRU5UJztcbmV4cG9ydHNbMTYxMF0gPSAnRVJfU0xBVkVfQ09SUlVQVF9FVkVOVCc7XG5leHBvcnRzWzE2MTFdID0gJ0VSX0xPQURfREFUQV9JTlZBTElEX0NPTFVNTic7XG5leHBvcnRzWzE2MTJdID0gJ0VSX0xPR19QVVJHRV9OT19GSUxFJztcbmV4cG9ydHNbMTYxM10gPSAnRVJfWEFfUkJUSU1FT1VUJztcbmV4cG9ydHNbMTYxNF0gPSAnRVJfWEFfUkJERUFETE9DSyc7XG5leHBvcnRzWzE2MTVdID0gJ0VSX05FRURfUkVQUkVQQVJFJztcbmV4cG9ydHNbMTYxNl0gPSAnRVJfREVMQVlFRF9OT1RfU1VQUE9SVEVEJztcbmV4cG9ydHNbMTYxN10gPSAnV0FSTl9OT19NQVNURVJfSU5GTyc7XG5leHBvcnRzWzE2MThdID0gJ1dBUk5fT1BUSU9OX0lHTk9SRUQnO1xuZXhwb3J0c1sxNjE5XSA9ICdXQVJOX1BMVUdJTl9ERUxFVEVfQlVJTFRJTic7XG5leHBvcnRzWzE2MjBdID0gJ1dBUk5fUExVR0lOX0JVU1knO1xuZXhwb3J0c1sxNjIxXSA9ICdFUl9WQVJJQUJMRV9JU19SRUFET05MWSc7XG5leHBvcnRzWzE2MjJdID0gJ0VSX1dBUk5fRU5HSU5FX1RSQU5TQUNUSU9OX1JPTExCQUNLJztcbmV4cG9ydHNbMTYyM10gPSAnRVJfU0xBVkVfSEVBUlRCRUFUX0ZBSUxVUkUnO1xuZXhwb3J0c1sxNjI0XSA9ICdFUl9TTEFWRV9IRUFSVEJFQVRfVkFMVUVfT1VUX09GX1JBTkdFJztcbmV4cG9ydHNbMTYyNV0gPSAnRVJfTkRCX1JFUExJQ0FUSU9OX1NDSEVNQV9FUlJPUic7XG5leHBvcnRzWzE2MjZdID0gJ0VSX0NPTkZMSUNUX0ZOX1BBUlNFX0VSUk9SJztcbmV4cG9ydHNbMTYyN10gPSAnRVJfRVhDRVBUSU9OU19XUklURV9FUlJPUic7XG5leHBvcnRzWzE2MjhdID0gJ0VSX1RPT19MT05HX1RBQkxFX0NPTU1FTlQnO1xuZXhwb3J0c1sxNjI5XSA9ICdFUl9UT09fTE9OR19GSUVMRF9DT01NRU5UJztcbmV4cG9ydHNbMTYzMF0gPSAnRVJfRlVOQ19JTkVYSVNURU5UX05BTUVfQ09MTElTSU9OJztcbmV4cG9ydHNbMTYzMV0gPSAnRVJfREFUQUJBU0VfTkFNRSc7XG5leHBvcnRzWzE2MzJdID0gJ0VSX1RBQkxFX05BTUUnO1xuZXhwb3J0c1sxNjMzXSA9ICdFUl9QQVJUSVRJT05fTkFNRSc7XG5leHBvcnRzWzE2MzRdID0gJ0VSX1NVQlBBUlRJVElPTl9OQU1FJztcbmV4cG9ydHNbMTYzNV0gPSAnRVJfVEVNUE9SQVJZX05BTUUnO1xuZXhwb3J0c1sxNjM2XSA9ICdFUl9SRU5BTUVEX05BTUUnO1xuZXhwb3J0c1sxNjM3XSA9ICdFUl9UT09fTUFOWV9DT05DVVJSRU5UX1RSWFMnO1xuZXhwb3J0c1sxNjM4XSA9ICdXQVJOX05PTl9BU0NJSV9TRVBBUkFUT1JfTk9UX0lNUExFTUVOVEVEJztcbmV4cG9ydHNbMTYzOV0gPSAnRVJfREVCVUdfU1lOQ19USU1FT1VUJztcbmV4cG9ydHNbMTY0MF0gPSAnRVJfREVCVUdfU1lOQ19ISVRfTElNSVQnO1xuZXhwb3J0c1sxNjQxXSA9ICdFUl9EVVBfU0lHTkFMX1NFVCc7XG5leHBvcnRzWzE2NDJdID0gJ0VSX1NJR05BTF9XQVJOJztcbmV4cG9ydHNbMTY0M10gPSAnRVJfU0lHTkFMX05PVF9GT1VORCc7XG5leHBvcnRzWzE2NDRdID0gJ0VSX1NJR05BTF9FWENFUFRJT04nO1xuZXhwb3J0c1sxNjQ1XSA9ICdFUl9SRVNJR05BTF9XSVRIT1VUX0FDVElWRV9IQU5ETEVSJztcbmV4cG9ydHNbMTY0Nl0gPSAnRVJfU0lHTkFMX0JBRF9DT05ESVRJT05fVFlQRSc7XG5leHBvcnRzWzE2NDddID0gJ1dBUk5fQ09ORF9JVEVNX1RSVU5DQVRFRCc7XG5leHBvcnRzWzE2NDhdID0gJ0VSX0NPTkRfSVRFTV9UT09fTE9ORyc7XG5leHBvcnRzWzE2NDldID0gJ0VSX1VOS05PV05fTE9DQUxFJztcbmV4cG9ydHNbMTY1MF0gPSAnRVJfU0xBVkVfSUdOT1JFX1NFUlZFUl9JRFMnO1xuZXhwb3J0c1sxNjUxXSA9ICdFUl9RVUVSWV9DQUNIRV9ESVNBQkxFRCc7XG5leHBvcnRzWzE2NTJdID0gJ0VSX1NBTUVfTkFNRV9QQVJUSVRJT05fRklFTEQnO1xuZXhwb3J0c1sxNjUzXSA9ICdFUl9QQVJUSVRJT05fQ09MVU1OX0xJU1RfRVJST1InO1xuZXhwb3J0c1sxNjU0XSA9ICdFUl9XUk9OR19UWVBFX0NPTFVNTl9WQUxVRV9FUlJPUic7XG5leHBvcnRzWzE2NTVdID0gJ0VSX1RPT19NQU5ZX1BBUlRJVElPTl9GVU5DX0ZJRUxEU19FUlJPUic7XG5leHBvcnRzWzE2NTZdID0gJ0VSX01BWFZBTFVFX0lOX1ZBTFVFU19JTic7XG5leHBvcnRzWzE2NTddID0gJ0VSX1RPT19NQU5ZX1ZBTFVFU19FUlJPUic7XG5leHBvcnRzWzE2NThdID0gJ0VSX1JPV19TSU5HTEVfUEFSVElUSU9OX0ZJRUxEX0VSUk9SJztcbmV4cG9ydHNbMTY1OV0gPSAnRVJfRklFTERfVFlQRV9OT1RfQUxMT1dFRF9BU19QQVJUSVRJT05fRklFTEQnO1xuZXhwb3J0c1sxNjYwXSA9ICdFUl9QQVJUSVRJT05fRklFTERTX1RPT19MT05HJztcbmV4cG9ydHNbMTY2MV0gPSAnRVJfQklOTE9HX1JPV19FTkdJTkVfQU5EX1NUTVRfRU5HSU5FJztcbmV4cG9ydHNbMTY2Ml0gPSAnRVJfQklOTE9HX1JPV19NT0RFX0FORF9TVE1UX0VOR0lORSc7XG5leHBvcnRzWzE2NjNdID0gJ0VSX0JJTkxPR19VTlNBRkVfQU5EX1NUTVRfRU5HSU5FJztcbmV4cG9ydHNbMTY2NF0gPSAnRVJfQklOTE9HX1JPV19JTkpFQ1RJT05fQU5EX1NUTVRfRU5HSU5FJztcbmV4cG9ydHNbMTY2NV0gPSAnRVJfQklOTE9HX1NUTVRfTU9ERV9BTkRfUk9XX0VOR0lORSc7XG5leHBvcnRzWzE2NjZdID0gJ0VSX0JJTkxPR19ST1dfSU5KRUNUSU9OX0FORF9TVE1UX01PREUnO1xuZXhwb3J0c1sxNjY3XSA9ICdFUl9CSU5MT0dfTVVMVElQTEVfRU5HSU5FU19BTkRfU0VMRl9MT0dHSU5HX0VOR0lORSc7XG5leHBvcnRzWzE2NjhdID0gJ0VSX0JJTkxPR19VTlNBRkVfTElNSVQnO1xuZXhwb3J0c1sxNjY5XSA9ICdFUl9CSU5MT0dfVU5TQUZFX0lOU0VSVF9ERUxBWUVEJztcbmV4cG9ydHNbMTY3MF0gPSAnRVJfQklOTE9HX1VOU0FGRV9TWVNURU1fVEFCTEUnO1xuZXhwb3J0c1sxNjcxXSA9ICdFUl9CSU5MT0dfVU5TQUZFX0FVVE9JTkNfQ09MVU1OUyc7XG5leHBvcnRzWzE2NzJdID0gJ0VSX0JJTkxPR19VTlNBRkVfVURGJztcbmV4cG9ydHNbMTY3M10gPSAnRVJfQklOTE9HX1VOU0FGRV9TWVNURU1fVkFSSUFCTEUnO1xuZXhwb3J0c1sxNjc0XSA9ICdFUl9CSU5MT0dfVU5TQUZFX1NZU1RFTV9GVU5DVElPTic7XG5leHBvcnRzWzE2NzVdID0gJ0VSX0JJTkxPR19VTlNBRkVfTk9OVFJBTlNfQUZURVJfVFJBTlMnO1xuZXhwb3J0c1sxNjc2XSA9ICdFUl9NRVNTQUdFX0FORF9TVEFURU1FTlQnO1xuZXhwb3J0c1sxNjc3XSA9ICdFUl9TTEFWRV9DT05WRVJTSU9OX0ZBSUxFRCc7XG5leHBvcnRzWzE2NzhdID0gJ0VSX1NMQVZFX0NBTlRfQ1JFQVRFX0NPTlZFUlNJT04nO1xuZXhwb3J0c1sxNjc5XSA9ICdFUl9JTlNJREVfVFJBTlNBQ1RJT05fUFJFVkVOVFNfU1dJVENIX0JJTkxPR19GT1JNQVQnO1xuZXhwb3J0c1sxNjgwXSA9ICdFUl9QQVRIX0xFTkdUSCc7XG5leHBvcnRzWzE2ODFdID0gJ0VSX1dBUk5fREVQUkVDQVRFRF9TWU5UQVhfTk9fUkVQTEFDRU1FTlQnO1xuZXhwb3J0c1sxNjgyXSA9ICdFUl9XUk9OR19OQVRJVkVfVEFCTEVfU1RSVUNUVVJFJztcbmV4cG9ydHNbMTY4M10gPSAnRVJfV1JPTkdfUEVSRlNDSEVNQV9VU0FHRSc7XG5leHBvcnRzWzE2ODRdID0gJ0VSX1dBUk5fSV9TX1NLSVBQRURfVEFCTEUnO1xuZXhwb3J0c1sxNjg1XSA9ICdFUl9JTlNJREVfVFJBTlNBQ1RJT05fUFJFVkVOVFNfU1dJVENIX0JJTkxPR19ESVJFQ1QnO1xuZXhwb3J0c1sxNjg2XSA9ICdFUl9TVE9SRURfRlVOQ1RJT05fUFJFVkVOVFNfU1dJVENIX0JJTkxPR19ESVJFQ1QnO1xuZXhwb3J0c1sxNjg3XSA9ICdFUl9TUEFUSUFMX01VU1RfSEFWRV9HRU9NX0NPTCc7XG5leHBvcnRzWzE2ODhdID0gJ0VSX1RPT19MT05HX0lOREVYX0NPTU1FTlQnO1xuZXhwb3J0c1sxNjg5XSA9ICdFUl9MT0NLX0FCT1JURUQnO1xuZXhwb3J0c1sxNjkwXSA9ICdFUl9EQVRBX09VVF9PRl9SQU5HRSc7XG5leHBvcnRzWzE2OTFdID0gJ0VSX1dST05HX1NQVkFSX1RZUEVfSU5fTElNSVQnO1xuZXhwb3J0c1sxNjkyXSA9ICdFUl9CSU5MT0dfVU5TQUZFX01VTFRJUExFX0VOR0lORVNfQU5EX1NFTEZfTE9HR0lOR19FTkdJTkUnO1xuZXhwb3J0c1sxNjkzXSA9ICdFUl9CSU5MT0dfVU5TQUZFX01JWEVEX1NUQVRFTUVOVCc7XG5leHBvcnRzWzE2OTRdID0gJ0VSX0lOU0lERV9UUkFOU0FDVElPTl9QUkVWRU5UU19TV0lUQ0hfU1FMX0xPR19CSU4nO1xuZXhwb3J0c1sxNjk1XSA9ICdFUl9TVE9SRURfRlVOQ1RJT05fUFJFVkVOVFNfU1dJVENIX1NRTF9MT0dfQklOJztcbmV4cG9ydHNbMTY5Nl0gPSAnRVJfRkFJTEVEX1JFQURfRlJPTV9QQVJfRklMRSc7XG5leHBvcnRzWzE2OTddID0gJ0VSX1ZBTFVFU19JU19OT1RfSU5UX1RZUEVfRVJST1InO1xuZXhwb3J0c1sxNjk4XSA9ICdFUl9BQ0NFU1NfREVOSUVEX05PX1BBU1NXT1JEX0VSUk9SJztcbmV4cG9ydHNbMTY5OV0gPSAnRVJfU0VUX1BBU1NXT1JEX0FVVEhfUExVR0lOJztcbmV4cG9ydHNbMTcwMF0gPSAnRVJfR1JBTlRfUExVR0lOX1VTRVJfRVhJU1RTJztcbmV4cG9ydHNbMTcwMV0gPSAnRVJfVFJVTkNBVEVfSUxMRUdBTF9GSyc7XG5leHBvcnRzWzE3MDJdID0gJ0VSX1BMVUdJTl9JU19QRVJNQU5FTlQnO1xuZXhwb3J0c1sxNzAzXSA9ICdFUl9TTEFWRV9IRUFSVEJFQVRfVkFMVUVfT1VUX09GX1JBTkdFX01JTic7XG5leHBvcnRzWzE3MDRdID0gJ0VSX1NMQVZFX0hFQVJUQkVBVF9WQUxVRV9PVVRfT0ZfUkFOR0VfTUFYJztcbmV4cG9ydHNbMTcwNV0gPSAnRVJfU1RNVF9DQUNIRV9GVUxMJztcbmV4cG9ydHNbMTcwNl0gPSAnRVJfTVVMVElfVVBEQVRFX0tFWV9DT05GTElDVCc7XG5leHBvcnRzWzE3MDddID0gJ0VSX1RBQkxFX05FRURTX1JFQlVJTEQnO1xuZXhwb3J0c1sxNzA4XSA9ICdXQVJOX09QVElPTl9CRUxPV19MSU1JVCc7XG5leHBvcnRzWzE3MDldID0gJ0VSX0lOREVYX0NPTFVNTl9UT09fTE9ORyc7XG5leHBvcnRzWzE3MTBdID0gJ0VSX0VSUk9SX0lOX1RSSUdHRVJfQk9EWSc7XG5leHBvcnRzWzE3MTFdID0gJ0VSX0VSUk9SX0lOX1VOS05PV05fVFJJR0dFUl9CT0RZJztcbmV4cG9ydHNbMTcxMl0gPSAnRVJfSU5ERVhfQ09SUlVQVCc7XG5leHBvcnRzWzE3MTNdID0gJ0VSX1VORE9fUkVDT1JEX1RPT19CSUcnO1xuZXhwb3J0c1sxNzE0XSA9ICdFUl9CSU5MT0dfVU5TQUZFX0lOU0VSVF9JR05PUkVfU0VMRUNUJztcbmV4cG9ydHNbMTcxNV0gPSAnRVJfQklOTE9HX1VOU0FGRV9JTlNFUlRfU0VMRUNUX1VQREFURSc7XG5leHBvcnRzWzE3MTZdID0gJ0VSX0JJTkxPR19VTlNBRkVfUkVQTEFDRV9TRUxFQ1QnO1xuZXhwb3J0c1sxNzE3XSA9ICdFUl9CSU5MT0dfVU5TQUZFX0NSRUFURV9JR05PUkVfU0VMRUNUJztcbmV4cG9ydHNbMTcxOF0gPSAnRVJfQklOTE9HX1VOU0FGRV9DUkVBVEVfUkVQTEFDRV9TRUxFQ1QnO1xuZXhwb3J0c1sxNzE5XSA9ICdFUl9CSU5MT0dfVU5TQUZFX1VQREFURV9JR05PUkUnO1xuZXhwb3J0c1sxNzIwXSA9ICdFUl9QTFVHSU5fTk9fVU5JTlNUQUxMJztcbmV4cG9ydHNbMTcyMV0gPSAnRVJfUExVR0lOX05PX0lOU1RBTEwnO1xuZXhwb3J0c1sxNzIyXSA9ICdFUl9CSU5MT0dfVU5TQUZFX1dSSVRFX0FVVE9JTkNfU0VMRUNUJztcbmV4cG9ydHNbMTcyM10gPSAnRVJfQklOTE9HX1VOU0FGRV9DUkVBVEVfU0VMRUNUX0FVVE9JTkMnO1xuZXhwb3J0c1sxNzI0XSA9ICdFUl9CSU5MT0dfVU5TQUZFX0lOU0VSVF9UV09fS0VZUyc7XG5leHBvcnRzWzE3MjVdID0gJ0VSX1RBQkxFX0lOX0ZLX0NIRUNLJztcbmV4cG9ydHNbMTcyNl0gPSAnRVJfVU5TVVBQT1JURURfRU5HSU5FJztcbmV4cG9ydHNbMTcyN10gPSAnRVJfQklOTE9HX1VOU0FGRV9BVVRPSU5DX05PVF9GSVJTVCc7XG5leHBvcnRzWzE3MjhdID0gJ0VSX0NBTk5PVF9MT0FEX0ZST01fVEFCTEVfVjInO1xuZXhwb3J0c1sxNzI5XSA9ICdFUl9NQVNURVJfREVMQVlfVkFMVUVfT1VUX09GX1JBTkdFJztcbmV4cG9ydHNbMTczMF0gPSAnRVJfT05MWV9GRF9BTkRfUkJSX0VWRU5UU19BTExPV0VEX0lOX0JJTkxPR19TVEFURU1FTlQnO1xuZXhwb3J0c1sxNzMxXSA9ICdFUl9QQVJUSVRJT05fRVhDSEFOR0VfRElGRkVSRU5UX09QVElPTic7XG5leHBvcnRzWzE3MzJdID0gJ0VSX1BBUlRJVElPTl9FWENIQU5HRV9QQVJUX1RBQkxFJztcbmV4cG9ydHNbMTczM10gPSAnRVJfUEFSVElUSU9OX0VYQ0hBTkdFX1RFTVBfVEFCTEUnO1xuZXhwb3J0c1sxNzM0XSA9ICdFUl9QQVJUSVRJT05fSU5TVEVBRF9PRl9TVUJQQVJUSVRJT04nO1xuZXhwb3J0c1sxNzM1XSA9ICdFUl9VTktOT1dOX1BBUlRJVElPTic7XG5leHBvcnRzWzE3MzZdID0gJ0VSX1RBQkxFU19ESUZGRVJFTlRfTUVUQURBVEEnO1xuZXhwb3J0c1sxNzM3XSA9ICdFUl9ST1dfRE9FU19OT1RfTUFUQ0hfUEFSVElUSU9OJztcbmV4cG9ydHNbMTczOF0gPSAnRVJfQklOTE9HX0NBQ0hFX1NJWkVfR1JFQVRFUl9USEFOX01BWCc7XG5leHBvcnRzWzE3MzldID0gJ0VSX1dBUk5fSU5ERVhfTk9UX0FQUExJQ0FCTEUnO1xuZXhwb3J0c1sxNzQwXSA9ICdFUl9QQVJUSVRJT05fRVhDSEFOR0VfRk9SRUlHTl9LRVknO1xuZXhwb3J0c1sxNzQxXSA9ICdFUl9OT19TVUNIX0tFWV9WQUxVRSc7XG5leHBvcnRzWzE3NDJdID0gJ0VSX1JQTF9JTkZPX0RBVEFfVE9PX0xPTkcnO1xuZXhwb3J0c1sxNzQzXSA9ICdFUl9ORVRXT1JLX1JFQURfRVZFTlRfQ0hFQ0tTVU1fRkFJTFVSRSc7XG5leHBvcnRzWzE3NDRdID0gJ0VSX0JJTkxPR19SRUFEX0VWRU5UX0NIRUNLU1VNX0ZBSUxVUkUnO1xuZXhwb3J0c1sxNzQ1XSA9ICdFUl9CSU5MT0dfU1RNVF9DQUNIRV9TSVpFX0dSRUFURVJfVEhBTl9NQVgnO1xuZXhwb3J0c1sxNzQ2XSA9ICdFUl9DQU5UX1VQREFURV9UQUJMRV9JTl9DUkVBVEVfVEFCTEVfU0VMRUNUJztcbmV4cG9ydHNbMTc0N10gPSAnRVJfUEFSVElUSU9OX0NMQVVTRV9PTl9OT05QQVJUSVRJT05FRCc7XG5leHBvcnRzWzE3NDhdID0gJ0VSX1JPV19ET0VTX05PVF9NQVRDSF9HSVZFTl9QQVJUSVRJT05fU0VUJztcbmV4cG9ydHNbMTc0OV0gPSAnRVJfTk9fU1VDSF9QQVJUSVRJT04nO1xuZXhwb3J0c1sxNzUwXSA9ICdFUl9DSEFOR0VfUlBMX0lORk9fUkVQT1NJVE9SWV9GQUlMVVJFJztcbmV4cG9ydHNbMTc1MV0gPSAnRVJfV0FSTklOR19OT1RfQ09NUExFVEVfUk9MTEJBQ0tfV0lUSF9DUkVBVEVEX1RFTVBfVEFCTEUnO1xuZXhwb3J0c1sxNzUyXSA9ICdFUl9XQVJOSU5HX05PVF9DT01QTEVURV9ST0xMQkFDS19XSVRIX0RST1BQRURfVEVNUF9UQUJMRSc7XG5leHBvcnRzWzE3NTNdID0gJ0VSX01UU19GRUFUVVJFX0lTX05PVF9TVVBQT1JURUQnO1xuZXhwb3J0c1sxNzU0XSA9ICdFUl9NVFNfVVBEQVRFRF9EQlNfR1JFQVRFUl9NQVgnO1xuZXhwb3J0c1sxNzU1XSA9ICdFUl9NVFNfQ0FOVF9QQVJBTExFTCc7XG5leHBvcnRzWzE3NTZdID0gJ0VSX01UU19JTkNPTlNJU1RFTlRfREFUQSc7XG5leHBvcnRzWzE3NTddID0gJ0VSX0ZVTExURVhUX05PVF9TVVBQT1JURURfV0lUSF9QQVJUSVRJT05JTkcnO1xuZXhwb3J0c1sxNzU4XSA9ICdFUl9EQV9JTlZBTElEX0NPTkRJVElPTl9OVU1CRVInO1xuZXhwb3J0c1sxNzU5XSA9ICdFUl9JTlNFQ1VSRV9QTEFJTl9URVhUJztcbmV4cG9ydHNbMTc2MF0gPSAnRVJfSU5TRUNVUkVfQ0hBTkdFX01BU1RFUic7XG5leHBvcnRzWzE3NjFdID0gJ0VSX0ZPUkVJR05fRFVQTElDQVRFX0tFWV9XSVRIX0NISUxEX0lORk8nO1xuZXhwb3J0c1sxNzYyXSA9ICdFUl9GT1JFSUdOX0RVUExJQ0FURV9LRVlfV0lUSE9VVF9DSElMRF9JTkZPJztcbmV4cG9ydHNbMTc2M10gPSAnRVJfU1FMVEhSRUFEX1dJVEhfU0VDVVJFX1NMQVZFJztcbmV4cG9ydHNbMTc2NF0gPSAnRVJfVEFCTEVfSEFTX05PX0ZUJztcbmV4cG9ydHNbMTc2NV0gPSAnRVJfVkFSSUFCTEVfTk9UX1NFVFRBQkxFX0lOX1NGX09SX1RSSUdHRVInO1xuZXhwb3J0c1sxNzY2XSA9ICdFUl9WQVJJQUJMRV9OT1RfU0VUVEFCTEVfSU5fVFJBTlNBQ1RJT04nO1xuZXhwb3J0c1sxNzY3XSA9ICdFUl9HVElEX05FWFRfSVNfTk9UX0lOX0dUSURfTkVYVF9MSVNUJztcbmV4cG9ydHNbMTc2OF0gPSAnRVJfQ0FOVF9DSEFOR0VfR1RJRF9ORVhUX0lOX1RSQU5TQUNUSU9OX1dIRU5fR1RJRF9ORVhUX0xJU1RfSVNfTlVMTCc7XG5leHBvcnRzWzE3NjldID0gJ0VSX1NFVF9TVEFURU1FTlRfQ0FOTk9UX0lOVk9LRV9GVU5DVElPTic7XG5leHBvcnRzWzE3NzBdID0gJ0VSX0dUSURfTkVYVF9DQU5UX0JFX0FVVE9NQVRJQ19JRl9HVElEX05FWFRfTElTVF9JU19OT05fTlVMTCc7XG5leHBvcnRzWzE3NzFdID0gJ0VSX1NLSVBQSU5HX0xPR0dFRF9UUkFOU0FDVElPTic7XG5leHBvcnRzWzE3NzJdID0gJ0VSX01BTEZPUk1FRF9HVElEX1NFVF9TUEVDSUZJQ0FUSU9OJztcbmV4cG9ydHNbMTc3M10gPSAnRVJfTUFMRk9STUVEX0dUSURfU0VUX0VOQ09ESU5HJztcbmV4cG9ydHNbMTc3NF0gPSAnRVJfTUFMRk9STUVEX0dUSURfU1BFQ0lGSUNBVElPTic7XG5leHBvcnRzWzE3NzVdID0gJ0VSX0dOT19FWEhBVVNURUQnO1xuZXhwb3J0c1sxNzc2XSA9ICdFUl9CQURfU0xBVkVfQVVUT19QT1NJVElPTic7XG5leHBvcnRzWzE3NzddID0gJ0VSX0FVVE9fUE9TSVRJT05fUkVRVUlSRVNfR1RJRF9NT0RFX09OJztcbmV4cG9ydHNbMTc3OF0gPSAnRVJfQ0FOVF9ET19JTVBMSUNJVF9DT01NSVRfSU5fVFJYX1dIRU5fR1RJRF9ORVhUX0lTX1NFVCc7XG5leHBvcnRzWzE3NzldID0gJ0VSX0dUSURfTU9ERV8yX09SXzNfUkVRVUlSRVNfRU5GT1JDRV9HVElEX0NPTlNJU1RFTkNZX09OJztcbmV4cG9ydHNbMTc4MF0gPSAnRVJfR1RJRF9NT0RFX1JFUVVJUkVTX0JJTkxPRyc7XG5leHBvcnRzWzE3ODFdID0gJ0VSX0NBTlRfU0VUX0dUSURfTkVYVF9UT19HVElEX1dIRU5fR1RJRF9NT0RFX0lTX09GRic7XG5leHBvcnRzWzE3ODJdID0gJ0VSX0NBTlRfU0VUX0dUSURfTkVYVF9UT19BTk9OWU1PVVNfV0hFTl9HVElEX01PREVfSVNfT04nO1xuZXhwb3J0c1sxNzgzXSA9ICdFUl9DQU5UX1NFVF9HVElEX05FWFRfTElTVF9UT19OT05fTlVMTF9XSEVOX0dUSURfTU9ERV9JU19PRkYnO1xuZXhwb3J0c1sxNzg0XSA9ICdFUl9GT1VORF9HVElEX0VWRU5UX1dIRU5fR1RJRF9NT0RFX0lTX09GRic7XG5leHBvcnRzWzE3ODVdID0gJ0VSX0dUSURfVU5TQUZFX05PTl9UUkFOU0FDVElPTkFMX1RBQkxFJztcbmV4cG9ydHNbMTc4Nl0gPSAnRVJfR1RJRF9VTlNBRkVfQ1JFQVRFX1NFTEVDVCc7XG5leHBvcnRzWzE3ODddID0gJ0VSX0dUSURfVU5TQUZFX0NSRUFURV9EUk9QX1RFTVBPUkFSWV9UQUJMRV9JTl9UUkFOU0FDVElPTic7XG5leHBvcnRzWzE3ODhdID0gJ0VSX0dUSURfTU9ERV9DQU5fT05MWV9DSEFOR0VfT05FX1NURVBfQVRfQV9USU1FJztcbmV4cG9ydHNbMTc4OV0gPSAnRVJfTUFTVEVSX0hBU19QVVJHRURfUkVRVUlSRURfR1RJRFMnO1xuZXhwb3J0c1sxNzkwXSA9ICdFUl9DQU5UX1NFVF9HVElEX05FWFRfV0hFTl9PV05JTkdfR1RJRCc7XG5leHBvcnRzWzE3OTFdID0gJ0VSX1VOS05PV05fRVhQTEFJTl9GT1JNQVQnO1xuZXhwb3J0c1sxNzkyXSA9ICdFUl9DQU5UX0VYRUNVVEVfSU5fUkVBRF9PTkxZX1RSQU5TQUNUSU9OJztcbmV4cG9ydHNbMTc5M10gPSAnRVJfVE9PX0xPTkdfVEFCTEVfUEFSVElUSU9OX0NPTU1FTlQnO1xuZXhwb3J0c1sxNzk0XSA9ICdFUl9TTEFWRV9DT05GSUdVUkFUSU9OJztcbmV4cG9ydHNbMTc5NV0gPSAnRVJfSU5OT0RCX0ZUX0xJTUlUJztcbmV4cG9ydHNbMTc5Nl0gPSAnRVJfSU5OT0RCX05PX0ZUX1RFTVBfVEFCTEUnO1xuZXhwb3J0c1sxNzk3XSA9ICdFUl9JTk5PREJfRlRfV1JPTkdfRE9DSURfQ09MVU1OJztcbmV4cG9ydHNbMTc5OF0gPSAnRVJfSU5OT0RCX0ZUX1dST05HX0RPQ0lEX0lOREVYJztcbmV4cG9ydHNbMTc5OV0gPSAnRVJfSU5OT0RCX09OTElORV9MT0dfVE9PX0JJRyc7XG5leHBvcnRzWzE4MDBdID0gJ0VSX1VOS05PV05fQUxURVJfQUxHT1JJVEhNJztcbmV4cG9ydHNbMTgwMV0gPSAnRVJfVU5LTk9XTl9BTFRFUl9MT0NLJztcbmV4cG9ydHNbMTgwMl0gPSAnRVJfTVRTX0NIQU5HRV9NQVNURVJfQ0FOVF9SVU5fV0lUSF9HQVBTJztcbmV4cG9ydHNbMTgwM10gPSAnRVJfTVRTX1JFQ09WRVJZX0ZBSUxVUkUnO1xuZXhwb3J0c1sxODA0XSA9ICdFUl9NVFNfUkVTRVRfV09SS0VSUyc7XG5leHBvcnRzWzE4MDVdID0gJ0VSX0NPTF9DT1VOVF9ET0VTTlRfTUFUQ0hfQ09SUlVQVEVEX1YyJztcbmV4cG9ydHNbMTgwNl0gPSAnRVJfU0xBVkVfU0lMRU5UX1JFVFJZX1RSQU5TQUNUSU9OJztcbmV4cG9ydHNbMTgwN10gPSAnRVJfRElTQ0FSRF9GS19DSEVDS1NfUlVOTklORyc7XG5leHBvcnRzWzE4MDhdID0gJ0VSX1RBQkxFX1NDSEVNQV9NSVNNQVRDSCc7XG5leHBvcnRzWzE4MDldID0gJ0VSX1RBQkxFX0lOX1NZU1RFTV9UQUJMRVNQQUNFJztcbmV4cG9ydHNbMTgxMF0gPSAnRVJfSU9fUkVBRF9FUlJPUic7XG5leHBvcnRzWzE4MTFdID0gJ0VSX0lPX1dSSVRFX0VSUk9SJztcbmV4cG9ydHNbMTgxMl0gPSAnRVJfVEFCTEVTUEFDRV9NSVNTSU5HJztcbmV4cG9ydHNbMTgxM10gPSAnRVJfVEFCTEVTUEFDRV9FWElTVFMnO1xuZXhwb3J0c1sxODE0XSA9ICdFUl9UQUJMRVNQQUNFX0RJU0NBUkRFRCc7XG5leHBvcnRzWzE4MTVdID0gJ0VSX0lOVEVSTkFMX0VSUk9SJztcbmV4cG9ydHNbMTgxNl0gPSAnRVJfSU5OT0RCX0lNUE9SVF9FUlJPUic7XG5leHBvcnRzWzE4MTddID0gJ0VSX0lOTk9EQl9JTkRFWF9DT1JSVVBUJztcbmV4cG9ydHNbMTgxOF0gPSAnRVJfSU5WQUxJRF9ZRUFSX0NPTFVNTl9MRU5HVEgnO1xuZXhwb3J0c1sxODE5XSA9ICdFUl9OT1RfVkFMSURfUEFTU1dPUkQnO1xuZXhwb3J0c1sxODIwXSA9ICdFUl9NVVNUX0NIQU5HRV9QQVNTV09SRCc7XG5leHBvcnRzWzE4MjFdID0gJ0VSX0ZLX05PX0lOREVYX0NISUxEJztcbmV4cG9ydHNbMTgyMl0gPSAnRVJfRktfTk9fSU5ERVhfUEFSRU5UJztcbmV4cG9ydHNbMTgyM10gPSAnRVJfRktfRkFJTF9BRERfU1lTVEVNJztcbmV4cG9ydHNbMTgyNF0gPSAnRVJfRktfQ0FOTk9UX09QRU5fUEFSRU5UJztcbmV4cG9ydHNbMTgyNV0gPSAnRVJfRktfSU5DT1JSRUNUX09QVElPTic7XG5leHBvcnRzWzE4MjZdID0gJ0VSX0ZLX0RVUF9OQU1FJztcbmV4cG9ydHNbMTgyN10gPSAnRVJfUEFTU1dPUkRfRk9STUFUJztcbmV4cG9ydHNbMTgyOF0gPSAnRVJfRktfQ09MVU1OX0NBTk5PVF9EUk9QJztcbmV4cG9ydHNbMTgyOV0gPSAnRVJfRktfQ09MVU1OX0NBTk5PVF9EUk9QX0NISUxEJztcbmV4cG9ydHNbMTgzMF0gPSAnRVJfRktfQ09MVU1OX05PVF9OVUxMJztcbmV4cG9ydHNbMTgzMV0gPSAnRVJfRFVQX0lOREVYJztcbmV4cG9ydHNbMTgzMl0gPSAnRVJfRktfQ09MVU1OX0NBTk5PVF9DSEFOR0UnO1xuZXhwb3J0c1sxODMzXSA9ICdFUl9GS19DT0xVTU5fQ0FOTk9UX0NIQU5HRV9DSElMRCc7XG5leHBvcnRzWzE4MzRdID0gJ0VSX0ZLX0NBTk5PVF9ERUxFVEVfUEFSRU5UJztcbmV4cG9ydHNbMTgzNV0gPSAnRVJfTUFMRk9STUVEX1BBQ0tFVCc7XG5leHBvcnRzWzE4MzZdID0gJ0VSX1JFQURfT05MWV9NT0RFJztcbmV4cG9ydHNbMTgzN10gPSAnRVJfR1RJRF9ORVhUX1RZUEVfVU5ERUZJTkVEX0dST1VQJztcbmV4cG9ydHNbMTgzOF0gPSAnRVJfVkFSSUFCTEVfTk9UX1NFVFRBQkxFX0lOX1NQJztcbmV4cG9ydHNbMTgzOV0gPSAnRVJfQ0FOVF9TRVRfR1RJRF9QVVJHRURfV0hFTl9HVElEX01PREVfSVNfT0ZGJztcbmV4cG9ydHNbMTg0MF0gPSAnRVJfQ0FOVF9TRVRfR1RJRF9QVVJHRURfV0hFTl9HVElEX0VYRUNVVEVEX0lTX05PVF9FTVBUWSc7XG5leHBvcnRzWzE4NDFdID0gJ0VSX0NBTlRfU0VUX0dUSURfUFVSR0VEX1dIRU5fT1dORURfR1RJRFNfSVNfTk9UX0VNUFRZJztcbmV4cG9ydHNbMTg0Ml0gPSAnRVJfR1RJRF9QVVJHRURfV0FTX0NIQU5HRUQnO1xuZXhwb3J0c1sxODQzXSA9ICdFUl9HVElEX0VYRUNVVEVEX1dBU19DSEFOR0VEJztcbmV4cG9ydHNbMTg0NF0gPSAnRVJfQklOTE9HX1NUTVRfTU9ERV9BTkRfTk9fUkVQTF9UQUJMRVMnO1xuZXhwb3J0c1sxODQ1XSA9ICdFUl9BTFRFUl9PUEVSQVRJT05fTk9UX1NVUFBPUlRFRCc7XG5leHBvcnRzWzE4NDZdID0gJ0VSX0FMVEVSX09QRVJBVElPTl9OT1RfU1VQUE9SVEVEX1JFQVNPTic7XG5leHBvcnRzWzE4NDddID0gJ0VSX0FMVEVSX09QRVJBVElPTl9OT1RfU1VQUE9SVEVEX1JFQVNPTl9DT1BZJztcbmV4cG9ydHNbMTg0OF0gPSAnRVJfQUxURVJfT1BFUkFUSU9OX05PVF9TVVBQT1JURURfUkVBU09OX1BBUlRJVElPTic7XG5leHBvcnRzWzE4NDldID0gJ0VSX0FMVEVSX09QRVJBVElPTl9OT1RfU1VQUE9SVEVEX1JFQVNPTl9GS19SRU5BTUUnO1xuZXhwb3J0c1sxODUwXSA9ICdFUl9BTFRFUl9PUEVSQVRJT05fTk9UX1NVUFBPUlRFRF9SRUFTT05fQ09MVU1OX1RZUEUnO1xuZXhwb3J0c1sxODUxXSA9ICdFUl9BTFRFUl9PUEVSQVRJT05fTk9UX1NVUFBPUlRFRF9SRUFTT05fRktfQ0hFQ0snO1xuZXhwb3J0c1sxODUyXSA9ICdFUl9BTFRFUl9PUEVSQVRJT05fTk9UX1NVUFBPUlRFRF9SRUFTT05fSUdOT1JFJztcbmV4cG9ydHNbMTg1M10gPSAnRVJfQUxURVJfT1BFUkFUSU9OX05PVF9TVVBQT1JURURfUkVBU09OX05PUEsnO1xuZXhwb3J0c1sxODU0XSA9ICdFUl9BTFRFUl9PUEVSQVRJT05fTk9UX1NVUFBPUlRFRF9SRUFTT05fQVVUT0lOQyc7XG5leHBvcnRzWzE4NTVdID0gJ0VSX0FMVEVSX09QRVJBVElPTl9OT1RfU1VQUE9SVEVEX1JFQVNPTl9ISURERU5fRlRTJztcbmV4cG9ydHNbMTg1Nl0gPSAnRVJfQUxURVJfT1BFUkFUSU9OX05PVF9TVVBQT1JURURfUkVBU09OX0NIQU5HRV9GVFMnO1xuZXhwb3J0c1sxODU3XSA9ICdFUl9BTFRFUl9PUEVSQVRJT05fTk9UX1NVUFBPUlRFRF9SRUFTT05fRlRTJztcbmV4cG9ydHNbMTg1OF0gPSAnRVJfU1FMX1NMQVZFX1NLSVBfQ09VTlRFUl9OT1RfU0VUVEFCTEVfSU5fR1RJRF9NT0RFJztcbmV4cG9ydHNbMTg1OV0gPSAnRVJfRFVQX1VOS05PV05fSU5fSU5ERVgnO1xuZXhwb3J0c1sxODYwXSA9ICdFUl9JREVOVF9DQVVTRVNfVE9PX0xPTkdfUEFUSCc7XG5leHBvcnRzWzE4NjFdID0gJ0VSX0FMVEVSX09QRVJBVElPTl9OT1RfU1VQUE9SVEVEX1JFQVNPTl9OT1RfTlVMTCc7XG5leHBvcnRzWzE4NjJdID0gJ0VSX01VU1RfQ0hBTkdFX1BBU1NXT1JEX0xPR0lOJztcbmV4cG9ydHNbMTg2M10gPSAnRVJfUk9XX0lOX1dST05HX1BBUlRJVElPTic7XG5leHBvcnRzWzE4NjRdID0gJ0VSX01UU19FVkVOVF9CSUdHRVJfUEVORElOR19KT0JTX1NJWkVfTUFYJztcbmV4cG9ydHNbMTg2NV0gPSAnRVJfSU5OT0RCX05PX0ZUX1VTRVNfUEFSU0VSJztcbmV4cG9ydHNbMTg2Nl0gPSAnRVJfQklOTE9HX0xPR0lDQUxfQ09SUlVQVElPTic7XG5leHBvcnRzWzE4NjddID0gJ0VSX1dBUk5fUFVSR0VfTE9HX0lOX1VTRSc7XG5leHBvcnRzWzE4NjhdID0gJ0VSX1dBUk5fUFVSR0VfTE9HX0lTX0FDVElWRSc7XG5leHBvcnRzWzE4NjldID0gJ0VSX0FVVE9fSU5DUkVNRU5UX0NPTkZMSUNUJztcbmV4cG9ydHNbMTg3MF0gPSAnV0FSTl9PTl9CTE9DS0hPTEVfSU5fUkJSJztcbmV4cG9ydHNbMTg3MV0gPSAnRVJfU0xBVkVfTUlfSU5JVF9SRVBPU0lUT1JZJztcbmV4cG9ydHNbMTg3Ml0gPSAnRVJfU0xBVkVfUkxJX0lOSVRfUkVQT1NJVE9SWSc7XG5leHBvcnRzWzE4NzNdID0gJ0VSX0FDQ0VTU19ERU5JRURfQ0hBTkdFX1VTRVJfRVJST1InO1xuZXhwb3J0c1sxODc0XSA9ICdFUl9JTk5PREJfUkVBRF9PTkxZJztcbmV4cG9ydHNbMTg3NV0gPSAnRVJfU1RPUF9TTEFWRV9TUUxfVEhSRUFEX1RJTUVPVVQnO1xuZXhwb3J0c1sxODc2XSA9ICdFUl9TVE9QX1NMQVZFX0lPX1RIUkVBRF9USU1FT1VUJztcbmV4cG9ydHNbMTg3N10gPSAnRVJfVEFCTEVfQ09SUlVQVCc7XG5leHBvcnRzWzE4NzhdID0gJ0VSX1RFTVBfRklMRV9XUklURV9GQUlMVVJFJztcbmV4cG9ydHNbMTg3OV0gPSAnRVJfSU5OT0RCX0ZUX0FVWF9OT1RfSEVYX0lEJztcbmV4cG9ydHNbMTg4MF0gPSAnRVJfT0xEX1RFTVBPUkFMU19VUEdSQURFRCc7XG5leHBvcnRzWzE4ODFdID0gJ0VSX0lOTk9EQl9GT1JDRURfUkVDT1ZFUlknO1xuZXhwb3J0c1sxODgyXSA9ICdFUl9BRVNfSU5WQUxJRF9JVic7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9saWIvcHJvdG9jb2wvY29uc3RhbnRzL2Vycm9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIENyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIEF1dGggICA9IGV4cG9ydHM7XG5cbmZ1bmN0aW9uIHNoYTEobXNnKSB7XG4gIHZhciBoYXNoID0gQ3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKTtcbiAgaGFzaC51cGRhdGUobXNnLCAnYmluYXJ5Jyk7XG4gIHJldHVybiBoYXNoLmRpZ2VzdCgnYmluYXJ5Jyk7XG59XG5BdXRoLnNoYTEgPSBzaGExO1xuXG5mdW5jdGlvbiB4b3IoYSwgYikge1xuICBhID0gbmV3IEJ1ZmZlcihhLCAnYmluYXJ5Jyk7XG4gIGIgPSBuZXcgQnVmZmVyKGIsICdiaW5hcnknKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBCdWZmZXIoYS5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSAoYVtpXSBeIGJbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuQXV0aC54b3IgPSB4b3I7XG5cbkF1dGgudG9rZW4gPSBmdW5jdGlvbihwYXNzd29yZCwgc2NyYW1ibGUpIHtcbiAgaWYgKCFwYXNzd29yZCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApO1xuICB9XG5cbiAgLy8gcGFzc3dvcmQgbXVzdCBiZSBpbiBiaW5hcnkgZm9ybWF0LCBub3QgdXRmOFxuICB2YXIgc3RhZ2UxID0gc2hhMSgobmV3IEJ1ZmZlcihwYXNzd29yZCwgXCJ1dGY4XCIpKS50b1N0cmluZyhcImJpbmFyeVwiKSk7XG4gIHZhciBzdGFnZTIgPSBzaGExKHN0YWdlMSk7XG4gIHZhciBzdGFnZTMgPSBzaGExKHNjcmFtYmxlLnRvU3RyaW5nKCdiaW5hcnknKSArIHN0YWdlMik7XG4gIHJldHVybiB4b3Ioc3RhZ2UzLCBzdGFnZTEpO1xufTtcblxuLy8gVGhpcyBpcyBhIHBvcnQgb2Ygc3FsL3Bhc3N3b3JkLmM6aGFzaF9wYXNzd29yZCB3aGljaCBuZWVkcyB0byBiZSB1c2VkIGZvclxuLy8gcHJlLTQuMSBwYXNzd29yZHMuXG5BdXRoLmhhc2hQYXNzd29yZCA9IGZ1bmN0aW9uKHBhc3N3b3JkKSB7XG4gIHZhciBuciA9IFsweDUwMzAsIDB4NTczNV0sXG4gICAgICBhZGQgPSA3LFxuICAgICAgbnIyID0gWzB4MTIzNCwgMHg1NjcxXSxcbiAgICAgIHJlc3VsdCA9IG5ldyBCdWZmZXIoOCk7XG5cbiAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PSAnc3RyaW5nJyl7XG4gICAgcGFzc3dvcmQgPSBuZXcgQnVmZmVyKHBhc3N3b3JkKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFzc3dvcmQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYyA9IHBhc3N3b3JkW2ldO1xuICAgIGlmIChjID09IDMyIHx8IGMgPT0gOSkge1xuICAgICAgLy8gc2tpcCBzcGFjZSBpbiBwYXNzd29yZFxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbnJePSAoKChuciAmIDYzKSthZGQpKmMpKyAobnIgPDwgOCk7XG4gICAgLy8gbnIgPSB4b3IobnIsIGFkZChtdWwoYWRkKGFuZChuciwgNjMpLCBhZGQpLCBjKSwgc2hsKG5yLCA4KSkpXG4gICAgbnIgPSB0aGlzLnhvcjMyKG5yLCB0aGlzLmFkZDMyKHRoaXMubXVsMzIodGhpcy5hZGQzMih0aGlzLmFuZDMyKG5yLCBbMCw2M10pLCBbMCxhZGRdKSwgWzAsY10pLCB0aGlzLnNobDMyKG5yLCA4KSkpO1xuXG4gICAgLy8gbnIyKz0obnIyIDw8IDgpIF4gbnI7XG4gICAgLy8gbnIyID0gYWRkKG5yMiwgeG9yKHNobChucjIsIDgpLCBucikpXG4gICAgbnIyID0gdGhpcy5hZGQzMihucjIsIHRoaXMueG9yMzIodGhpcy5zaGwzMihucjIsIDgpLCBucikpO1xuXG4gICAgLy8gYWRkKz10bXA7XG4gICAgYWRkICs9IGM7XG4gIH1cblxuICB0aGlzLmludDMxV3JpdGUocmVzdWx0LCBuciwgMCk7XG4gIHRoaXMuaW50MzFXcml0ZShyZXN1bHQsIG5yMiwgNCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkF1dGgucmFuZG9tSW5pdCA9IGZ1bmN0aW9uKHNlZWQxLCBzZWVkMikge1xuICByZXR1cm4ge1xuICAgIG1heF92YWx1ZTogMHgzRkZGRkZGRixcbiAgICBtYXhfdmFsdWVfZGJsOiAweDNGRkZGRkZGLFxuICAgIHNlZWQxOiBzZWVkMSAlIDB4M0ZGRkZGRkYsXG4gICAgc2VlZDI6IHNlZWQyICUgMHgzRkZGRkZGRlxuICB9O1xufTtcblxuQXV0aC5teVJuZCA9IGZ1bmN0aW9uKHIpe1xuICByLnNlZWQxID0gKHIuc2VlZDEgKiAzICsgci5zZWVkMikgJSByLm1heF92YWx1ZTtcbiAgci5zZWVkMiA9IChyLnNlZWQxICsgci5zZWVkMiArIDMzKSAlIHIubWF4X3ZhbHVlO1xuXG4gIHJldHVybiByLnNlZWQxIC8gci5tYXhfdmFsdWVfZGJsO1xufTtcblxuQXV0aC5zY3JhbWJsZTMyMyA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHBhc3N3b3JkKSB7XG4gIHZhciB0byA9IG5ldyBCdWZmZXIoOCksXG4gICAgICBoYXNoUGFzcyA9IHRoaXMuaGFzaFBhc3N3b3JkKHBhc3N3b3JkKSxcbiAgICAgIGhhc2hNZXNzYWdlID0gdGhpcy5oYXNoUGFzc3dvcmQobWVzc2FnZS5zbGljZSgwLCA4KSksXG4gICAgICBzZWVkMSA9IHRoaXMuaW50MzJSZWFkKGhhc2hQYXNzLCAwKSBeIHRoaXMuaW50MzJSZWFkKGhhc2hNZXNzYWdlLCAwKSxcbiAgICAgIHNlZWQyID0gdGhpcy5pbnQzMlJlYWQoaGFzaFBhc3MsIDQpIF4gdGhpcy5pbnQzMlJlYWQoaGFzaE1lc3NhZ2UsIDQpLFxuICAgICAgciA9IHRoaXMucmFuZG9tSW5pdChzZWVkMSwgc2VlZDIpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKXtcbiAgICB0b1tpXSA9IE1hdGguZmxvb3IodGhpcy5teVJuZChyKSAqIDMxKSArIDY0O1xuICB9XG4gIHZhciBleHRyYSA9IChNYXRoLmZsb29yKHRoaXMubXlSbmQocikgKiAzMSkpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKXtcbiAgICB0b1tpXSBePSBleHRyYTtcbiAgfVxuXG4gIHJldHVybiB0bztcbn07XG5cbkF1dGguZm10MzIgPSBmdW5jdGlvbih4KXtcbiAgdmFyIGEgPSB4WzBdLnRvU3RyaW5nKDE2KSxcbiAgICAgIGIgPSB4WzFdLnRvU3RyaW5nKDE2KTtcblxuICBpZiAoYS5sZW5ndGggPT0gMSkgYSA9ICcwMDAnK2E7XG4gIGlmIChhLmxlbmd0aCA9PSAyKSBhID0gJzAwJythO1xuICBpZiAoYS5sZW5ndGggPT0gMykgYSA9ICcwJythO1xuICBpZiAoYi5sZW5ndGggPT0gMSkgYiA9ICcwMDAnK2I7XG4gIGlmIChiLmxlbmd0aCA9PSAyKSBiID0gJzAwJytiO1xuICBpZiAoYi5sZW5ndGggPT0gMykgYiA9ICcwJytiO1xuICByZXR1cm4gJycgKyBhICsgJy8nICsgYjtcbn07XG5cbkF1dGgueG9yMzIgPSBmdW5jdGlvbihhLGIpe1xuICByZXR1cm4gW2FbMF0gXiBiWzBdLCBhWzFdIF4gYlsxXV07XG59O1xuXG5BdXRoLmFkZDMyID0gZnVuY3Rpb24oYSxiKXtcbiAgdmFyIHcxID0gYVsxXSArIGJbMV0sXG4gICAgICB3MiA9IGFbMF0gKyBiWzBdICsgKCh3MSAmIDB4RkZGRjAwMDApID4+IDE2KTtcblxuICByZXR1cm4gW3cyICYgMHhGRkZGLCB3MSAmIDB4RkZGRl07XG59O1xuXG5BdXRoLm11bDMyID0gZnVuY3Rpb24oYSxiKXtcbiAgLy8gYmFzZWQgb24gdGhpcyBleGFtcGxlIG9mIG11bHRpcGx5aW5nIDMyYiBpbnRzIHVzaW5nIDE2YlxuICAvLyBodHRwOi8vd3d3LmRzcHJlbGF0ZWQuY29tL3Nob3dtZXNzYWdlLzg5NzkwLzEucGhwXG4gIHZhciB3MSA9IGFbMV0gKiBiWzFdLFxuICAgICAgdzIgPSAoKChhWzFdICogYlsxXSkgPj4gMTYpICYgMHhGRkZGKSArICgoYVswXSAqIGJbMV0pICYgMHhGRkZGKSArIChhWzFdICogYlswXSAmIDB4RkZGRik7XG5cbiAgcmV0dXJuIFt3MiAmIDB4RkZGRiwgdzEgJiAweEZGRkZdO1xufTtcblxuQXV0aC5hbmQzMiA9IGZ1bmN0aW9uKGEsYil7XG4gIHJldHVybiBbYVswXSAmIGJbMF0sIGFbMV0gJiBiWzFdXTtcbn07XG5cbkF1dGguc2hsMzIgPSBmdW5jdGlvbihhLGIpe1xuICAvLyBhc3N1bWUgYiBpcyAxNiBvciBsZXNzXG4gIHZhciB3MSA9IGFbMV0gPDwgYixcbiAgICAgIHcyID0gKGFbMF0gPDwgYikgfCAoKHcxICYgMHhGRkZGMDAwMCkgPj4gMTYpO1xuXG4gIHJldHVybiBbdzIgJiAweEZGRkYsIHcxICYgMHhGRkZGXTtcbn07XG5cbkF1dGguaW50MzFXcml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgbnVtYmVyLCBvZmZzZXQpIHtcbiAgYnVmZmVyW29mZnNldF0gPSAobnVtYmVyWzBdID4+IDgpICYgMHg3RjtcbiAgYnVmZmVyW29mZnNldCArIDFdID0gKG51bWJlclswXSkgJiAweEZGO1xuICBidWZmZXJbb2Zmc2V0ICsgMl0gPSAobnVtYmVyWzFdID4+IDgpICYgMHhGRjtcbiAgYnVmZmVyW29mZnNldCArIDNdID0gKG51bWJlclsxXSkgJiAweEZGO1xufTtcblxuQXV0aC5pbnQzMlJlYWQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCl7XG4gIHJldHVybiAoYnVmZmVyW29mZnNldF0gPDwgMjQpXG4gICAgICAgKyAoYnVmZmVyW29mZnNldCsxXSA8PCAxNilcbiAgICAgICArIChidWZmZXJbb2Zmc2V0KzJdIDw8IDgpXG4gICAgICAgKyAoYnVmZmVyW29mZnNldCszXSk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbXlzcWwvbGliL3Byb3RvY29sL0F1dGguanNcbiAqKiBtb2R1bGUgaWQgPSA1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJidWZmZXJcIlxuICoqIG1vZHVsZSBpZCA9IDU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgU2VxdWVuY2UgICAgICAgID0gcmVxdWlyZSgnLi9TZXF1ZW5jZScpO1xudmFyIFV0aWwgICAgICAgICAgICA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBQYWNrZXRzICAgICAgICAgPSByZXF1aXJlKCcuLi9wYWNrZXRzJyk7XG52YXIgQXV0aCAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vQXV0aCcpO1xudmFyIENsaWVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9jbGllbnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBIYW5kc2hha2U7XG5VdGlsLmluaGVyaXRzKEhhbmRzaGFrZSwgU2VxdWVuY2UpO1xuZnVuY3Rpb24gSGFuZHNoYWtlKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIFNlcXVlbmNlLmNhbGwodGhpcywgb3B0aW9ucywgY2FsbGJhY2spO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMuX2NvbmZpZyAgICAgICAgICAgICAgICAgICAgICAgID0gb3B0aW9ucy5jb25maWc7XG4gIHRoaXMuX2hhbmRzaGFrZUluaXRpYWxpemF0aW9uUGFja2V0ID0gbnVsbDtcbn1cblxuSGFuZHNoYWtlLnByb3RvdHlwZS5kZXRlcm1pbmVQYWNrZXQgPSBmdW5jdGlvbihmaXJzdEJ5dGUpIHtcbiAgaWYgKGZpcnN0Qnl0ZSA9PT0gMHhmZikge1xuICAgIHJldHVybiBQYWNrZXRzLkVycm9yUGFja2V0O1xuICB9XG5cbiAgaWYgKCF0aGlzLl9oYW5kc2hha2VJbml0aWFsaXphdGlvblBhY2tldCkge1xuICAgIHJldHVybiBQYWNrZXRzLkhhbmRzaGFrZUluaXRpYWxpemF0aW9uUGFja2V0O1xuICB9XG5cbiAgaWYgKGZpcnN0Qnl0ZSA9PT0gMHhmZSkge1xuICAgIHJldHVybiBQYWNrZXRzLlVzZU9sZFBhc3N3b3JkUGFja2V0O1xuICB9XG59O1xuXG5IYW5kc2hha2UucHJvdG90eXBlWydIYW5kc2hha2VJbml0aWFsaXphdGlvblBhY2tldCddID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHRoaXMuX2hhbmRzaGFrZUluaXRpYWxpemF0aW9uUGFja2V0ID0gcGFja2V0O1xuXG4gIHRoaXMuX2NvbmZpZy5wcm90b2NvbDQxID0gcGFja2V0LnByb3RvY29sNDE7XG5cbiAgdmFyIHNlcnZlclNTTFN1cHBvcnQgPSBwYWNrZXQuc2VydmVyQ2FwYWJpbGl0aWVzMSAmIENsaWVudENvbnN0YW50cy5DTElFTlRfU1NMOyBcblxuICBpZiAodGhpcy5fY29uZmlnLnNzbCkge1xuICAgIGlmICghc2VydmVyU1NMU3VwcG9ydCkge1xuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignU2VydmVyIGRvZXMgbm90IHN1cHBvcnQgc2VjdXJlIGNvbm5uZWN0aW9uJyk7XG5cbiAgICAgIGVyci5jb2RlID0gJ0hBTkRTSEFLRV9OT19TU0xfU1VQUE9SVCc7XG4gICAgICBlcnIuZmF0YWwgPSB0cnVlO1xuXG4gICAgICB0aGlzLmVuZChlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2NvbmZpZy5jbGllbnRGbGFncyB8PSBDbGllbnRDb25zdGFudHMuQ0xJRU5UX1NTTDtcbiAgICB0aGlzLmVtaXQoJ3BhY2tldCcsIG5ldyBQYWNrZXRzLlNTTFJlcXVlc3RQYWNrZXQoe1xuICAgICAgY2xpZW50RmxhZ3MgICA6IHRoaXMuX2NvbmZpZy5jbGllbnRGbGFncyxcbiAgICAgIG1heFBhY2tldFNpemUgOiB0aGlzLl9jb25maWcubWF4UGFja2V0U2l6ZSxcbiAgICAgIGNoYXJzZXROdW1iZXIgOiB0aGlzLl9jb25maWcuY2hhcnNldE51bWJlclxuICAgIH0pKTtcbiAgICB0aGlzLmVtaXQoJ3N0YXJ0LXRscycpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3NlbmRDcmVkZW50aWFscygpO1xuICB9XG59O1xuXG5IYW5kc2hha2UucHJvdG90eXBlLl90bHNVcGdyYWRlQ29tcGxldGVIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3NlbmRDcmVkZW50aWFscygpO1xufTtcblxuSGFuZHNoYWtlLnByb3RvdHlwZS5fc2VuZENyZWRlbnRpYWxzID0gZnVuY3Rpb24oc2VydmVySGVsbG8pIHtcbiAgdmFyIHBhY2tldCA9IHRoaXMuX2hhbmRzaGFrZUluaXRpYWxpemF0aW9uUGFja2V0O1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIG5ldyBQYWNrZXRzLkNsaWVudEF1dGhlbnRpY2F0aW9uUGFja2V0KHtcbiAgICBjbGllbnRGbGFncyAgIDogdGhpcy5fY29uZmlnLmNsaWVudEZsYWdzLFxuICAgIG1heFBhY2tldFNpemUgOiB0aGlzLl9jb25maWcubWF4UGFja2V0U2l6ZSxcbiAgICBjaGFyc2V0TnVtYmVyIDogdGhpcy5fY29uZmlnLmNoYXJzZXROdW1iZXIsXG4gICAgdXNlciAgICAgICAgICA6IHRoaXMuX2NvbmZpZy51c2VyLFxuICAgIHNjcmFtYmxlQnVmZiAgOiAocGFja2V0LnByb3RvY29sNDEpXG4gICAgICAgICAgICAgICAgICAgICA/IEF1dGgudG9rZW4odGhpcy5fY29uZmlnLnBhc3N3b3JkLCBwYWNrZXQuc2NyYW1ibGVCdWZmKCkpXG4gICAgICAgICAgICAgICAgICAgICA6IEF1dGguc2NyYW1ibGUzMjMocGFja2V0LnNjcmFtYmxlQnVmZigpLCB0aGlzLl9jb25maWcucGFzc3dvcmQpLFxuICAgIGRhdGFiYXNlICAgICAgOiB0aGlzLl9jb25maWcuZGF0YWJhc2UsXG4gICAgcHJvdG9jb2w0MSAgICA6IHBhY2tldC5wcm90b2NvbDQxXG4gIH0pKTtcbn07XG5cbkhhbmRzaGFrZS5wcm90b3R5cGVbJ1VzZU9sZFBhc3N3b3JkUGFja2V0J10gPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgaWYgKCF0aGlzLl9jb25maWcuaW5zZWN1cmVBdXRoKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICdNeVNRTCBzZXJ2ZXIgaXMgcmVxdWVzdGluZyB0aGUgb2xkIGFuZCBpbnNlY3VyZSBwcmUtNC4xIGF1dGggbWVjaGFuaXNtLicgK1xuICAgICAgJ1VwZ3JhZGUgdGhlIHVzZXIgcGFzc3dvcmQgb3IgdXNlIHRoZSB7aW5zZWN1cmVBdXRoOiB0cnVlfSBvcHRpb24uJ1xuICAgICk7XG5cbiAgICBlcnIuY29kZSA9ICdIQU5EU0hBS0VfSU5TRUNVUkVfQVVUSCc7XG4gICAgZXJyLmZhdGFsID0gdHJ1ZTtcblxuICAgIHRoaXMuZW5kKGVycik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBuZXcgUGFja2V0cy5PbGRQYXNzd29yZFBhY2tldCh7XG4gICAgc2NyYW1ibGVCdWZmIDogQXV0aC5zY3JhbWJsZTMyMyh0aGlzLl9oYW5kc2hha2VJbml0aWFsaXphdGlvblBhY2tldC5zY3JhbWJsZUJ1ZmYoKSwgdGhpcy5fY29uZmlnLnBhc3N3b3JkKSxcbiAgfSkpO1xufTtcblxuSGFuZHNoYWtlLnByb3RvdHlwZVsnRXJyb3JQYWNrZXQnXSA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICB2YXIgZXJyID0gdGhpcy5fcGFja2V0VG9FcnJvcihwYWNrZXQsIHRydWUpO1xuICBlcnIuZmF0YWwgPSB0cnVlO1xuICB0aGlzLmVuZChlcnIpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL2xpYi9wcm90b2NvbC9zZXF1ZW5jZXMvSGFuZHNoYWtlLmpzXG4gKiogbW9kdWxlIGlkID0gNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBTZXF1ZW5jZSA9IHJlcXVpcmUoJy4vU2VxdWVuY2UnKTtcbnZhciBVdGlsICAgICA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBQYWNrZXRzICA9IHJlcXVpcmUoJy4uL3BhY2tldHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQaW5nO1xuVXRpbC5pbmhlcml0cyhQaW5nLCBTZXF1ZW5jZSk7XG5cbmZ1bmN0aW9uIFBpbmcob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBTZXF1ZW5jZS5jYWxsKHRoaXMsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn1cblxuUGluZy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBuZXcgUGFja2V0cy5Db21QaW5nUGFja2V0KTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9saWIvcHJvdG9jb2wvc2VxdWVuY2VzL1BpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSA2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIFNlcXVlbmNlICAgICA9IHJlcXVpcmUoJy4vU2VxdWVuY2UnKTtcbnZhciBVdGlsICAgICAgICAgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgUGFja2V0cyAgICAgID0gcmVxdWlyZSgnLi4vcGFja2V0cycpO1xudmFyIFJlc3VsdFNldCAgICA9IHJlcXVpcmUoJy4uL1Jlc3VsdFNldCcpO1xudmFyIFNlcnZlclN0YXR1cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9zZXJ2ZXJfc3RhdHVzJyk7XG52YXIgZnMgICAgICAgICAgID0gcmVxdWlyZSgnZnMnKTtcbnZhciBSZWFkYWJsZSAgICAgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeTtcblV0aWwuaW5oZXJpdHMoUXVlcnksIFNlcXVlbmNlKTtcbmZ1bmN0aW9uIFF1ZXJ5KG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIFNlcXVlbmNlLmNhbGwodGhpcywgb3B0aW9ucywgY2FsbGJhY2spO1xuXG4gIHRoaXMuc3FsID0gb3B0aW9ucy5zcWw7XG4gIHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG4gIHRoaXMudHlwZUNhc3QgPSAob3B0aW9ucy50eXBlQ2FzdCA9PT0gdW5kZWZpbmVkKVxuICAgID8gdHJ1ZVxuICAgIDogb3B0aW9ucy50eXBlQ2FzdDtcbiAgdGhpcy5uZXN0VGFibGVzID0gb3B0aW9ucy5uZXN0VGFibGVzIHx8IGZhbHNlO1xuXG4gIHRoaXMuX3Jlc3VsdFNldCA9IG51bGw7XG4gIHRoaXMuX3Jlc3VsdHMgICA9IFtdO1xuICB0aGlzLl9maWVsZHMgICAgPSBbXTtcbiAgdGhpcy5faW5kZXggICAgID0gMDtcbiAgdGhpcy5fbG9hZEVycm9yID0gbnVsbDtcbn1cblxuUXVlcnkucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgbmV3IFBhY2tldHMuQ29tUXVlcnlQYWNrZXQodGhpcy5zcWwpKTtcbn07XG5cblF1ZXJ5LnByb3RvdHlwZS5kZXRlcm1pbmVQYWNrZXQgPSBmdW5jdGlvbihmaXJzdEJ5dGUsIHBhcnNlcikge1xuICBpZiAoZmlyc3RCeXRlID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhIHJlc3VsdFNldCBhbmQgZ290IG9uZSBlb2ZQYWNrZXRcbiAgICBpZiAodGhpcy5fcmVzdWx0U2V0ICYmIHRoaXMuX3Jlc3VsdFNldC5lb2ZQYWNrZXRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gVGhlbiB0aGlzIGlzIGEgUm93RGF0YVBhY2tldCB3aXRoIGFuIGVtcHR5IHN0cmluZyBpbiB0aGUgZmlyc3QgY29sdW1uLlxuICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVsaXhnZS9ub2RlLW15c3FsL2lzc3Vlcy8yMjJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3Jlc3VsdFNldCAmJiB0aGlzLl9yZXN1bHRTZXQucmVzdWx0U2V0SGVhZGVyUGFja2V0XG4gICAgICAgICAgICYmIHRoaXMuX3Jlc3VsdFNldC5yZXN1bHRTZXRIZWFkZXJQYWNrZXQuZmllbGRDb3VudCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFBhY2tldHMuRmllbGRQYWNrZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoZmlyc3RCeXRlID09PSAyNTUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBFb2ZQYWNrZXQncyBhcmUgNSBieXRlcyBpbiBteXNxbCA+PSA0LjFcbiAgLy8gVGhpcyBpcyB0aGUgb25seSAvIGJlc3Qgd2F5IHRvIGRpZmZlcmVudGlhdGUgdGhlaXIgZmlyc3RCeXRlIGZyb20gYSA5XG4gIC8vIGJ5dGUgbGVuZ3RoIGNvZGVkIGJpbmFyeS5cbiAgaWYgKGZpcnN0Qnl0ZSA9PT0gMHhmZSAmJiBwYXJzZXIucGFja2V0TGVuZ3RoKCkgPCA5KSB7XG4gICAgcmV0dXJuIFBhY2tldHMuRW9mUGFja2V0O1xuICB9XG5cbiAgaWYgKCF0aGlzLl9yZXN1bHRTZXQpIHtcbiAgICByZXR1cm4gUGFja2V0cy5SZXN1bHRTZXRIZWFkZXJQYWNrZXQ7XG4gIH1cblxuICByZXR1cm4gKHRoaXMuX3Jlc3VsdFNldC5lb2ZQYWNrZXRzLmxlbmd0aCA9PT0gMClcbiAgICA/IFBhY2tldHMuRmllbGRQYWNrZXRcbiAgICA6IFBhY2tldHMuUm93RGF0YVBhY2tldDtcbn07XG5cblF1ZXJ5LnByb3RvdHlwZVsnT2tQYWNrZXQnXSA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICAvLyB0cnkuLi5maW5hbGx5IGZvciBleGNlcHRpb24gc2FmZXR5XG4gIHRyeSB7XG4gICAgaWYgKCF0aGlzLl9jYWxsYmFjaykge1xuICAgICAgdGhpcy5lbWl0KCdyZXN1bHQnLCBwYWNrZXQsIHRoaXMuX2luZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzdWx0cy5wdXNoKHBhY2tldCk7XG4gICAgICB0aGlzLl9maWVsZHMucHVzaCh1bmRlZmluZWQpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICB0aGlzLl9pbmRleCsrO1xuICAgIHRoaXMuX3Jlc3VsdFNldCA9IG51bGw7XG4gICAgdGhpcy5faGFuZGxlRmluYWxSZXN1bHRQYWNrZXQocGFja2V0KTtcbiAgfVxufTtcblxuUXVlcnkucHJvdG90eXBlWydFcnJvclBhY2tldCddID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHZhciBlcnIgPSB0aGlzLl9wYWNrZXRUb0Vycm9yKHBhY2tldCk7XG5cbiAgdmFyIHJlc3VsdHMgPSAodGhpcy5fcmVzdWx0cy5sZW5ndGggPiAwKVxuICAgID8gdGhpcy5fcmVzdWx0c1xuICAgIDogdW5kZWZpbmVkO1xuXG4gIHZhciBmaWVsZHMgPSAodGhpcy5fZmllbGRzLmxlbmd0aCA+IDApXG4gICAgPyB0aGlzLl9maWVsZHNcbiAgICA6IHVuZGVmaW5lZDtcblxuICBlcnIuaW5kZXggPSB0aGlzLl9pbmRleDtcbiAgdGhpcy5lbmQoZXJyLCByZXN1bHRzLCBmaWVsZHMpO1xufTtcblxuUXVlcnkucHJvdG90eXBlWydSZXN1bHRTZXRIZWFkZXJQYWNrZXQnXSA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICB0aGlzLl9yZXN1bHRTZXQgPSBuZXcgUmVzdWx0U2V0KHBhY2tldCk7XG5cbiAgLy8gdXNlZCBieSBMT0FEIERBVEEgTE9DQUwgSU5GSUxFIHF1ZXJpZXNcbiAgaWYgKHBhY2tldC5maWVsZENvdW50ID09PSBudWxsKSB7XG4gICAgdGhpcy5fc2VuZExvY2FsRGF0YUZpbGUocGFja2V0LmV4dHJhKTtcbiAgfVxufTtcblxuUXVlcnkucHJvdG90eXBlWydGaWVsZFBhY2tldCddID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHRoaXMuX3Jlc3VsdFNldC5maWVsZFBhY2tldHMucHVzaChwYWNrZXQpO1xufTtcblxuUXVlcnkucHJvdG90eXBlWydFb2ZQYWNrZXQnXSA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICB0aGlzLl9yZXN1bHRTZXQuZW9mUGFja2V0cy5wdXNoKHBhY2tldCk7XG5cbiAgaWYgKHRoaXMuX3Jlc3VsdFNldC5lb2ZQYWNrZXRzLmxlbmd0aCA9PT0gMSAmJiAhdGhpcy5fY2FsbGJhY2spIHtcbiAgICB0aGlzLmVtaXQoJ2ZpZWxkcycsIHRoaXMuX3Jlc3VsdFNldC5maWVsZFBhY2tldHMsIHRoaXMuX2luZGV4KTtcbiAgfVxuXG4gIGlmICh0aGlzLl9yZXN1bHRTZXQuZW9mUGFja2V0cy5sZW5ndGggIT09IDIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5fY2FsbGJhY2spIHtcbiAgICB0aGlzLl9yZXN1bHRzLnB1c2godGhpcy5fcmVzdWx0U2V0LnJvd3MpO1xuICAgIHRoaXMuX2ZpZWxkcy5wdXNoKHRoaXMuX3Jlc3VsdFNldC5maWVsZFBhY2tldHMpO1xuICB9XG5cbiAgdGhpcy5faW5kZXgrKztcbiAgdGhpcy5fcmVzdWx0U2V0ID0gbnVsbDtcbiAgdGhpcy5faGFuZGxlRmluYWxSZXN1bHRQYWNrZXQocGFja2V0KTtcbn07XG5cblF1ZXJ5LnByb3RvdHlwZS5faGFuZGxlRmluYWxSZXN1bHRQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgaWYgKHBhY2tldC5zZXJ2ZXJTdGF0dXMgJiBTZXJ2ZXJTdGF0dXMuU0VSVkVSX01PUkVfUkVTVUxUU19FWElTVFMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVzdWx0cyA9ICh0aGlzLl9yZXN1bHRzLmxlbmd0aCA+IDEpXG4gICAgPyB0aGlzLl9yZXN1bHRzXG4gICAgOiB0aGlzLl9yZXN1bHRzWzBdO1xuXG4gIHZhciBmaWVsZHMgPSAodGhpcy5fZmllbGRzLmxlbmd0aCA+IDEpXG4gICAgPyB0aGlzLl9maWVsZHNcbiAgICA6IHRoaXMuX2ZpZWxkc1swXTtcblxuICB0aGlzLmVuZCh0aGlzLl9sb2FkRXJyb3IsIHJlc3VsdHMsIGZpZWxkcyk7XG59O1xuXG5RdWVyeS5wcm90b3R5cGVbJ1Jvd0RhdGFQYWNrZXQnXSA9IGZ1bmN0aW9uKHBhY2tldCwgcGFyc2VyLCBjb25uZWN0aW9uKSB7XG4gIHBhY2tldC5wYXJzZShwYXJzZXIsIHRoaXMuX3Jlc3VsdFNldC5maWVsZFBhY2tldHMsIHRoaXMudHlwZUNhc3QsIHRoaXMubmVzdFRhYmxlcywgY29ubmVjdGlvbik7XG5cbiAgaWYgKHRoaXMuX2NhbGxiYWNrKSB7XG4gICAgdGhpcy5fcmVzdWx0U2V0LnJvd3MucHVzaChwYWNrZXQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZW1pdCgncmVzdWx0JywgcGFja2V0LCB0aGlzLl9pbmRleCk7XG4gIH1cbn07XG5cblF1ZXJ5LnByb3RvdHlwZS5fc2VuZExvY2FsRGF0YUZpbGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxvY2FsU3RyZWFtID0gZnMuY3JlYXRlUmVhZFN0cmVhbShwYXRoLCB7XG4gICAgJ2ZsYWcnOiAncicsXG4gICAgJ2VuY29kaW5nJzogbnVsbCxcbiAgICAnYXV0b0Nsb3NlJzogdHJ1ZVxuICB9KTtcblxuXG4gIHRoaXMub24oJ3BhdXNlJywgZnVuY3Rpb24gKCkge1xuICAgIGxvY2FsU3RyZWFtLnBhdXNlKCk7XG4gIH0pO1xuXG4gIHRoaXMub24oJ3Jlc3VtZScsIGZ1bmN0aW9uICgpIHtcbiAgICBsb2NhbFN0cmVhbS5yZXN1bWUoKTtcbiAgfSk7XG5cbiAgbG9jYWxTdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHNlbGYuZW1pdCgncGFja2V0JywgbmV3IFBhY2tldHMuTG9jYWxEYXRhRmlsZVBhY2tldChkYXRhKSk7XG4gIH0pO1xuXG4gIGxvY2FsU3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLl9sb2FkRXJyb3IgPSBlcnI7XG4gICAgbG9jYWxTdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH0pO1xuXG4gIGxvY2FsU3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5lbWl0KCdwYWNrZXQnLCBuZXcgUGFja2V0cy5FbXB0eVBhY2tldCgpKTtcbiAgfSk7XG59O1xuXG5RdWVyeS5wcm90b3R5cGUuc3RyZWFtID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBzdHJlYW07XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMub2JqZWN0TW9kZSA9IHRydWU7XG4gIHN0cmVhbSA9IG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICBzdHJlYW0uX3JlYWQgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9jb25uZWN0aW9uICYmIHNlbGYuX2Nvbm5lY3Rpb24ucmVzdW1lKCk7XG4gIH07XG5cbiAgdGhpcy5vbigncmVzdWx0JyxmdW5jdGlvbihyb3csaSkge1xuICAgIGlmICghc3RyZWFtLnB1c2gocm93KSkgc2VsZi5fY29ubmVjdGlvbi5wYXVzZSgpO1xuICAgIHN0cmVhbS5lbWl0KCdyZXN1bHQnLHJvdyxpKTsgIC8vIHJlcGxpY2F0ZSBvbGQgZW1pdHRlclxuICB9KTtcblxuICB0aGlzLm9uKCdlcnJvcicsZnVuY3Rpb24oZXJyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJyxlcnIpOyAgLy8gUGFzcyBvbiBhbnkgZXJyb3JzXG4gIH0pO1xuXG4gIHRoaXMub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgIHN0cmVhbS5lbWl0KCdjbG9zZScpOyAgLy8gbm90aWZ5IHJlYWRlcnMgdGhhdCBxdWVyeSBoYXMgY29tcGxldGVkXG4gICAgc3RyZWFtLnB1c2gobnVsbCk7ICAvLyBwdXNoaW5nIG51bGwsIGluZGljYXRpbmcgRU9GXG4gIH0pO1xuXG4gIHRoaXMub24oJ2ZpZWxkcycsZnVuY3Rpb24oZmllbGRzLGkpIHtcbiAgICBzdHJlYW0uZW1pdCgnZmllbGRzJyxmaWVsZHMsaSk7ICAvLyByZXBsaWNhdGUgb2xkIGVtaXR0ZXJcbiAgfSk7XG5cbiAgcmV0dXJuIHN0cmVhbTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9saWIvcHJvdG9jb2wvc2VxdWVuY2VzL1F1ZXJ5LmpzXG4gKiogbW9kdWxlIGlkID0gNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gUmVzdWx0U2V0O1xuZnVuY3Rpb24gUmVzdWx0U2V0KHJlc3VsdFNldEhlYWRlclBhY2tldCkge1xuICB0aGlzLnJlc3VsdFNldEhlYWRlclBhY2tldCA9IHJlc3VsdFNldEhlYWRlclBhY2tldDtcbiAgdGhpcy5maWVsZFBhY2tldHMgICAgICAgICAgPSBbXTtcbiAgdGhpcy5lb2ZQYWNrZXRzICAgICAgICAgICAgPSBbXTtcbiAgdGhpcy5yb3dzICAgICAgICAgICAgICAgICAgPSBbXTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL2xpYi9wcm90b2NvbC9SZXN1bHRTZXQuanNcbiAqKiBtb2R1bGUgaWQgPSA2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gTWFudWFsbHkgZXh0cmFjdGVkIGZyb20gbXlzcWwtNS41LjIzL2luY2x1ZGUvbXlzcWxfY29tLmhcblxuLyoqXG4gIElzIHJhaXNlZCB3aGVuIGEgbXVsdGktc3RhdGVtZW50IHRyYW5zYWN0aW9uXG4gIGhhcyBiZWVuIHN0YXJ0ZWQsIGVpdGhlciBleHBsaWNpdGx5LCBieSBtZWFuc1xuICBvZiBCRUdJTiBvciBDT01NSVQgQU5EIENIQUlOLCBvclxuICBpbXBsaWNpdGx5LCBieSB0aGUgZmlyc3QgdHJhbnNhY3Rpb25hbFxuICBzdGF0ZW1lbnQsIHdoZW4gYXV0b2NvbW1pdD1vZmYuXG4qL1xuZXhwb3J0cy5TRVJWRVJfU1RBVFVTX0lOX1RSQU5TICAgICAgICAgID0gMTtcbmV4cG9ydHMuU0VSVkVSX1NUQVRVU19BVVRPQ09NTUlUICAgICAgICA9IDI7ICAvKiBTZXJ2ZXIgaW4gYXV0b19jb21taXQgbW9kZSAqL1xuZXhwb3J0cy5TRVJWRVJfTU9SRV9SRVNVTFRTX0VYSVNUUyAgICAgID0gODsgICAgLyogTXVsdGkgcXVlcnkgLSBuZXh0IHF1ZXJ5IGV4aXN0cyAqL1xuZXhwb3J0cy5TRVJWRVJfUVVFUllfTk9fR09PRF9JTkRFWF9VU0VEID0gMTY7XG5leHBvcnRzLlNFUlZFUl9RVUVSWV9OT19JTkRFWF9VU0VEICAgICAgPSAzMjtcbi8qKlxuICBUaGUgc2VydmVyIHdhcyBhYmxlIHRvIGZ1bGZpbGwgdGhlIGNsaWVudHMgcmVxdWVzdCBhbmQgb3BlbmVkIGFcbiAgcmVhZC1vbmx5IG5vbi1zY3JvbGxhYmxlIGN1cnNvciBmb3IgYSBxdWVyeS4gVGhpcyBmbGFnIGNvbWVzXG4gIGluIHJlcGx5IHRvIENPTV9TVE1UX0VYRUNVVEUgYW5kIENPTV9TVE1UX0ZFVENIIGNvbW1hbmRzLlxuKi9cbmV4cG9ydHMuU0VSVkVSX1NUQVRVU19DVVJTT1JfRVhJU1RTID0gNjQ7XG4vKipcbiAgVGhpcyBmbGFnIGlzIHNlbnQgd2hlbiBhIHJlYWQtb25seSBjdXJzb3IgaXMgZXhoYXVzdGVkLCBpbiByZXBseSB0b1xuICBDT01fU1RNVF9GRVRDSCBjb21tYW5kLlxuKi9cbmV4cG9ydHMuU0VSVkVSX1NUQVRVU19MQVNUX1JPV19TRU5UICAgICAgICA9IDEyODtcbmV4cG9ydHMuU0VSVkVSX1NUQVRVU19EQl9EUk9QUEVEICAgICAgICAgICA9IDI1NjsgLyogQSBkYXRhYmFzZSB3YXMgZHJvcHBlZCAqL1xuZXhwb3J0cy5TRVJWRVJfU1RBVFVTX05PX0JBQ0tTTEFTSF9FU0NBUEVTID0gNTEyO1xuLyoqXG4gIFNlbnQgdG8gdGhlIGNsaWVudCBpZiBhZnRlciBhIHByZXBhcmVkIHN0YXRlbWVudCByZXByZXBhcmVcbiAgd2UgZGlzY292ZXJlZCB0aGF0IHRoZSBuZXcgc3RhdGVtZW50IHJldHVybnMgYSBkaWZmZXJlbnQgXG4gIG51bWJlciBvZiByZXN1bHQgc2V0IGNvbHVtbnMuXG4qL1xuZXhwb3J0cy5TRVJWRVJfU1RBVFVTX01FVEFEQVRBX0NIQU5HRUQgPSAxMDI0O1xuZXhwb3J0cy5TRVJWRVJfUVVFUllfV0FTX1NMT1cgICAgICAgICAgPSAyMDQ4O1xuXG4vKipcbiAgVG8gbWFyayBSZXN1bHRTZXQgY29udGFpbmluZyBvdXRwdXQgcGFyYW1ldGVyIHZhbHVlcy5cbiovXG5leHBvcnRzLlNFUlZFUl9QU19PVVRfUEFSQU1TID0gNDA5NjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL2xpYi9wcm90b2NvbC9jb25zdGFudHMvc2VydmVyX3N0YXR1cy5qc1xuICoqIG1vZHVsZSBpZCA9IDY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJmc1wiKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIGV4dGVybmFsIFwiZnNcIlxuICoqIG1vZHVsZSBpZCA9IDY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL34vcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuaWYgKCFFRS5saXN0ZW5lckNvdW50KSBFRS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmluZ0RlY29kZXI7XG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ3V0aWwnKTtcbmlmIChkZWJ1ZyAmJiBkZWJ1Zy5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSBvcHRpb25zLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG5cblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KVxuICAgIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKVxuICAgIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAodXRpbC5pc1N0cmluZyhjaHVuaykgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIGlmICghc3RhdGUuZW5kZWQpXG4gICAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKVxuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgICBpZiAoIWFkZFRvRnJvbnQpXG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gaWYgd2Ugd2FudCB0aGUgZGF0YSBub3csIGp1c3QgZW1pdCBpdC5cbiAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmIChhZGRUb0Zyb250KVxuICAgICAgICAgIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKVxuICAgICAgICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICAgICAgfVxuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIChzdGF0ZS5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbihlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxMjhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIHJvdW5kVXBUb05leHRQb3dlck9mMihuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyXG4gICAgbi0tO1xuICAgIGZvciAodmFyIHAgPSAxOyBwIDwgMzI7IHAgPDw9IDEpIG4gfD0gbiA+PiBwO1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgIHJldHVybiAwO1xuXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKVxuICAgIHJldHVybiBuID09PSAwID8gMCA6IDE7XG5cbiAgaWYgKGlzTmFOKG4pIHx8IHV0aWwuaXNOdWxsKG4pKSB7XG4gICAgLy8gb25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIHJldHVybiBzdGF0ZS5idWZmZXJbMF0ubGVuZ3RoO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICBpZiAobiA8PSAwKVxuICAgIHJldHVybiAwO1xuXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSB0YXJnZXQgYnVmZmVyIGxldmVsLFxuICAvLyB0aGVuIHJhaXNlIHRoZSB3YXRlciBtYXJrLiAgQnVtcCB1cCB0byB0aGUgbmV4dCBoaWdoZXN0XG4gIC8vIHBvd2VyIG9mIDIsIHRvIHByZXZlbnQgaW5jcmVhc2luZyBpdCBleGNlc3NpdmVseSBpbiB0aW55XG4gIC8vIGFtb3VudHMuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaylcbiAgICBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pO1xuXG4gIC8vIGRvbid0IGhhdmUgdGhhdCBtdWNoLiAgcmV0dXJuIG51bGwsIHVubGVzcyB3ZSd2ZSBlbmRlZC5cbiAgaWYgKG4gPiBzdGF0ZS5sZW5ndGgpIHtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAoIXV0aWwuaXNOdW1iZXIobikgfHwgbiA+IDApXG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJlxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlICYmXG4gICAgICAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgICBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICBlbHNlXG4gICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9XG5cbiAgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gIH1cblxuICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gIGlmIChkb1JlYWQgJiYgIXN0YXRlLnJlYWRpbmcpXG4gICAgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApXG4gICAgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO1xuICBlbHNlXG4gICAgcmV0ID0gbnVsbDtcblxuICBpZiAodXRpbC5pc051bGwocmV0KSkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH1cblxuICBzdGF0ZS5sZW5ndGggLT0gbjtcblxuICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5lbmRlZClcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICBpZiAoIXV0aWwuaXNOdWxsKHJldCkpXG4gICAgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIXV0aWwuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgICAhdXRpbC5pc1N0cmluZyhjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICAgIGVsc2VcbiAgICAgIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmXG4gICAgICAgICAgICAgIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmXG4gICAgICAgICAgICAgIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiBjbGVhbnVwO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZClcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtcbiAgZWxzZVxuICAgIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSkge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiZcbiAgICAgICAgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSlcbiAgICAgIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQpIHtcbiAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLFxuICAgICAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKVxuICAgICAgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuICAvLyBUaGlzIGlzIGEgYnJ1dGFsbHkgdWdseSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyXG4gIC8vIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnkgdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuXG4gIGlmICghZGVzdC5fZXZlbnRzIHx8ICFkZXN0Ll9ldmVudHMuZXJyb3IpXG4gICAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZWxzZSBpZiAoaXNBcnJheShkZXN0Ll9ldmVudHMuZXJyb3IpKVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvci51bnNoaWZ0KG9uZXJyb3IpO1xuICBlbHNlXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yID0gW29uZXJyb3IsIGRlc3QuX2V2ZW50cy5lcnJvcl07XG5cblxuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbilcbiAgICAgIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRS5saXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbihkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdClcbiAgICAgIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpXG4gICAgICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaSA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaSA9PT0gLTEpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGksIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKVxuICAgIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIC8vIElmIGxpc3RlbmluZyB0byBkYXRhLCBhbmQgaXQgaGFzIG5vdCBleHBsaWNpdGx5IGJlZW4gcGF1c2VkLFxuICAvLyB0aGVuIGNhbGwgcmVzdW1lIHRvIHN0YXJ0IHRoZSBmbG93IG9mIGRhdGEgb24gdGhlIG5leHQgdGljay5cbiAgaWYgKGV2ID09PSAnZGF0YScgJiYgZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIHRoaXMucmVzdW1lKCk7XG4gIH1cblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgJiYgdGhpcy5yZWFkYWJsZSkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gICAgICAgICAgc2VsZi5yZWFkKDApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICAgIHRoaXMucmVhZCgwKTtcbiAgICB9XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgcmVzdW1lXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZylcbiAgICBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgY2h1bmsgPSBzdHJlYW0ucmVhZCgpO1xuICAgIH0gd2hpbGUgKG51bGwgIT09IGNodW5rICYmIHN0YXRlLmZsb3dpbmcpO1xuICB9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aClcbiAgICAgICAgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKVxuICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICBpZiAoIWNodW5rIHx8ICFzdGF0ZS5vYmplY3RNb2RlICYmICFjaHVuay5sZW5ndGgpXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKHN0cmVhbVtpXSkgJiYgdXRpbC5pc1VuZGVmaW5lZCh0aGlzW2ldKSkge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uKG1ldGhvZCkgeyByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICB9fShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbihldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn07XG5cblxuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIHZhciBsaXN0ID0gc3RhdGUuYnVmZmVyO1xuICB2YXIgbGVuZ3RoID0gc3RhdGUubGVuZ3RoO1xuICB2YXIgc3RyaW5nTW9kZSA9ICEhc3RhdGUuZGVjb2RlcjtcbiAgdmFyIG9iamVjdE1vZGUgPSAhIXN0YXRlLm9iamVjdE1vZGU7XG4gIHZhciByZXQ7XG5cbiAgLy8gbm90aGluZyBpbiB0aGUgbGlzdCwgZGVmaW5pdGVseSBlbXB0eS5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmIChsZW5ndGggPT09IDApXG4gICAgcmV0ID0gbnVsbDtcbiAgZWxzZSBpZiAob2JqZWN0TW9kZSlcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIGVsc2UgaWYgKCFuIHx8IG4gPj0gbGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBhcnJheS5cbiAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgIHJldCA9IGxpc3Quam9pbignJyk7XG4gICAgZWxzZVxuICAgICAgcmV0ID0gQnVmZmVyLmNvbmNhdChsaXN0LCBsZW5ndGgpO1xuICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIGp1c3Qgc29tZSBvZiBpdC5cbiAgICBpZiAobiA8IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBqdXN0IHRha2UgYSBwYXJ0IG9mIHRoZSBmaXJzdCBsaXN0IGl0ZW0uXG4gICAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgcmV0ID0gYnVmLnNsaWNlKDAsIG4pO1xuICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShuKTtcbiAgICB9IGVsc2UgaWYgKG4gPT09IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBmaXJzdCBsaXN0IGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb21wbGV4IGNhc2UuXG4gICAgICAvLyB3ZSBoYXZlIGVub3VnaCB0byBjb3ZlciBpdCwgYnV0IGl0IHNwYW5zIHBhc3QgdGhlIGZpcnN0IGJ1ZmZlci5cbiAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICByZXQgPSAnJztcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0ID0gbmV3IEJ1ZmZlcihuKTtcblxuICAgICAgdmFyIGMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGwgJiYgYyA8IG47IGkrKykge1xuICAgICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgICAgdmFyIGNweSA9IE1hdGgubWluKG4gLSBjLCBidWYubGVuZ3RoKTtcblxuICAgICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgICByZXQgKz0gYnVmLnNsaWNlKDAsIGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBidWYuY29weShyZXQsIGMsIDAsIGNweSk7XG5cbiAgICAgICAgaWYgKGNweSA8IGJ1Zi5sZW5ndGgpXG4gICAgICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuXG4gICAgICAgIGMgKz0gY3B5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKVxuICAgIHRocm93IG5ldyBFcnJvcignZW5kUmVhZGFibGUgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICAgICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9+L3JlYWRhYmxlLXN0cmVhbS9+L2lzYXJyYXkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJzdHJlYW1cIlxuICoqIG1vZHVsZSBpZCA9IDY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9+L3JlYWRhYmxlLXN0cmVhbS9+L2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbXlzcWwvfi9yZWFkYWJsZS1zdHJlYW0vfi9pbmhlcml0cy9pbmhlcml0cy5qc1xuICoqIG1vZHVsZSBpZCA9IDcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG5mb3JFYWNoKG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKVxuICAgIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufSk7XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKVxuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKVxuICAgIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzLm5leHRUaWNrKHRoaXMuZW5kLmJpbmQodGhpcykpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanNcbiAqKiBtb2R1bGUgaWQgPSA3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IG9wdGlvbnMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbihlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XG4gIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRhYmxlKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLiBOb3QgcmVhZGFibGUuJykpO1xufTtcblxuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBjYihlcik7XG4gIH0pO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIGlmICghdXRpbC5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzU3RyaW5nKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIHZhciBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNiKGVyKTtcbiAgICB9KTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihlbmNvZGluZykpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1dGlsLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICBlbHNlIGlmICghZW5jb2RpbmcpXG4gICAgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oY2IpKVxuICAgIGNiID0gZnVuY3Rpb24oKSB7fTtcblxuICBpZiAoc3RhdGUuZW5kZWQpXG4gICAgd3JpdGVBZnRlckVuZCh0aGlzLCBzdGF0ZSwgY2IpO1xuICBlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiZcbiAgICAgICAgIXN0YXRlLmNvcmtlZCAmJlxuICAgICAgICAhc3RhdGUuZmluaXNoZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiZcbiAgICAgIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmXG4gICAgICB1dGlsLmlzU3RyaW5nKGNodW5rKSkge1xuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICBpZiAodXRpbC5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldClcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZClcbiAgICBzdGF0ZS5idWZmZXIucHVzaChuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikpO1xuICBlbHNlXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldilcbiAgICBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7XG4gIGVsc2VcbiAgICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICBpZiAoc3luYylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gIGVsc2Uge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVyKTtcbiAgfVxuXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKVxuICAgIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO1xuICBlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmXG4gICAgICAgICFzdGF0ZS5jb3JrZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpXG4gICAgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoID4gMSkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgY2JzID0gW107XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspXG4gICAgICBjYnMucHVzaChzdGF0ZS5idWZmZXJbY10uY2FsbGJhY2spO1xuXG4gICAgLy8gY291bnQgdGhlIG9uZSB3ZSBhcmUgYWRkaW5nLCBhcyB3ZWxsLlxuICAgIC8vIFRPRE8oaXNhYWNzKSBjbGVhbiB0aGlzIHVwXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmJ1ZmZlciwgJycsIGZ1bmN0aW9uKGVycikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICAgIGNic1tpXShlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2xlYXIgYnVmZmVyXG4gICAgc3RhdGUuYnVmZmVyID0gW107XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aDsgYysrKSB7XG4gICAgICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJbY107XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBjKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIHN0YXRlLmJ1ZmZlciA9IHN0YXRlLmJ1ZmZlci5zbGljZShjKTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZS5idWZmZXIubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG5cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKGNodW5rKSkge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh1dGlsLmlzRnVuY3Rpb24oZW5jb2RpbmcpKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspKVxuICAgIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpXG4gICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuZW5kaW5nICYmXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICAgIXN0YXRlLndyaXRpbmcpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlXG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKTtcbiAgICBlbHNlXG4gICAgICBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgaXNCdWZmZXJFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nXG4gIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gICAgICAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICBjYXNlICdoZXgnOiBjYXNlICd1dGY4JzogY2FzZSAndXRmLTgnOiBjYXNlICdhc2NpaSc6IGNhc2UgJ2JpbmFyeSc6IGNhc2UgJ2Jhc2U2NCc6IGNhc2UgJ3VjczInOiBjYXNlICd1Y3MtMic6IGNhc2UgJ3V0ZjE2bGUnOiBjYXNlICd1dGYtMTZsZSc6IGNhc2UgJ3Jhdyc6IHJldHVybiB0cnVlO1xuICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgIH1cbiAgICAgfVxuXG5cbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyAmJiAhaXNCdWZmZXJFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLiBDRVNVLTggaXMgaGFuZGxlZCBhcyBwYXJ0IG9mIHRoZSBVVEYtOCBlbmNvZGluZy5cbi8vXG4vLyBAVE9ETyBIYW5kbGluZyBhbGwgZW5jb2RpbmdzIGluc2lkZSBhIHNpbmdsZSBvYmplY3QgbWFrZXMgaXQgdmVyeSBkaWZmaWN1bHRcbi8vIHRvIHJlYXNvbiBhYm91dCB0aGlzIGNvZGUsIHNvIGl0IHNob3VsZCBiZSBzcGxpdCB1cCBpbiB0aGUgZnV0dXJlLlxuLy8gQFRPRE8gVGhlcmUgc2hvdWxkIGJlIGEgdXRmOC1zdHJpY3QgZW5jb2RpbmcgdGhhdCByZWplY3RzIGludmFsaWQgVVRGLTggY29kZVxuLy8gcG9pbnRzIGFzIHVzZWQgYnkgQ0VTVS04LlxudmFyIFN0cmluZ0RlY29kZXIgPSBleHBvcnRzLlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRW5vdWdoIHNwYWNlIHRvIHN0b3JlIGFsbCBieXRlcyBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuIFVURi04IG5lZWRzIDRcbiAgLy8gYnl0ZXMsIGJ1dCBDRVNVLTggbWF5IHJlcXVpcmUgdXAgdG8gNiAoMyBieXRlcyBwZXIgc3Vycm9nYXRlKS5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIC8vIE51bWJlciBvZiBieXRlcyBleHBlY3RlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyTGVuZ3RoID0gMDtcbn07XG5cblxuLy8gd3JpdGUgZGVjb2RlcyB0aGUgZ2l2ZW4gYnVmZmVyIGFuZCByZXR1cm5zIGl0IGFzIEpTIHN0cmluZyB0aGF0IGlzXG4vLyBndWFyYW50ZWVkIHRvIG5vdCBjb250YWluIGFueSBwYXJ0aWFsIG11bHRpLWJ5dGUgY2hhcmFjdGVycy4gQW55IHBhcnRpYWxcbi8vIGNoYXJhY3RlciBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgaXMgYnVmZmVyZWQgdXAsIGFuZCB3aWxsIGJlXG4vLyByZXR1cm5lZCB3aGVuIGNhbGxpbmcgd3JpdGUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzLlxuLy9cbi8vIE5vdGU6IENvbnZlcnRpbmcgYSBCdWZmZXIgY29udGFpbmluZyBhbiBvcnBoYW4gc3Vycm9nYXRlIHRvIGEgU3RyaW5nXG4vLyBjdXJyZW50bHkgd29ya3MsIGJ1dCBjb252ZXJ0aW5nIGEgU3RyaW5nIHRvIGEgQnVmZmVyICh2aWEgYG5ldyBCdWZmZXJgLCBvclxuLy8gQnVmZmVyI3dyaXRlKSB3aWxsIHJlcGxhY2UgaW5jb21wbGV0ZSBzdXJyb2dhdGVzIHdpdGggdGhlIHVuaWNvZGVcbi8vIHJlcGxhY2VtZW50IGNoYXJhY3Rlci4gU2VlIGh0dHBzOi8vY29kZXJldmlldy5jaHJvbWl1bS5vcmcvMTIxMTczMDA5LyAuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBhdmFpbGFibGUgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgIGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBieXRlcyB0byB0aGUgY2hhciBidWZmZXJcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCAwLCBhdmFpbGFibGUpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IGF2YWlsYWJsZTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYnl0ZXMgYmVsb25naW5nIHRvIHRoZSBjdXJyZW50IGNoYXJhY3RlciBmcm9tIHRoZSBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYXZhaWxhYmxlLCBidWZmZXIubGVuZ3RoKTtcblxuICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIHNwbGl0XG4gICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNoYXJTdHI7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGFuZCBzZXQgY2hhckxlbmd0aCAvIGNoYXJSZWNlaXZlZFxuICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcik7XG5cbiAgdmFyIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkLCBlbmQpO1xuICAgIGVuZCAtPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICB0aGlzLmNoYXJMZW5ndGggKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xuICAgIHRoaXMuY2hhckJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgc2l6ZSwgMCwgc2l6ZSk7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCAwLCBzaXplKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cbi8vIGRldGVjdEluY29tcGxldGVDaGFyIGRldGVybWluZXMgaWYgdGhlcmUgaXMgYW4gaW5jb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXIgYXRcbi8vIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gSWYgc28sIGl0IHNldHMgdGhpcy5jaGFyTGVuZ3RoIHRvIHRoZSBieXRlXG4vLyBsZW5ndGggdGhhdCBjaGFyYWN0ZXIsIGFuZCBzZXRzIHRoaXMuY2hhclJlY2VpdmVkIHRvIHRoZSBudW1iZXIgb2YgYnl0ZXNcbi8vIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdGhpcyBjaGFyYWN0ZXIuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMiA6IDA7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDMgOiAwO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbXlzcWwvfi9yZWFkYWJsZS1zdHJlYW0vfi9zdHJpbmdfZGVjb2Rlci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24oZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoZGF0YSkpXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgaWYgKGNiKVxuICAgIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKHRoaXMuX2ZsdXNoKSlcbiAgICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uKGVyKSB7XG4gICAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fFxuICAgICAgICBycy5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaylcbiAgICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICghdXRpbC5pc051bGwodHMud3JpdGVjaHVuaykgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1xuICoqIG1vZHVsZSBpZCA9IDc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKVxuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbXlzcWwvfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanNcbiAqKiBtb2R1bGUgaWQgPSA3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIFNlcXVlbmNlID0gcmVxdWlyZSgnLi9TZXF1ZW5jZScpO1xudmFyIFV0aWwgICAgID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIFBhY2tldHMgID0gcmVxdWlyZSgnLi4vcGFja2V0cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1aXQ7XG5VdGlsLmluaGVyaXRzKFF1aXQsIFNlcXVlbmNlKTtcbmZ1bmN0aW9uIFF1aXQob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBTZXF1ZW5jZS5jYWxsKHRoaXMsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn1cblxuUXVpdC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBuZXcgUGFja2V0cy5Db21RdWl0UGFja2V0KTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9saWIvcHJvdG9jb2wvc2VxdWVuY2VzL1F1aXQuanNcbiAqKiBtb2R1bGUgaWQgPSA3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIFNlcXVlbmNlID0gcmVxdWlyZSgnLi9TZXF1ZW5jZScpO1xudmFyIFV0aWwgICAgID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIFBhY2tldHMgID0gcmVxdWlyZSgnLi4vcGFja2V0cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRpc3RpY3M7XG5VdGlsLmluaGVyaXRzKFN0YXRpc3RpY3MsIFNlcXVlbmNlKTtcbmZ1bmN0aW9uIFN0YXRpc3RpY3Mob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBTZXF1ZW5jZS5jYWxsKHRoaXMsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn1cblxuU3RhdGlzdGljcy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBuZXcgUGFja2V0cy5Db21TdGF0aXN0aWNzUGFja2V0KTtcbn07XG5cblN0YXRpc3RpY3MucHJvdG90eXBlWydTdGF0aXN0aWNzUGFja2V0J10gPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHRoaXMuZW5kKG51bGwsIHBhY2tldCk7XG59O1xuXG5TdGF0aXN0aWNzLnByb3RvdHlwZS5kZXRlcm1pbmVQYWNrZXQgPSBmdW5jdGlvbihmaXJzdEJ5dGUsIHBhcnNlcikge1xuICBpZiAoZmlyc3RCeXRlID09PSAweDU1KSB7XG4gICAgcmV0dXJuIFBhY2tldHMuU3RhdGlzdGljc1BhY2tldDtcbiAgfVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL2xpYi9wcm90b2NvbC9zZXF1ZW5jZXMvU3RhdGlzdGljcy5qc1xuICoqIG1vZHVsZSBpZCA9IDc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0aW1lcnNcIik7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcInRpbWVyc1wiXG4gKiogbW9kdWxlIGlkID0gNzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBCSVRfMTYgPSBNYXRoLnBvdygyLCAxNik7XG52YXIgQklUXzI0ID0gTWF0aC5wb3coMiwgMjQpO1xuLy8gVGhlIG1heGltdW0gcHJlY2lzaW9uIEpTIE51bWJlcnMgY2FuIGhvbGQgcHJlY2lzZWx5XG4vLyBEb24ndCBwYW5pYzogR29vZCBlbm91Z2ggdG8gcmVwcmVzZW50IGJ5dGUgdmFsdWVzIHVwIHRvIDgxOTIgVEJcbnZhciBJRUVFXzc1NF9CSU5BUllfNjRfUFJFQ0lTSU9OID0gTWF0aC5wb3coMiwgNTMpO1xudmFyIE1BWF9QQUNLRVRfTEVOR1RIICAgICAgICAgICAgPSBNYXRoLnBvdygyLCAyNCkgLSAxO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhY2tldFdyaXRlcjtcbmZ1bmN0aW9uIFBhY2tldFdyaXRlcigpIHtcbiAgdGhpcy5fYnVmZmVyID0gbmV3IEJ1ZmZlcigwKTtcbiAgdGhpcy5fb2Zmc2V0ID0gMDtcbn1cblxuUGFja2V0V3JpdGVyLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKHBhcnNlcikge1xuICB2YXIgcGFja2V0cyAgPSBNYXRoLmZsb29yKHRoaXMuX2J1ZmZlci5sZW5ndGggLyBNQVhfUEFDS0VUX0xFTkdUSCkgKyAxO1xuICB2YXIgYnVmZmVyICAgPSB0aGlzLl9idWZmZXI7XG4gIHRoaXMuX2J1ZmZlciA9IG5ldyBCdWZmZXIodGhpcy5fYnVmZmVyLmxlbmd0aCArIHBhY2tldHMgKiA0KTtcblxuICBmb3IgKHZhciBwYWNrZXQgPSAwOyBwYWNrZXQgPCBwYWNrZXRzOyBwYWNrZXQrKykge1xuICAgIHRoaXMuX29mZnNldCA9IHBhY2tldCAqIChNQVhfUEFDS0VUX0xFTkdUSCArIDQpO1xuXG4gICAgdmFyIGlzTGFzdCA9IChwYWNrZXQgKyAxID09PSBwYWNrZXRzKTtcbiAgICB2YXIgcGFja2V0TGVuZ3RoID0gKGlzTGFzdClcbiAgICAgID8gYnVmZmVyLmxlbmd0aCAlIE1BWF9QQUNLRVRfTEVOR1RIXG4gICAgICA6IE1BWF9QQUNLRVRfTEVOR1RIO1xuXG4gICAgdmFyIHBhY2tldE51bWJlciA9IHBhcnNlci5pbmNyZW1lbnRQYWNrZXROdW1iZXIoKTtcblxuICAgIHRoaXMud3JpdGVVbnNpZ25lZE51bWJlcigzLCBwYWNrZXRMZW5ndGgpO1xuICAgIHRoaXMud3JpdGVVbnNpZ25lZE51bWJlcigxLCBwYWNrZXROdW1iZXIpO1xuXG4gICAgdmFyIHN0YXJ0ID0gcGFja2V0ICogTUFYX1BBQ0tFVF9MRU5HVEg7XG4gICAgdmFyIGVuZCAgID0gc3RhcnQgKyBwYWNrZXRMZW5ndGg7XG5cbiAgICB0aGlzLndyaXRlQnVmZmVyKGJ1ZmZlci5zbGljZShzdGFydCwgZW5kKSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fYnVmZmVyO1xufTtcblxuUGFja2V0V3JpdGVyLnByb3RvdHlwZS53cml0ZVVuc2lnbmVkTnVtYmVyID0gZnVuY3Rpb24oYnl0ZXMsIHZhbHVlKSB7XG4gIHRoaXMuX2FsbG9jYXRlKGJ5dGVzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzOyBpKyspIHtcbiAgICB0aGlzLl9idWZmZXJbdGhpcy5fb2Zmc2V0KytdID0gKHZhbHVlID4+IChpICogOCkpICYgMHhmZjtcbiAgfVxufTtcblxuUGFja2V0V3JpdGVyLnByb3RvdHlwZS53cml0ZUZpbGxlciA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHRoaXMuX2FsbG9jYXRlKGJ5dGVzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzOyBpKyspIHtcbiAgICB0aGlzLl9idWZmZXJbdGhpcy5fb2Zmc2V0KytdID0gMHgwMDtcbiAgfVxufTtcblxuUGFja2V0V3JpdGVyLnByb3RvdHlwZS53cml0ZU51bGxUZXJtaW5hdGVkU3RyaW5nID0gZnVuY3Rpb24odmFsdWUsIGVuY29kaW5nKSB7XG4gIC8vIFR5cGVjYXN0IHVuZGVmaW5lZCBpbnRvICcnIGFuZCBudW1iZXJzIGludG8gc3RyaW5nc1xuICB2YWx1ZSA9IHZhbHVlIHx8ICcnO1xuICB2YWx1ZSA9IHZhbHVlICsgJyc7XG5cbiAgdmFyIGJ5dGVzID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUsIGVuY29kaW5nIHx8ICd1dGYtOCcpICsgMTtcbiAgdGhpcy5fYWxsb2NhdGUoYnl0ZXMpO1xuXG4gIHRoaXMuX2J1ZmZlci53cml0ZSh2YWx1ZSwgdGhpcy5fb2Zmc2V0LCBlbmNvZGluZyk7XG4gIHRoaXMuX2J1ZmZlclt0aGlzLl9vZmZzZXQgKyBieXRlcyAtIDFdID0gMHgwMDtcblxuICB0aGlzLl9vZmZzZXQgKz0gYnl0ZXM7XG59O1xuXG5QYWNrZXRXcml0ZXIucHJvdG90eXBlLndyaXRlU3RyaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVHlwZWNhc3QgdW5kZWZpbmVkIGludG8gJycgYW5kIG51bWJlcnMgaW50byBzdHJpbmdzXG4gIHZhbHVlID0gdmFsdWUgfHwgJyc7XG4gIHZhbHVlID0gdmFsdWUgKyAnJztcblxuICB2YXIgYnl0ZXMgPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSwgJ3V0Zi04Jyk7XG4gIHRoaXMuX2FsbG9jYXRlKGJ5dGVzKTtcblxuICB0aGlzLl9idWZmZXIud3JpdGUodmFsdWUsIHRoaXMuX29mZnNldCwgJ3V0Zi04Jyk7XG5cbiAgdGhpcy5fb2Zmc2V0ICs9IGJ5dGVzO1xufTtcblxuUGFja2V0V3JpdGVyLnByb3RvdHlwZS53cml0ZUJ1ZmZlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBieXRlcyA9IHZhbHVlLmxlbmd0aDtcblxuICB0aGlzLl9hbGxvY2F0ZShieXRlcyk7XG4gIHZhbHVlLmNvcHkodGhpcy5fYnVmZmVyLCB0aGlzLl9vZmZzZXQpO1xuICB0aGlzLl9vZmZzZXQgKz0gYnl0ZXM7XG59O1xuXG5QYWNrZXRXcml0ZXIucHJvdG90eXBlLndyaXRlTGVuZ3RoQ29kZWROdW1iZXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICB0aGlzLl9hbGxvY2F0ZSgxKTtcbiAgICB0aGlzLl9idWZmZXJbdGhpcy5fb2Zmc2V0KytdID0gMjUxO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh2YWx1ZSA8PSAyNTApIHtcbiAgICB0aGlzLl9hbGxvY2F0ZSgxKTtcbiAgICB0aGlzLl9idWZmZXJbdGhpcy5fb2Zmc2V0KytdID0gdmFsdWU7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHZhbHVlID4gSUVFRV83NTRfQklOQVJZXzY0X1BSRUNJU0lPTikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICd3cml0ZUxlbmd0aENvZGVkTnVtYmVyOiBKUyBwcmVjaXNpb24gcmFuZ2UgZXhjZWVkZWQsIHlvdXIgJyArXG4gICAgICAnbnVtYmVyIGlzID4gNTMgYml0OiBcIicgKyB2YWx1ZSArICdcIidcbiAgICApO1xuICB9XG5cbiAgaWYgKHZhbHVlIDw9IEJJVF8xNikge1xuICAgIHRoaXMuX2FsbG9jYXRlKDMpXG4gICAgdGhpcy5fYnVmZmVyW3RoaXMuX29mZnNldCsrXSA9IDI1MjtcbiAgfSBlbHNlIGlmICh2YWx1ZSA8PSBCSVRfMjQpIHtcbiAgICB0aGlzLl9hbGxvY2F0ZSg0KVxuICAgIHRoaXMuX2J1ZmZlclt0aGlzLl9vZmZzZXQrK10gPSAyNTM7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fYWxsb2NhdGUoOSk7XG4gICAgdGhpcy5fYnVmZmVyW3RoaXMuX29mZnNldCsrXSA9IDI1NDtcbiAgfVxuXG4gIC8vIDE2IEJpdFxuICB0aGlzLl9idWZmZXJbdGhpcy5fb2Zmc2V0KytdID0gdmFsdWUgJiAweGZmO1xuICB0aGlzLl9idWZmZXJbdGhpcy5fb2Zmc2V0KytdID0gKHZhbHVlID4+IDgpICYgMHhmZjtcblxuICBpZiAodmFsdWUgPD0gQklUXzE2KSByZXR1cm47XG5cbiAgLy8gMjQgQml0XG4gIHRoaXMuX2J1ZmZlclt0aGlzLl9vZmZzZXQrK10gPSAodmFsdWUgPj4gMTYpICYgMHhmZjtcblxuICBpZiAodmFsdWUgPD0gQklUXzI0KSByZXR1cm47XG5cbiAgdGhpcy5fYnVmZmVyW3RoaXMuX29mZnNldCsrXSA9ICh2YWx1ZSA+PiAyNCkgJiAweGZmO1xuXG4gIC8vIEhhY2s6IEdldCB0aGUgbW9zdCBzaWduaWZpY2FudCAzMiBiaXQgKEpTIGJpdHdpc2Ugb3BlcmF0b3JzIGFyZSAzMiBiaXQpXG4gIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoMik7XG4gIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIHZhbHVlLmxlbmd0aCAtIDMyKTtcbiAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMik7XG5cbiAgdGhpcy5fYnVmZmVyW3RoaXMuX29mZnNldCsrXSA9IHZhbHVlICYgMHhmZjtcbiAgdGhpcy5fYnVmZmVyW3RoaXMuX29mZnNldCsrXSA9ICh2YWx1ZSA+PiA4KSAmIDB4ZmY7XG4gIHRoaXMuX2J1ZmZlclt0aGlzLl9vZmZzZXQrK10gPSAodmFsdWUgPj4gMTYpICYgMHhmZjtcblxuICAvLyBTZXQgbGFzdCBieXRlIHRvIDAsIGFzIHdlIGNhbiBvbmx5IHN1cHBvcnQgNTMgYml0cyBpbiBKUyAoc2VlIGFib3ZlKVxuICB0aGlzLl9idWZmZXJbdGhpcy5fb2Zmc2V0KytdID0gMDtcbn07XG5cblBhY2tldFdyaXRlci5wcm90b3R5cGUud3JpdGVMZW5ndGhDb2RlZEJ1ZmZlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBieXRlcyA9IHZhbHVlLmxlbmd0aDtcbiAgdGhpcy53cml0ZUxlbmd0aENvZGVkTnVtYmVyKGJ5dGVzKTtcbiAgdGhpcy53cml0ZUJ1ZmZlcih2YWx1ZSk7XG59O1xuXG5QYWNrZXRXcml0ZXIucHJvdG90eXBlLndyaXRlTnVsbFRlcm1pbmF0ZWRCdWZmZXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLndyaXRlQnVmZmVyKHZhbHVlKTtcbiAgdGhpcy53cml0ZUZpbGxlcigxKTsgLy8gMHgwMCB0ZXJtaW5hdG9yXG59O1xuXG5QYWNrZXRXcml0ZXIucHJvdG90eXBlLndyaXRlTGVuZ3RoQ29kZWRTdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICB0aGlzLndyaXRlTGVuZ3RoQ29kZWROdW1iZXIobnVsbCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFsdWUgPSAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICA/ICcnXG4gICAgOiBTdHJpbmcodmFsdWUpO1xuXG4gIHZhciBieXRlcyA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlLCAndXRmLTgnKTtcbiAgdGhpcy53cml0ZUxlbmd0aENvZGVkTnVtYmVyKGJ5dGVzKTtcblxuICBpZiAoIWJ5dGVzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fYWxsb2NhdGUoYnl0ZXMpO1xuICB0aGlzLl9idWZmZXIud3JpdGUodmFsdWUsIHRoaXMuX29mZnNldCwgJ3V0Zi04Jyk7XG4gIHRoaXMuX29mZnNldCArPSBieXRlcztcbn07XG5cblBhY2tldFdyaXRlci5wcm90b3R5cGUuX2FsbG9jYXRlID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgaWYgKCF0aGlzLl9idWZmZXIpIHtcbiAgICB0aGlzLl9idWZmZXIgPSBuZXcgQnVmZmVyKGJ5dGVzKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYnl0ZXNSZW1haW5pbmcgPSB0aGlzLl9idWZmZXIubGVuZ3RoIC0gdGhpcy5fb2Zmc2V0O1xuICBpZiAoYnl0ZXNSZW1haW5pbmcgPj0gYnl0ZXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb2xkQnVmZmVyID0gdGhpcy5fYnVmZmVyO1xuXG4gIHRoaXMuX2J1ZmZlciA9IG5ldyBCdWZmZXIob2xkQnVmZmVyLmxlbmd0aCArIGJ5dGVzKTtcbiAgb2xkQnVmZmVyLmNvcHkodGhpcy5fYnVmZmVyKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9saWIvcHJvdG9jb2wvUGFja2V0V3JpdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBTcWxTdHJpbmcgPSBleHBvcnRzO1xuXG5TcWxTdHJpbmcuZXNjYXBlSWQgPSBmdW5jdGlvbiAodmFsLCBmb3JiaWRRdWFsaWZpZWQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiB2YWwubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBTcWxTdHJpbmcuZXNjYXBlSWQodiwgZm9yYmlkUXVhbGlmaWVkKTtcbiAgICB9KS5qb2luKCcsICcpO1xuICB9XG5cbiAgaWYgKGZvcmJpZFF1YWxpZmllZCkge1xuICAgIHJldHVybiAnYCcgKyB2YWwucmVwbGFjZSgvYC9nLCAnYGAnKSArICdgJztcbiAgfVxuICByZXR1cm4gJ2AnICsgdmFsLnJlcGxhY2UoL2AvZywgJ2BgJykucmVwbGFjZSgvXFwuL2csICdgLmAnKSArICdgJztcbn07XG5cblNxbFN0cmluZy5lc2NhcGUgPSBmdW5jdGlvbih2YWwsIHN0cmluZ2lmeU9iamVjdHMsIHRpbWVab25lKSB7XG4gIGlmICh2YWwgPT09IHVuZGVmaW5lZCB8fCB2YWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ05VTEwnO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlb2YgdmFsKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6IHJldHVybiAodmFsKSA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgY2FzZSAnbnVtYmVyJzogcmV0dXJuIHZhbCsnJztcbiAgfVxuXG4gIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgdmFsID0gU3FsU3RyaW5nLmRhdGVUb1N0cmluZyh2YWwsIHRpbWVab25lIHx8ICdsb2NhbCcpO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgcmV0dXJuIFNxbFN0cmluZy5idWZmZXJUb1N0cmluZyh2YWwpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiBTcWxTdHJpbmcuYXJyYXlUb0xpc3QodmFsLCB0aW1lWm9uZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoc3RyaW5naWZ5T2JqZWN0cykge1xuICAgICAgdmFsID0gdmFsLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBTcWxTdHJpbmcub2JqZWN0VG9WYWx1ZXModmFsLCB0aW1lWm9uZSk7XG4gICAgfVxuICB9XG5cbiAgdmFsID0gdmFsLnJlcGxhY2UoL1tcXDBcXG5cXHJcXGJcXHRcXFxcXFwnXFxcIlxceDFhXS9nLCBmdW5jdGlvbihzKSB7XG4gICAgc3dpdGNoKHMpIHtcbiAgICAgIGNhc2UgXCJcXDBcIjogcmV0dXJuIFwiXFxcXDBcIjtcbiAgICAgIGNhc2UgXCJcXG5cIjogcmV0dXJuIFwiXFxcXG5cIjtcbiAgICAgIGNhc2UgXCJcXHJcIjogcmV0dXJuIFwiXFxcXHJcIjtcbiAgICAgIGNhc2UgXCJcXGJcIjogcmV0dXJuIFwiXFxcXGJcIjtcbiAgICAgIGNhc2UgXCJcXHRcIjogcmV0dXJuIFwiXFxcXHRcIjtcbiAgICAgIGNhc2UgXCJcXHgxYVwiOiByZXR1cm4gXCJcXFxcWlwiO1xuICAgICAgZGVmYXVsdDogcmV0dXJuIFwiXFxcXFwiK3M7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFwiJ1wiK3ZhbCtcIidcIjtcbn07XG5cblNxbFN0cmluZy5hcnJheVRvTGlzdCA9IGZ1bmN0aW9uKGFycmF5LCB0aW1lWm9uZSkge1xuICByZXR1cm4gYXJyYXkubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkgcmV0dXJuICcoJyArIFNxbFN0cmluZy5hcnJheVRvTGlzdCh2LCB0aW1lWm9uZSkgKyAnKSc7XG4gICAgcmV0dXJuIFNxbFN0cmluZy5lc2NhcGUodiwgdHJ1ZSwgdGltZVpvbmUpO1xuICB9KS5qb2luKCcsICcpO1xufTtcblxuU3FsU3RyaW5nLmZvcm1hdCA9IGZ1bmN0aW9uKHNxbCwgdmFsdWVzLCBzdHJpbmdpZnlPYmplY3RzLCB0aW1lWm9uZSkge1xuICB2YWx1ZXMgPSB2YWx1ZXMgPT0gbnVsbCA/IFtdIDogW10uY29uY2F0KHZhbHVlcyk7XG5cbiAgdmFyIGluZGV4ID0gMDtcbiAgcmV0dXJuIHNxbC5yZXBsYWNlKC9cXD9cXD8/L2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKGluZGV4ID09PSB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gdmFsdWVzW2luZGV4KytdO1xuXG4gICAgcmV0dXJuIG1hdGNoID09PSAnPz8nXG4gICAgICA/IFNxbFN0cmluZy5lc2NhcGVJZCh2YWx1ZSlcbiAgICAgIDogU3FsU3RyaW5nLmVzY2FwZSh2YWx1ZSwgc3RyaW5naWZ5T2JqZWN0cywgdGltZVpvbmUpO1xuICB9KTtcbn07XG5cblNxbFN0cmluZy5kYXRlVG9TdHJpbmcgPSBmdW5jdGlvbiBkYXRlVG9TdHJpbmcoZGF0ZSwgdGltZVpvbmUpIHtcbiAgdmFyIGR0ID0gbmV3IERhdGUoZGF0ZSk7XG5cbiAgdmFyIHllYXI7XG4gIHZhciBtb250aDtcbiAgdmFyIGRheTtcbiAgdmFyIGhvdXI7XG4gIHZhciBtaW51dGU7XG4gIHZhciBzZWNvbmQ7XG4gIHZhciBtaWxsaXNlY29uZDtcblxuICBpZiAodGltZVpvbmUgPT09ICdsb2NhbCcpIHtcbiAgICB5ZWFyICAgICAgICA9IGR0LmdldEZ1bGxZZWFyKCk7XG4gICAgbW9udGggICAgICAgPSBkdC5nZXRNb250aCgpICsgMTtcbiAgICBkYXkgICAgICAgICA9IGR0LmdldERhdGUoKTtcbiAgICBob3VyICAgICAgICA9IGR0LmdldEhvdXJzKCk7XG4gICAgbWludXRlICAgICAgPSBkdC5nZXRNaW51dGVzKCk7XG4gICAgc2Vjb25kICAgICAgPSBkdC5nZXRTZWNvbmRzKCk7XG4gICAgbWlsbGlzZWNvbmQgPSBkdC5nZXRNaWxsaXNlY29uZHMoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHogPSBjb252ZXJ0VGltZXpvbmUodGltZVpvbmUpO1xuICAgIGlmICh0eiAhPT0gZmFsc2UpIHtcbiAgICAgIGR0LnNldFRpbWUoZHQuZ2V0VGltZSgpICsgKHR6ICogNjAwMDApKTtcbiAgICB9XG5cbiAgICB5ZWFyICAgICAgID0gZHQuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICBtb250aCAgICAgICA9IGR0LmdldFVUQ01vbnRoKCkgKyAxO1xuICAgIGRheSAgICAgICAgID0gZHQuZ2V0VVRDRGF0ZSgpO1xuICAgIGhvdXIgICAgICAgID0gZHQuZ2V0VVRDSG91cnMoKTtcbiAgICBtaW51dGUgICAgICA9IGR0LmdldFVUQ01pbnV0ZXMoKTtcbiAgICBzZWNvbmQgICAgICA9IGR0LmdldFVUQ1NlY29uZHMoKTtcbiAgICBtaWxsaXNlY29uZCA9IGR0LmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICB9XG5cbiAgLy8gWVlZWS1NTS1ERCBISDptbTpzcy5tbW1cbiAgcmV0dXJuIHplcm9QYWQoeWVhciwgNCkgKyAnLScgKyB6ZXJvUGFkKG1vbnRoLCAyKSArICctJyArIHplcm9QYWQoZGF5LCAyKSArICcgJyArXG4gICAgemVyb1BhZChob3VyLCAyKSArICc6JyArIHplcm9QYWQobWludXRlLCAyKSArICc6JyArIHplcm9QYWQoc2Vjb25kLCAyKSArICcuJyArXG4gICAgemVyb1BhZChtaWxsaXNlY29uZCwgMyk7XG59O1xuXG5TcWxTdHJpbmcuYnVmZmVyVG9TdHJpbmcgPSBmdW5jdGlvbiBidWZmZXJUb1N0cmluZyhidWZmZXIpIHtcbiAgcmV0dXJuIFwiWCdcIiArIGJ1ZmZlci50b1N0cmluZygnaGV4JykgKyBcIidcIjtcbn07XG5cblNxbFN0cmluZy5vYmplY3RUb1ZhbHVlcyA9IGZ1bmN0aW9uKG9iamVjdCwgdGltZVpvbmUpIHtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgaWYodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YWx1ZXMucHVzaCh0aGlzLmVzY2FwZUlkKGtleSkgKyAnID0gJyArIFNxbFN0cmluZy5lc2NhcGUodmFsdWUsIHRydWUsIHRpbWVab25lKSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWVzLmpvaW4oJywgJyk7XG59O1xuXG5mdW5jdGlvbiB6ZXJvUGFkKG51bWJlciwgbGVuZ3RoKSB7XG4gIG51bWJlciA9IG51bWJlci50b1N0cmluZygpO1xuICB3aGlsZSAobnVtYmVyLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgIG51bWJlciA9ICcwJyArIG51bWJlcjtcbiAgfVxuXG4gIHJldHVybiBudW1iZXI7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUaW1lem9uZSh0eikge1xuICBpZiAodHogPT0gXCJaXCIpIHJldHVybiAwO1xuXG4gIHZhciBtID0gdHoubWF0Y2goLyhbXFwrXFwtXFxzXSkoXFxkXFxkKTo/KFxcZFxcZCk/Lyk7XG4gIGlmIChtKSB7XG4gICAgcmV0dXJuIChtWzFdID09ICctJyA/IC0xIDogMSkgKiAocGFyc2VJbnQobVsyXSwgMTApICsgKChtWzNdID8gcGFyc2VJbnQobVszXSwgMTApIDogMCkgLyA2MCkpICogNjA7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbXlzcWwvbGliL3Byb3RvY29sL1NxbFN0cmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbXlzcWwgICAgICAgICAgPSByZXF1aXJlKCcuLi8nKTtcbnZhciBDb25uZWN0aW9uICAgICA9IHJlcXVpcmUoJy4vQ29ubmVjdGlvbicpO1xudmFyIEV2ZW50RW1pdHRlciAgID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIFV0aWwgICAgICAgICAgID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIFBvb2xDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9Qb29sQ29ubmVjdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2w7XG5cblV0aWwuaW5oZXJpdHMoUG9vbCwgRXZlbnRFbWl0dGVyKTtcbmZ1bmN0aW9uIFBvb2wob3B0aW9ucykge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5jb25maWcgPSBvcHRpb25zLmNvbmZpZztcbiAgdGhpcy5jb25maWcuY29ubmVjdGlvbkNvbmZpZy5wb29sID0gdGhpcztcblxuICB0aGlzLl9hY3F1aXJpbmdDb25uZWN0aW9ucyA9IFtdO1xuICB0aGlzLl9hbGxDb25uZWN0aW9ucyAgICAgICA9IFtdO1xuICB0aGlzLl9mcmVlQ29ubmVjdGlvbnMgICAgICA9IFtdO1xuICB0aGlzLl9jb25uZWN0aW9uUXVldWUgICAgICA9IFtdO1xuICB0aGlzLl9jbG9zZWQgICAgICAgICAgICAgICA9IGZhbHNlO1xufVxuXG5Qb29sLnByb3RvdHlwZS5nZXRDb25uZWN0aW9uID0gZnVuY3Rpb24gKGNiKSB7XG5cbiAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdQb29sIGlzIGNsb3NlZC4nKSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgY29ubmVjdGlvbjtcbiAgdmFyIHBvb2wgPSB0aGlzO1xuXG4gIGlmICh0aGlzLl9mcmVlQ29ubmVjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgIGNvbm5lY3Rpb24gPSB0aGlzLl9mcmVlQ29ubmVjdGlvbnMuc2hpZnQoKTtcblxuICAgIHJldHVybiB0aGlzLmFjcXVpcmVDb25uZWN0aW9uKGNvbm5lY3Rpb24sIGNiKTtcbiAgfVxuXG4gIGlmICh0aGlzLmNvbmZpZy5jb25uZWN0aW9uTGltaXQgPT09IDAgfHwgdGhpcy5fYWxsQ29ubmVjdGlvbnMubGVuZ3RoIDwgdGhpcy5jb25maWcuY29ubmVjdGlvbkxpbWl0KSB7XG4gICAgY29ubmVjdGlvbiA9IG5ldyBQb29sQ29ubmVjdGlvbih0aGlzLCB7IGNvbmZpZzogdGhpcy5jb25maWcubmV3Q29ubmVjdGlvbkNvbmZpZygpIH0pO1xuXG4gICAgdGhpcy5fYWNxdWlyaW5nQ29ubmVjdGlvbnMucHVzaChjb25uZWN0aW9uKTtcbiAgICB0aGlzLl9hbGxDb25uZWN0aW9ucy5wdXNoKGNvbm5lY3Rpb24pO1xuXG4gICAgcmV0dXJuIGNvbm5lY3Rpb24uY29ubmVjdCh7dGltZW91dDogdGhpcy5jb25maWcuYWNxdWlyZVRpbWVvdXR9LCBmdW5jdGlvbiBvbkNvbm5lY3QoZXJyKSB7XG4gICAgICBzcGxpY2VDb25uZWN0aW9uKHBvb2wuX2FjcXVpcmluZ0Nvbm5lY3Rpb25zLCBjb25uZWN0aW9uKTtcblxuICAgICAgaWYgKHBvb2wuX2Nsb3NlZCkge1xuICAgICAgICBlcnIgPSBuZXcgRXJyb3IoJ1Bvb2wgaXMgY2xvc2VkLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHBvb2wuX3B1cmdlQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwb29sLmVtaXQoJ2Nvbm5lY3Rpb24nLCBjb25uZWN0aW9uKTtcbiAgICAgIGNiKG51bGwsIGNvbm5lY3Rpb24pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCF0aGlzLmNvbmZpZy53YWl0Rm9yQ29ubmVjdGlvbnMpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignTm8gY29ubmVjdGlvbnMgYXZhaWxhYmxlLicpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuX2VucXVldWVDYWxsYmFjayhjYik7XG59O1xuXG5Qb29sLnByb3RvdHlwZS5hY3F1aXJlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIGFjcXVpcmVDb25uZWN0aW9uKGNvbm5lY3Rpb24sIGNiKSB7XG4gIGlmIChjb25uZWN0aW9uLl9wb29sICE9PSB0aGlzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb25uZWN0aW9uIGFjcXVpcmVkIGZyb20gd3JvbmcgcG9vbC4nKTtcbiAgfVxuXG4gIHZhciBjaGFuZ2VVc2VyID0gdGhpcy5fbmVlZHNDaGFuZ2VVc2VyKGNvbm5lY3Rpb24pO1xuICB2YXIgcG9vbCAgICAgICA9IHRoaXM7XG5cbiAgdGhpcy5fYWNxdWlyaW5nQ29ubmVjdGlvbnMucHVzaChjb25uZWN0aW9uKTtcblxuICBmdW5jdGlvbiBvbk9wZXJhdGlvbkNvbXBsZXRlKGVycikge1xuICAgIHNwbGljZUNvbm5lY3Rpb24ocG9vbC5fYWNxdWlyaW5nQ29ubmVjdGlvbnMsIGNvbm5lY3Rpb24pO1xuXG4gICAgaWYgKHBvb2wuX2Nsb3NlZCkge1xuICAgICAgZXJyID0gbmV3IEVycm9yKCdQb29sIGlzIGNsb3NlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBwb29sLl9jb25uZWN0aW9uUXVldWUudW5zaGlmdChjYik7XG4gICAgICBwb29sLl9wdXJnZUNvbm5lY3Rpb24oY29ubmVjdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZVVzZXIpIHtcbiAgICAgIHBvb2wuZW1pdCgnY29ubmVjdGlvbicsIGNvbm5lY3Rpb24pO1xuICAgIH1cblxuICAgIGNiKG51bGwsIGNvbm5lY3Rpb24pO1xuICB9XG5cbiAgaWYgKGNoYW5nZVVzZXIpIHtcbiAgICAvLyByZXN0b3JlIHVzZXIgYmFjayB0byBwb29sIGNvbmZpZ3VyYXRpb25cbiAgICBjb25uZWN0aW9uLmNvbmZpZyA9IHRoaXMuY29uZmlnLm5ld0Nvbm5lY3Rpb25Db25maWcoKTtcbiAgICBjb25uZWN0aW9uLmNoYW5nZVVzZXIoe3RpbWVvdXQ6IHRoaXMuY29uZmlnLmFjcXVpcmVUaW1lb3V0fSwgb25PcGVyYXRpb25Db21wbGV0ZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcGluZyBjb25uZWN0aW9uXG4gICAgY29ubmVjdGlvbi5waW5nKHt0aW1lb3V0OiB0aGlzLmNvbmZpZy5hY3F1aXJlVGltZW91dH0sIG9uT3BlcmF0aW9uQ29tcGxldGUpO1xuICB9XG59O1xuXG5Qb29sLnByb3RvdHlwZS5yZWxlYXNlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIHJlbGVhc2VDb25uZWN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgdmFyIGNiO1xuICB2YXIgcG9vbCA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuX2FjcXVpcmluZ0Nvbm5lY3Rpb25zLmluZGV4T2YoY29ubmVjdGlvbikgIT09IC0xKSB7XG4gICAgLy8gY29ubmVjdGlvbiBpcyBiZWluZyBhY3F1aXJlZFxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb25uZWN0aW9uLl9wb29sKSB7XG4gICAgaWYgKGNvbm5lY3Rpb24uX3Bvb2wgIT09IHRoaXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29ubmVjdGlvbiByZWxlYXNlZCB0byB3cm9uZyBwb29sJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZyZWVDb25uZWN0aW9ucy5pbmRleE9mKGNvbm5lY3Rpb24pICE9PSAtMSkge1xuICAgICAgLy8gY29ubmVjdGlvbiBhbHJlYWR5IGluIGZyZWUgY29ubmVjdGlvbiBwb29sXG4gICAgICAvLyB0aGlzIHdvbid0IGNhdGNoIGFsbCBkb3VibGUtcmVsZWFzZSBjYXNlc1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25uZWN0aW9uIGFscmVhZHkgcmVsZWFzZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYWRkIGNvbm5lY3Rpb24gdG8gZW5kIG9mIGZyZWUgcXVldWVcbiAgICAgIHRoaXMuX2ZyZWVDb25uZWN0aW9ucy5wdXNoKGNvbm5lY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlICh0aGlzLl9jbG9zZWQgJiYgdGhpcy5fY29ubmVjdGlvblF1ZXVlLmxlbmd0aCkge1xuICAgIC8vIGVtcHR5IHRoZSBjb25uZWN0aW9uIHF1ZXVlXG4gICAgY2IgPSB0aGlzLl9jb25uZWN0aW9uUXVldWUuc2hpZnQoKTtcblxuICAgIHByb2Nlc3MubmV4dFRpY2soY2IuYmluZChudWxsLCBuZXcgRXJyb3IoJ1Bvb2wgaXMgY2xvc2VkLicpKSk7XG4gIH1cblxuICBpZiAodGhpcy5fY29ubmVjdGlvblF1ZXVlLmxlbmd0aCkge1xuICAgIGNiID0gdGhpcy5fY29ubmVjdGlvblF1ZXVlLnNoaWZ0KCk7XG5cbiAgICB0aGlzLmdldENvbm5lY3Rpb24oY2IpO1xuICB9XG59O1xuXG5Qb29sLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2IpIHtcbiAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGNiICE9IFwiZnVuY3Rpb25cIikge1xuICAgIGNiID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikgdGhyb3cgZXJyO1xuICAgIH07XG4gIH1cblxuICB2YXIgY2FsbGVkQmFjayAgID0gZmFsc2U7XG4gIHZhciB3YWl0aW5nQ2xvc2UgPSB0aGlzLl9hbGxDb25uZWN0aW9ucy5sZW5ndGg7XG5cbiAgZnVuY3Rpb24gb25FbmQoZXJyKSB7XG4gICAgaWYgKGNhbGxlZEJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXJyIHx8IC0td2FpdGluZ0Nsb3NlID09PSAwKSB7XG4gICAgICBjYWxsZWRCYWNrID0gdHJ1ZTtcbiAgICAgIHJldHVybiBjYihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh3YWl0aW5nQ2xvc2UgPT09IDApIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhjYik7XG4gIH1cblxuICB3aGlsZSAodGhpcy5fYWxsQ29ubmVjdGlvbnMubGVuZ3RoICE9PSAwKSB7XG4gICAgdGhpcy5fcHVyZ2VDb25uZWN0aW9uKHRoaXMuX2FsbENvbm5lY3Rpb25zWzBdLCBvbkVuZCk7XG4gIH1cbn07XG5cblBvb2wucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKHNxbCwgdmFsdWVzLCBjYikge1xuICB2YXIgcXVlcnkgPSBDb25uZWN0aW9uLmNyZWF0ZVF1ZXJ5KHNxbCwgdmFsdWVzLCBjYik7XG5cbiAgaWYgKCEodHlwZW9mIHNxbCA9PT0gJ29iamVjdCcgJiYgJ3R5cGVDYXN0JyBpbiBzcWwpKSB7XG4gICAgcXVlcnkudHlwZUNhc3QgPSB0aGlzLmNvbmZpZy5jb25uZWN0aW9uQ29uZmlnLnR5cGVDYXN0O1xuICB9XG5cbiAgaWYgKHRoaXMuY29uZmlnLmNvbm5lY3Rpb25Db25maWcudHJhY2UpIHtcbiAgICAvLyBMb25nIHN0YWNrIHRyYWNlIHN1cHBvcnRcbiAgICBxdWVyeS5fY2FsbFNpdGUgPSBuZXcgRXJyb3I7XG4gIH1cblxuICB0aGlzLmdldENvbm5lY3Rpb24oZnVuY3Rpb24gKGVyciwgY29ubikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHF1ZXJ5Lm9uKCdlcnJvcicsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgIHF1ZXJ5LmVuZChlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJlbGVhc2UgY29ubmVjdGlvbiBiYXNlZCBvZmYgZXZlbnRcbiAgICBxdWVyeS5vbmNlKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbm4ucmVsZWFzZSgpO1xuICAgIH0pO1xuXG4gICAgY29ubi5xdWVyeShxdWVyeSk7XG4gIH0pO1xuXG4gIHJldHVybiBxdWVyeTtcbn07XG5cblBvb2wucHJvdG90eXBlLl9lbnF1ZXVlQ2FsbGJhY2sgPSBmdW5jdGlvbiBfZW5xdWV1ZUNhbGxiYWNrKGNhbGxiYWNrKSB7XG5cbiAgaWYgKHRoaXMuY29uZmlnLnF1ZXVlTGltaXQgJiYgdGhpcy5fY29ubmVjdGlvblF1ZXVlLmxlbmd0aCA+PSB0aGlzLmNvbmZpZy5xdWV1ZUxpbWl0KSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdRdWV1ZSBsaW1pdCByZWFjaGVkLicpO1xuICAgICAgZXJyLmNvZGUgPSAnUE9PTF9FTlFVRVVFTElNSVQnO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBCaW5kIHRvIGRvbWFpbiwgYXMgZGVxdWV1ZSB3aWxsIGxpa2VseSBvY2N1ciBpbiBhIGRpZmZlcmVudCBkb21haW5cbiAgdmFyIGNiID0gcHJvY2Vzcy5kb21haW5cbiAgICA/IHByb2Nlc3MuZG9tYWluLmJpbmQoY2FsbGJhY2spXG4gICAgOiBjYWxsYmFjaztcblxuICB0aGlzLl9jb25uZWN0aW9uUXVldWUucHVzaChjYik7XG4gIHRoaXMuZW1pdCgnZW5xdWV1ZScpO1xufTtcblxuUG9vbC5wcm90b3R5cGUuX25lZWRzQ2hhbmdlVXNlciA9IGZ1bmN0aW9uIF9uZWVkc0NoYW5nZVVzZXIoY29ubmVjdGlvbikge1xuICB2YXIgY29ubkNvbmZpZyA9IGNvbm5lY3Rpb24uY29uZmlnO1xuICB2YXIgcG9vbENvbmZpZyA9IHRoaXMuY29uZmlnLmNvbm5lY3Rpb25Db25maWc7XG5cbiAgLy8gY2hlY2sgaWYgY2hhbmdlVXNlciB2YWx1ZXMgYXJlIGRpZmZlcmVudFxuICByZXR1cm4gY29ubkNvbmZpZy51c2VyICE9PSBwb29sQ29uZmlnLnVzZXJcbiAgICB8fCBjb25uQ29uZmlnLmRhdGFiYXNlICE9PSBwb29sQ29uZmlnLmRhdGFiYXNlXG4gICAgfHwgY29ubkNvbmZpZy5wYXNzd29yZCAhPT0gcG9vbENvbmZpZy5wYXNzd29yZFxuICAgIHx8IGNvbm5Db25maWcuY2hhcnNldE51bWJlciAhPT0gcG9vbENvbmZpZy5jaGFyc2V0TnVtYmVyO1xufVxuXG5Qb29sLnByb3RvdHlwZS5fcHVyZ2VDb25uZWN0aW9uID0gZnVuY3Rpb24gX3B1cmdlQ29ubmVjdGlvbihjb25uZWN0aW9uLCBjYWxsYmFjaykge1xuICB2YXIgY2IgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICBpZiAoY29ubmVjdGlvbi5zdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICBjb25uZWN0aW9uLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHRoaXMuX3JlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbik7XG5cbiAgaWYgKGNvbm5lY3Rpb24uc3RhdGUgIT09ICdkaXNjb25uZWN0ZWQnICYmICFjb25uZWN0aW9uLl9wcm90b2NvbC5fcXVpdFNlcXVlbmNlKSB7XG4gICAgY29ubmVjdGlvbi5fcmVhbEVuZChjYik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvY2Vzcy5uZXh0VGljayhjYik7XG59O1xuXG5Qb29sLnByb3RvdHlwZS5fcmVtb3ZlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgY29ubmVjdGlvbi5fcG9vbCA9IG51bGw7XG5cbiAgLy8gUmVtb3ZlIGNvbm5lY3Rpb24gZnJvbSBhbGwgY29ubmVjdGlvbnNcbiAgc3BsaWNlQ29ubmVjdGlvbih0aGlzLl9hbGxDb25uZWN0aW9ucywgY29ubmVjdGlvbik7XG5cbiAgLy8gUmVtb3ZlIGNvbm5lY3Rpb24gZnJvbSBmcmVlIGNvbm5lY3Rpb25zXG4gIHNwbGljZUNvbm5lY3Rpb24odGhpcy5fZnJlZUNvbm5lY3Rpb25zLCBjb25uZWN0aW9uKTtcblxuICB0aGlzLnJlbGVhc2VDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xufTtcblxuUG9vbC5wcm90b3R5cGUuZXNjYXBlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIG15c3FsLmVzY2FwZSh2YWx1ZSwgdGhpcy5jb25maWcuY29ubmVjdGlvbkNvbmZpZy5zdHJpbmdpZnlPYmplY3RzLCB0aGlzLmNvbmZpZy5jb25uZWN0aW9uQ29uZmlnLnRpbWV6b25lKTtcbn07XG5cblBvb2wucHJvdG90eXBlLmVzY2FwZUlkID0gZnVuY3Rpb24gZXNjYXBlSWQodmFsdWUpIHtcbiAgcmV0dXJuIG15c3FsLmVzY2FwZUlkKHZhbHVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiBzcGxpY2VDb25uZWN0aW9uKGFycmF5LCBjb25uZWN0aW9uKSB7XG4gIHZhciBpbmRleDtcbiAgaWYgKChpbmRleCA9IGFycmF5LmluZGV4T2YoY29ubmVjdGlvbikpICE9PSAtMSkge1xuICAgIC8vIFJlbW92ZSBjb25uZWN0aW9uIGZyb20gYWxsIGNvbm5lY3Rpb25zXG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbXlzcWwvbGliL1Bvb2wuanNcbiAqKiBtb2R1bGUgaWQgPSA4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xudmFyIENvbm5lY3Rpb24gPSByZXF1aXJlKCcuL0Nvbm5lY3Rpb24nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xDb25uZWN0aW9uO1xuaW5oZXJpdHMoUG9vbENvbm5lY3Rpb24sIENvbm5lY3Rpb24pO1xuXG5mdW5jdGlvbiBQb29sQ29ubmVjdGlvbihwb29sLCBvcHRpb25zKSB7XG4gIENvbm5lY3Rpb24uY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5fcG9vbCAgPSBwb29sO1xuXG4gIC8vIFdoZW4gYSBmYXRhbCBlcnJvciBvY2N1cnMgdGhlIGNvbm5lY3Rpb24ncyBwcm90b2NvbCBlbmRzLCB3aGljaCB3aWxsIGNhdXNlXG4gIC8vIHRoZSBjb25uZWN0aW9uIHRvIGVuZCBhcyB3ZWxsLCB0aHVzIHdlIG9ubHkgbmVlZCB0byB3YXRjaCBmb3IgdGhlIGVuZCBldmVudFxuICAvLyBhbmQgd2Ugd2lsbCBiZSBub3RpZmllZCBvZiBkaXNjb25uZWN0cy5cbiAgdGhpcy5vbignZW5kJywgdGhpcy5fcmVtb3ZlRnJvbVBvb2wpO1xuICB0aGlzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyLmZhdGFsKSB7XG4gICAgICB0aGlzLl9yZW1vdmVGcm9tUG9vbCgpO1xuICAgIH1cbiAgfSk7XG59XG5cblBvb2xDb25uZWN0aW9uLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24gcmVsZWFzZSgpIHtcbiAgdmFyIHBvb2wgPSB0aGlzLl9wb29sO1xuICB2YXIgY29ubmVjdGlvbiA9IHRoaXM7XG5cbiAgaWYgKCFwb29sIHx8IHBvb2wuX2Nsb3NlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBwb29sLnJlbGVhc2VDb25uZWN0aW9uKHRoaXMpO1xufTtcblxuLy8gVE9ETzogUmVtb3ZlIHRoaXMgd2hlbiB3ZSBhcmUgcmVtb3ZpbmcgUG9vbENvbm5lY3Rpb24jZW5kXG5Qb29sQ29ubmVjdGlvbi5wcm90b3R5cGUuX3JlYWxFbmQgPSBDb25uZWN0aW9uLnByb3RvdHlwZS5lbmQ7XG5cblBvb2xDb25uZWN0aW9uLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnNvbGUud2FybiggJ0NhbGxpbmcgY29ubi5lbmQoKSB0byByZWxlYXNlIGEgcG9vbGVkIGNvbm5lY3Rpb24gaXMgJ1xuICAgICAgICAgICAgICArICdkZXByZWNhdGVkLiBJbiBuZXh0IHZlcnNpb24gY2FsbGluZyBjb25uLmVuZCgpIHdpbGwgYmUgJ1xuICAgICAgICAgICAgICArICdyZXN0b3JlZCB0byBkZWZhdWx0IGNvbm4uZW5kKCkgYmVoYXZpb3IuIFVzZSAnXG4gICAgICAgICAgICAgICsgJ2Nvbm4ucmVsZWFzZSgpIGluc3RlYWQuJ1xuICAgICAgICAgICAgICApO1xuICB0aGlzLnJlbGVhc2UoKTtcbn07XG5cblBvb2xDb25uZWN0aW9uLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9yZW1vdmVGcm9tUG9vbCh0aGlzKTtcbiAgcmV0dXJuIENvbm5lY3Rpb24ucHJvdG90eXBlLmRlc3Ryb3kuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cblBvb2xDb25uZWN0aW9uLnByb3RvdHlwZS5fcmVtb3ZlRnJvbVBvb2wgPSBmdW5jdGlvbiBfcmVtb3ZlRnJvbVBvb2woKSB7XG4gIGlmICghdGhpcy5fcG9vbCB8fCB0aGlzLl9wb29sLl9jbG9zZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcG9vbCA9IHRoaXMuX3Bvb2w7XG4gIHRoaXMuX3Bvb2wgPSBudWxsO1xuXG4gIHBvb2wuX3B1cmdlQ29ubmVjdGlvbih0aGlzKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9saWIvUG9vbENvbm5lY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIFBvb2wgICAgICAgICAgPSByZXF1aXJlKCcuL1Bvb2wnKTtcbnZhciBQb29sQ29uZmlnICAgID0gcmVxdWlyZSgnLi9Qb29sQ29uZmlnJyk7XG52YXIgUG9vbE5hbWVzcGFjZSA9IHJlcXVpcmUoJy4vUG9vbE5hbWVzcGFjZScpO1xudmFyIFBvb2xTZWxlY3RvciAgPSByZXF1aXJlKCcuL1Bvb2xTZWxlY3RvcicpO1xudmFyIFV0aWwgICAgICAgICAgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgRXZlbnRFbWl0dGVyICA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBQb29sQ2x1c3RlcjtcblxuLyoqXG4gKiBQb29sQ2x1c3RlclxuICovXG5mdW5jdGlvbiBQb29sQ2x1c3Rlcihjb25maWcpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICB0aGlzLl9jYW5SZXRyeSA9IHR5cGVvZiBjb25maWcuY2FuUmV0cnkgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IGNvbmZpZy5jYW5SZXRyeTtcbiAgdGhpcy5fZGVmYXVsdFNlbGVjdG9yID0gY29uZmlnLmRlZmF1bHRTZWxlY3RvciB8fCAnUlInO1xuICB0aGlzLl9yZW1vdmVOb2RlRXJyb3JDb3VudCA9IGNvbmZpZy5yZW1vdmVOb2RlRXJyb3JDb3VudCB8fCA1O1xuICB0aGlzLl9yZXN0b3JlTm9kZVRpbWVvdXQgPSBjb25maWcucmVzdG9yZU5vZGVUaW1lb3V0IHx8IDA7XG5cbiAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gIHRoaXMuX2ZpbmRDYWNoZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9sYXN0SWQgPSAwO1xuICB0aGlzLl9uYW1lc3BhY2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fbm9kZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG5VdGlsLmluaGVyaXRzKFBvb2xDbHVzdGVyLCBFdmVudEVtaXR0ZXIpO1xuXG5Qb29sQ2x1c3Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGlkLCBjb25maWcpIHtcbiAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUG9vbENsdXN0ZXIgaXMgY2xvc2VkLicpO1xuICB9XG5cbiAgdmFyIG5vZGVJZCA9IHR5cGVvZiBpZCA9PT0gJ29iamVjdCdcbiAgICA/ICdDTFVTVEVSOjonICsgKCsrdGhpcy5fbGFzdElkKVxuICAgIDogU3RyaW5nKGlkKTtcblxuICBpZiAodGhpcy5fbm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb2RlIElEIFwiJyArIG5vZGVJZCArICdcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gUG9vbENsdXN0ZXIuJyk7XG4gIH1cblxuICB2YXIgcG9vbENvbmZpZyA9IHR5cGVvZiBpZCAhPT0gJ29iamVjdCdcbiAgICA/IG5ldyBQb29sQ29uZmlnKGNvbmZpZylcbiAgICA6IG5ldyBQb29sQ29uZmlnKGlkKTtcblxuICB0aGlzLl9ub2Rlc1tub2RlSWRdID0ge1xuICAgIGlkICAgICAgICAgICAgOiBub2RlSWQsXG4gICAgZXJyb3JDb3VudCAgICA6IDAsXG4gICAgcG9vbCAgICAgICAgICA6IG5ldyBQb29sKHtjb25maWc6IHBvb2xDb25maWd9KSxcbiAgICBfb2ZmbGluZVVudGlsIDogMFxuICB9O1xuXG4gIHRoaXMuX2NsZWFyRmluZENhY2hlcygpO1xufTtcblxuUG9vbENsdXN0ZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZChjYWxsYmFjaykge1xuICB2YXIgY2IgPSBjYWxsYmFjayAhPT0gdW5kZWZpbmVkXG4gICAgPyBjYWxsYmFja1xuICAgIDogX2NiO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2NhbGxiYWNrIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpXG4gIH1cblxuICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soY2IpO1xuICB9XG5cbiAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcblxuICB2YXIgY2FsbGVkQmFjayAgID0gZmFsc2U7XG4gIHZhciBub2RlSWRzICAgICAgPSBPYmplY3Qua2V5cyh0aGlzLl9ub2Rlcyk7XG4gIHZhciB3YWl0aW5nQ2xvc2UgPSBub2RlSWRzLmxlbmd0aDtcblxuICBmdW5jdGlvbiBvbkVuZChlcnIpIHtcbiAgICBpZiAoY2FsbGVkQmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlcnIgfHwgLS13YWl0aW5nQ2xvc2UgPT09IDApIHtcbiAgICAgIGNhbGxlZEJhY2sgPSB0cnVlO1xuICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgfVxuICB9XG5cbiAgaWYgKHdhaXRpbmdDbG9zZSA9PT0gMCkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGNiKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUlkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlSWQgPSBub2RlSWRzW2ldO1xuICAgIHZhciBub2RlID0gdGhpcy5fbm9kZXNbbm9kZUlkXTtcblxuICAgIG5vZGUucG9vbC5lbmQob25FbmQpO1xuICB9XG59O1xuXG5Qb29sQ2x1c3Rlci5wcm90b3R5cGUub2YgPSBmdW5jdGlvbihwYXR0ZXJuLCBzZWxlY3Rvcikge1xuICBwYXR0ZXJuID0gcGF0dGVybiB8fCAnKic7XG5cbiAgc2VsZWN0b3IgPSBzZWxlY3RvciB8fCB0aGlzLl9kZWZhdWx0U2VsZWN0b3I7XG4gIHNlbGVjdG9yID0gc2VsZWN0b3IudG9VcHBlckNhc2UoKTtcbiAgaWYgKHR5cGVvZiBQb29sU2VsZWN0b3Jbc2VsZWN0b3JdID09PSAndW5kZWZpbmVkJykge1xuICAgIHNlbGVjdG9yID0gdGhpcy5fZGVmYXVsdFNlbGVjdG9yO1xuICB9XG5cbiAgdmFyIGtleSA9IHBhdHRlcm4gKyBzZWxlY3RvcjtcblxuICBpZiAodHlwZW9mIHRoaXMuX25hbWVzcGFjZXNba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLl9uYW1lc3BhY2VzW2tleV0gPSBuZXcgUG9vbE5hbWVzcGFjZSh0aGlzLCBwYXR0ZXJuLCBzZWxlY3Rvcik7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fbmFtZXNwYWNlc1trZXldO1xufTtcblxuUG9vbENsdXN0ZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShwYXR0ZXJuKSB7XG4gIHZhciBmb3VuZE5vZGVJZHMgPSB0aGlzLl9maW5kTm9kZUlkcyhwYXR0ZXJuLCB0cnVlKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZvdW5kTm9kZUlkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gdGhpcy5fZ2V0Tm9kZShmb3VuZE5vZGVJZHNbaV0pO1xuXG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIHRoaXMuX3JlbW92ZU5vZGUobm9kZSk7XG4gICAgfVxuICB9XG59O1xuXG5Qb29sQ2x1c3Rlci5wcm90b3R5cGUuZ2V0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uKHBhdHRlcm4sIHNlbGVjdG9yLCBjYikge1xuICB2YXIgbmFtZXNwYWNlO1xuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IHBhdHRlcm47XG4gICAgbmFtZXNwYWNlID0gdGhpcy5vZigpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gc2VsZWN0b3I7XG4gICAgICBzZWxlY3RvciA9IHRoaXMuX2RlZmF1bHRTZWxlY3RvcjtcbiAgICB9XG5cbiAgICBuYW1lc3BhY2UgPSB0aGlzLm9mKHBhdHRlcm4sIHNlbGVjdG9yKTtcbiAgfVxuXG4gIG5hbWVzcGFjZS5nZXRDb25uZWN0aW9uKGNiKTtcbn07XG5cblBvb2xDbHVzdGVyLnByb3RvdHlwZS5fY2xlYXJGaW5kQ2FjaGVzID0gZnVuY3Rpb24gX2NsZWFyRmluZENhY2hlcygpIHtcbiAgdGhpcy5fZmluZENhY2hlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG59O1xuXG5Qb29sQ2x1c3Rlci5wcm90b3R5cGUuX2RlY3JlYXNlRXJyb3JDb3VudCA9IGZ1bmN0aW9uIF9kZWNyZWFzZUVycm9yQ291bnQobm9kZSkge1xuICB2YXIgZXJyb3JDb3VudCA9IG5vZGUuZXJyb3JDb3VudDtcblxuICBpZiAoZXJyb3JDb3VudCA+IHRoaXMuX3JlbW92ZU5vZGVFcnJvckNvdW50KSB7XG4gICAgZXJyb3JDb3VudCA9IHRoaXMuX3JlbW92ZU5vZGVFcnJvckNvdW50O1xuICB9XG5cbiAgaWYgKGVycm9yQ291bnQgPCAxKSB7XG4gICAgZXJyb3JDb3VudCA9IDE7XG4gIH1cblxuICBub2RlLmVycm9yQ291bnQgPSBlcnJvckNvdW50IC0gMTtcblxuICBpZiAobm9kZS5fb2ZmbGluZVVudGlsKSB7XG4gICAgbm9kZS5fb2ZmbGluZVVudGlsID0gMDtcbiAgICB0aGlzLmVtaXQoJ29ubGluZScsIG5vZGUuaWQpO1xuICB9XG59O1xuXG5Qb29sQ2x1c3Rlci5wcm90b3R5cGUuX2ZpbmROb2RlSWRzID0gZnVuY3Rpb24gX2ZpbmROb2RlSWRzKHBhdHRlcm4sIGluY2x1ZGVPZmZsaW5lKSB7XG4gIHZhciBjdXJyZW50VGltZSAgPSAwO1xuICB2YXIgZm91bmROb2RlSWRzID0gdGhpcy5fZmluZENhY2hlc1twYXR0ZXJuXTtcblxuICBpZiAoZm91bmROb2RlSWRzID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbm9kZUlkcyAgPSBPYmplY3Qua2V5cyh0aGlzLl9ub2Rlcyk7XG4gICAgdmFyIHdpbGRjYXJkID0gcGF0dGVybi5zdWJzdHIoLTEpID09PSAnKic7XG4gICAgdmFyIGtleXdvcmQgID0gd2lsZGNhcmRcbiAgICAgID8gcGF0dGVybi5zdWJzdHIoMCwgcGF0dGVybi5sZW5ndGggLSAxKVxuICAgICAgOiBwYXR0ZXJuO1xuXG4gICAgaWYgKHdpbGRjYXJkKSB7XG4gICAgICBmb3VuZE5vZGVJZHMgPSBrZXl3b3JkLmxlbmd0aCAhPT0gMFxuICAgICAgICA/IG5vZGVJZHMuZmlsdGVyKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gaWQuc3Vic3RyKDAsIGtleXdvcmQubGVuZ3RoKSA9PT0ga2V5d29yZDsgfSlcbiAgICAgICAgOiBub2RlSWRzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaW5kZXggPSBub2RlSWRzLmluZGV4T2Yoa2V5d29yZCk7XG4gICAgICBmb3VuZE5vZGVJZHMgPSBub2RlSWRzLnNsaWNlKGluZGV4LCBpbmRleCArIDEpO1xuICAgIH1cblxuICAgIHRoaXMuX2ZpbmRDYWNoZXNbcGF0dGVybl0gPSBmb3VuZE5vZGVJZHM7XG4gIH1cblxuICBpZiAoaW5jbHVkZU9mZmxpbmUpIHtcbiAgICByZXR1cm4gZm91bmROb2RlSWRzO1xuICB9XG5cbiAgcmV0dXJuIGZvdW5kTm9kZUlkcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgIHZhciBub2RlID0gdGhpcy5fZ2V0Tm9kZShub2RlSWQpO1xuXG4gICAgaWYgKCFub2RlLl9vZmZsaW5lVW50aWwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghY3VycmVudFRpbWUpIHtcbiAgICAgIGN1cnJlbnRUaW1lID0gZ2V0TW9ub3RvbmljTWlsbGlzZWNvbmRzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGUuX29mZmxpbmVVbnRpbCA8PSBjdXJyZW50VGltZTtcbiAgfSwgdGhpcyk7XG59O1xuXG5Qb29sQ2x1c3Rlci5wcm90b3R5cGUuX2dldE5vZGUgPSBmdW5jdGlvbiBfZ2V0Tm9kZShpZCkge1xuICByZXR1cm4gdGhpcy5fbm9kZXNbaWRdIHx8IG51bGw7XG59O1xuXG5Qb29sQ2x1c3Rlci5wcm90b3R5cGUuX2luY3JlYXNlRXJyb3JDb3VudCA9IGZ1bmN0aW9uIF9pbmNyZWFzZUVycm9yQ291bnQobm9kZSkge1xuICB2YXIgZXJyb3JDb3VudCA9ICsrbm9kZS5lcnJvckNvdW50O1xuXG4gIGlmICh0aGlzLl9yZW1vdmVOb2RlRXJyb3JDb3VudCA+IGVycm9yQ291bnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5fcmVzdG9yZU5vZGVUaW1lb3V0ID4gMCkge1xuICAgIG5vZGUuX29mZmxpbmVVbnRpbCA9IGdldE1vbm90b25pY01pbGxpc2Vjb25kcygpICsgdGhpcy5fcmVzdG9yZU5vZGVUaW1lb3V0O1xuICAgIHRoaXMuZW1pdCgnb2ZmbGluZScsIG5vZGUuaWQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX3JlbW92ZU5vZGUobm9kZSk7XG4gIHRoaXMuZW1pdCgncmVtb3ZlJywgbm9kZS5pZCk7XG59O1xuXG5Qb29sQ2x1c3Rlci5wcm90b3R5cGUuX2dldENvbm5lY3Rpb24gPSBmdW5jdGlvbihub2RlLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgbm9kZS5wb29sLmdldENvbm5lY3Rpb24oZnVuY3Rpb24gKGVyciwgY29ubmVjdGlvbikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHNlbGYuX2luY3JlYXNlRXJyb3JDb3VudChub2RlKTtcbiAgICAgIGNiKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuX2RlY3JlYXNlRXJyb3JDb3VudChub2RlKTtcbiAgICB9XG5cbiAgICBjb25uZWN0aW9uLl9jbHVzdGVySWQgPSBub2RlLmlkO1xuXG4gICAgY2IobnVsbCwgY29ubmVjdGlvbik7XG4gIH0pO1xufTtcblxuUG9vbENsdXN0ZXIucHJvdG90eXBlLl9yZW1vdmVOb2RlID0gZnVuY3Rpb24gX3JlbW92ZU5vZGUobm9kZSkge1xuICBkZWxldGUgdGhpcy5fbm9kZXNbbm9kZS5pZF07XG5cbiAgdGhpcy5fY2xlYXJGaW5kQ2FjaGVzKCk7XG5cbiAgbm9kZS5wb29sLmVuZChfbm9vcCk7XG59O1xuXG5mdW5jdGlvbiBnZXRNb25vdG9uaWNNaWxsaXNlY29uZHMoKSB7XG4gIHZhciBtcztcblxuICBpZiAodHlwZW9mIHByb2Nlc3MuaHJ0aW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbXMgPSBwcm9jZXNzLmhydGltZSgpO1xuICAgIG1zID0gbXNbMF0gKiAxZTMgKyBtc1sxXSAqIDFlLTY7XG4gIH0gZWxzZSB7XG4gICAgbXMgPSBwcm9jZXNzLnVwdGltZSgpICogMTAwMDtcbiAgfVxuXG4gIHJldHVybiBNYXRoLmZsb29yKG1zKTtcbn1cblxuZnVuY3Rpb24gX2NiKGVycikge1xuICBpZiAoZXJyKSB7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9ub29wKCkge31cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL2xpYi9Qb29sQ2x1c3Rlci5qc1xuICoqIG1vZHVsZSBpZCA9IDg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbnZhciBDb25uZWN0aW9uQ29uZmlnID0gcmVxdWlyZSgnLi9Db25uZWN0aW9uQ29uZmlnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbENvbmZpZztcbmZ1bmN0aW9uIFBvb2xDb25maWcob3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IENvbm5lY3Rpb25Db25maWcucGFyc2VVcmwob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLmFjcXVpcmVUaW1lb3V0ICAgICA9IChvcHRpb25zLmFjcXVpcmVUaW1lb3V0ID09PSB1bmRlZmluZWQpXG4gICAgPyAxMCAqIDEwMDBcbiAgICA6IE51bWJlcihvcHRpb25zLmFjcXVpcmVUaW1lb3V0KTtcbiAgdGhpcy5jb25uZWN0aW9uQ29uZmlnICAgPSBuZXcgQ29ubmVjdGlvbkNvbmZpZyhvcHRpb25zKTtcbiAgdGhpcy53YWl0Rm9yQ29ubmVjdGlvbnMgPSAob3B0aW9ucy53YWl0Rm9yQ29ubmVjdGlvbnMgPT09IHVuZGVmaW5lZClcbiAgICA/IHRydWVcbiAgICA6IEJvb2xlYW4ob3B0aW9ucy53YWl0Rm9yQ29ubmVjdGlvbnMpO1xuICB0aGlzLmNvbm5lY3Rpb25MaW1pdCAgICA9IChvcHRpb25zLmNvbm5lY3Rpb25MaW1pdCA9PT0gdW5kZWZpbmVkKVxuICAgID8gMTBcbiAgICA6IE51bWJlcihvcHRpb25zLmNvbm5lY3Rpb25MaW1pdCk7XG4gIHRoaXMucXVldWVMaW1pdCAgICAgICAgID0gKG9wdGlvbnMucXVldWVMaW1pdCA9PT0gdW5kZWZpbmVkKVxuICAgID8gMFxuICAgIDogTnVtYmVyKG9wdGlvbnMucXVldWVMaW1pdCk7XG59XG5cblBvb2xDb25maWcucHJvdG90eXBlLm5ld0Nvbm5lY3Rpb25Db25maWcgPSBmdW5jdGlvbiBuZXdDb25uZWN0aW9uQ29uZmlnKCkge1xuICB2YXIgY29ubmVjdGlvbkNvbmZpZyA9IG5ldyBDb25uZWN0aW9uQ29uZmlnKHRoaXMuY29ubmVjdGlvbkNvbmZpZyk7XG5cbiAgY29ubmVjdGlvbkNvbmZpZy5jbGllbnRGbGFncyAgID0gdGhpcy5jb25uZWN0aW9uQ29uZmlnLmNsaWVudEZsYWdzO1xuICBjb25uZWN0aW9uQ29uZmlnLm1heFBhY2tldFNpemUgPSB0aGlzLmNvbm5lY3Rpb25Db25maWcubWF4UGFja2V0U2l6ZTtcblxuICByZXR1cm4gY29ubmVjdGlvbkNvbmZpZztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9saWIvUG9vbENvbmZpZy5qc1xuICoqIG1vZHVsZSBpZCA9IDg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgUG9vbFNlbGVjdG9yID0gcmVxdWlyZSgnLi9Qb29sU2VsZWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb29sTmFtZXNwYWNlO1xuXG4vKipcbiAqIFBvb2xOYW1lc3BhY2VcbiAqL1xuZnVuY3Rpb24gUG9vbE5hbWVzcGFjZShjbHVzdGVyLCBwYXR0ZXJuLCBzZWxlY3Rvcikge1xuICB0aGlzLl9jbHVzdGVyID0gY2x1c3RlcjtcbiAgdGhpcy5fcGF0dGVybiA9IHBhdHRlcm47XG4gIHRoaXMuX3NlbGVjdG9yID0gbmV3IFBvb2xTZWxlY3RvcltzZWxlY3Rvcl0oKTtcbn1cblxuUG9vbE5hbWVzcGFjZS5wcm90b3R5cGUuZ2V0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uKGNiKSB7XG4gIHZhciBjbHVzdGVyTm9kZSA9IHRoaXMuX2dldENsdXN0ZXJOb2RlKCk7XG4gIHZhciBjbHVzdGVyICAgICA9IHRoaXMuX2NsdXN0ZXI7XG4gIHZhciBuYW1lc3BhY2UgICA9IHRoaXM7XG5cbiAgaWYgKGNsdXN0ZXJOb2RlID09PSBudWxsKSB7XG4gICAgdmFyIGVyciA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5fY2x1c3Rlci5fZmluZE5vZGVJZHModGhpcy5fcGF0dGVybiwgdHJ1ZSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICBlcnIgPSBuZXcgRXJyb3IoJ1Bvb2wgZG9lcyBub3QgaGF2ZSBvbmxpbmUgbm9kZS4nKTtcbiAgICAgIGVyci5jb2RlID0gJ1BPT0xfTk9ORU9OTElORSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvcignUG9vbCBkb2VzIG5vdCBleGlzdC4nKTtcbiAgICAgIGVyci5jb2RlID0gJ1BPT0xfTk9FWElTVCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNiKGVycik7XG4gIH1cblxuICBjbHVzdGVyLl9nZXRDb25uZWN0aW9uKGNsdXN0ZXJOb2RlLCBmdW5jdGlvbihlcnIsIGNvbm5lY3Rpb24pIHtcbiAgICB2YXIgcmV0cnkgPSBlcnIgJiYgY2x1c3Rlci5fY2FuUmV0cnlcbiAgICAgICYmIGNsdXN0ZXIuX2ZpbmROb2RlSWRzKG5hbWVzcGFjZS5fcGF0dGVybikubGVuZ3RoICE9PSAwO1xuXG4gICAgaWYgKHJldHJ5KSB7XG4gICAgICByZXR1cm4gbmFtZXNwYWNlLmdldENvbm5lY3Rpb24oY2IpO1xuICAgIH1cblxuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYihlcnIpO1xuICAgIH1cblxuICAgIGNiKG51bGwsIGNvbm5lY3Rpb24pO1xuICB9KTtcbn07XG5cblBvb2xOYW1lc3BhY2UucHJvdG90eXBlLl9nZXRDbHVzdGVyTm9kZSA9IGZ1bmN0aW9uIF9nZXRDbHVzdGVyTm9kZSgpIHtcbiAgdmFyIGZvdW5kTm9kZUlkcyA9IHRoaXMuX2NsdXN0ZXIuX2ZpbmROb2RlSWRzKHRoaXMuX3BhdHRlcm4pO1xuICB2YXIgbm9kZUlkO1xuXG4gIHN3aXRjaCAoZm91bmROb2RlSWRzLmxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIG5vZGVJZCA9IG51bGw7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBub2RlSWQgPSBmb3VuZE5vZGVJZHNbMF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbm9kZUlkID0gdGhpcy5fc2VsZWN0b3IoZm91bmROb2RlSWRzKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIG5vZGVJZCAhPT0gbnVsbFxuICAgID8gdGhpcy5fY2x1c3Rlci5fZ2V0Tm9kZShub2RlSWQpXG4gICAgOiBudWxsO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L215c3FsL2xpYi9Qb29sTmFtZXNwYWNlLmpzXG4gKiogbW9kdWxlIGlkID0gODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBQb29sU2VsZWN0b3JcbiAqL1xudmFyIFBvb2xTZWxlY3RvciA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cblBvb2xTZWxlY3Rvci5SUiA9IGZ1bmN0aW9uIFBvb2xTZWxlY3RvclJvdW5kUm9iaW4oKSB7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGNsdXN0ZXJJZHMpIHtcbiAgICBpZiAoaW5kZXggPj0gY2x1c3Rlcklkcy5sZW5ndGgpIHtcbiAgICAgIGluZGV4ID0gMDtcbiAgICB9XG5cbiAgICB2YXIgY2x1c3RlcklkID0gY2x1c3Rlcklkc1tpbmRleCsrXTtcblxuICAgIHJldHVybiBjbHVzdGVySWQ7XG4gIH07XG59O1xuXG5Qb29sU2VsZWN0b3IuUkFORE9NID0gZnVuY3Rpb24gUG9vbFNlbGVjdG9yUmFuZG9tKCkge1xuICByZXR1cm4gZnVuY3Rpb24oY2x1c3Rlcklkcykge1xuICAgIHJldHVybiBjbHVzdGVySWRzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNsdXN0ZXJJZHMubGVuZ3RoKV07XG4gIH07XG59O1xuXG5Qb29sU2VsZWN0b3IuT1JERVIgPSBmdW5jdGlvbiBQb29sU2VsZWN0b3JPcmRlcigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNsdXN0ZXJJZHMpIHtcbiAgICByZXR1cm4gY2x1c3Rlcklkc1swXTtcbiAgfTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9teXNxbC9saWIvUG9vbFNlbGVjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gODdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=